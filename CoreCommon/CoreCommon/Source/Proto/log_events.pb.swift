// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: log_events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Server_Platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case ios // = 1
  case android // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ios
    case 2: self = .android
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ios: return 1
    case .android: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Platform] = [
    .unknown,
    .ios,
    .android,
  ]
}

#endif  // swift(>=4.2)

public struct Server_EventData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt64 {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  /// client platform `android` or `ios`
  public var platform: Server_Platform {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  /// client version (eg.`0.94`)
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// set by server to indicate when event was received
  public var timestampMs: UInt64 {
    get {return _storage._timestampMs}
    set {_uniqueStorage()._timestampMs = newValue}
  }

  /// 2 letter country code
  public var cc: String {
    get {return _storage._cc}
    set {_uniqueStorage()._cc = newValue}
  }

  public var edata: OneOf_Edata? {
    get {return _storage._edata}
    set {_uniqueStorage()._edata = newValue}
  }

  public var mediaUpload: Server_MediaUpload {
    get {
      if case .mediaUpload(let v)? = _storage._edata {return v}
      return Server_MediaUpload()
    }
    set {_uniqueStorage()._edata = .mediaUpload(newValue)}
  }

  public var mediaDownload: Server_MediaDownload {
    get {
      if case .mediaDownload(let v)? = _storage._edata {return v}
      return Server_MediaDownload()
    }
    set {_uniqueStorage()._edata = .mediaDownload(newValue)}
  }

  public var mediaComposeLoad: Server_MediaComposeLoad {
    get {
      if case .mediaComposeLoad(let v)? = _storage._edata {return v}
      return Server_MediaComposeLoad()
    }
    set {_uniqueStorage()._edata = .mediaComposeLoad(newValue)}
  }

  public var pushReceived: Server_PushReceived {
    get {
      if case .pushReceived(let v)? = _storage._edata {return v}
      return Server_PushReceived()
    }
    set {_uniqueStorage()._edata = .pushReceived(newValue)}
  }

  public var decryptionReport: Server_DecryptionReport {
    get {
      if case .decryptionReport(let v)? = _storage._edata {return v}
      return Server_DecryptionReport()
    }
    set {_uniqueStorage()._edata = .decryptionReport(newValue)}
  }

  public var permissions: Server_Permissions {
    get {
      if case .permissions(let v)? = _storage._edata {return v}
      return Server_Permissions()
    }
    set {_uniqueStorage()._edata = .permissions(newValue)}
  }

  public var mediaObjectDownload: Server_MediaObjectDownload {
    get {
      if case .mediaObjectDownload(let v)? = _storage._edata {return v}
      return Server_MediaObjectDownload()
    }
    set {_uniqueStorage()._edata = .mediaObjectDownload(newValue)}
  }

  public var groupDecryptionReport: Server_GroupDecryptionReport {
    get {
      if case .groupDecryptionReport(let v)? = _storage._edata {return v}
      return Server_GroupDecryptionReport()
    }
    set {_uniqueStorage()._edata = .groupDecryptionReport(newValue)}
  }

  public var call: Server_Call {
    get {
      if case .call(let v)? = _storage._edata {return v}
      return Server_Call()
    }
    set {_uniqueStorage()._edata = .call(newValue)}
  }

  public var fabAction: Server_FabAction {
    get {
      if case .fabAction(let v)? = _storage._edata {return v}
      return Server_FabAction()
    }
    set {_uniqueStorage()._edata = .fabAction(newValue)}
  }

  public var groupHistoryReport: Server_GroupHistoryReport {
    get {
      if case .groupHistoryReport(let v)? = _storage._edata {return v}
      return Server_GroupHistoryReport()
    }
    set {_uniqueStorage()._edata = .groupHistoryReport(newValue)}
  }

  public var homeDecryptionReport: Server_HomeDecryptionReport {
    get {
      if case .homeDecryptionReport(let v)? = _storage._edata {return v}
      return Server_HomeDecryptionReport()
    }
    set {_uniqueStorage()._edata = .homeDecryptionReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Edata: Equatable {
    case mediaUpload(Server_MediaUpload)
    case mediaDownload(Server_MediaDownload)
    case mediaComposeLoad(Server_MediaComposeLoad)
    case pushReceived(Server_PushReceived)
    case decryptionReport(Server_DecryptionReport)
    case permissions(Server_Permissions)
    case mediaObjectDownload(Server_MediaObjectDownload)
    case groupDecryptionReport(Server_GroupDecryptionReport)
    case call(Server_Call)
    case fabAction(Server_FabAction)
    case groupHistoryReport(Server_GroupHistoryReport)
    case homeDecryptionReport(Server_HomeDecryptionReport)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_EventData.OneOf_Edata, rhs: Server_EventData.OneOf_Edata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mediaUpload, .mediaUpload): return {
        guard case .mediaUpload(let l) = lhs, case .mediaUpload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaDownload, .mediaDownload): return {
        guard case .mediaDownload(let l) = lhs, case .mediaDownload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaComposeLoad, .mediaComposeLoad): return {
        guard case .mediaComposeLoad(let l) = lhs, case .mediaComposeLoad(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pushReceived, .pushReceived): return {
        guard case .pushReceived(let l) = lhs, case .pushReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.decryptionReport, .decryptionReport): return {
        guard case .decryptionReport(let l) = lhs, case .decryptionReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permissions, .permissions): return {
        guard case .permissions(let l) = lhs, case .permissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaObjectDownload, .mediaObjectDownload): return {
        guard case .mediaObjectDownload(let l) = lhs, case .mediaObjectDownload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupDecryptionReport, .groupDecryptionReport): return {
        guard case .groupDecryptionReport(let l) = lhs, case .groupDecryptionReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.call, .call): return {
        guard case .call(let l) = lhs, case .call(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fabAction, .fabAction): return {
        guard case .fabAction(let l) = lhs, case .fabAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupHistoryReport, .groupHistoryReport): return {
        guard case .groupHistoryReport(let l) = lhs, case .groupHistoryReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.homeDecryptionReport, .homeDecryptionReport): return {
        guard case .homeDecryptionReport(let l) = lhs, case .homeDecryptionReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Server_MediaObjectDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of post or message
  public var id: String = String()

  /// 0-based index of the media item in the post/msg
  public var index: UInt64 = 0

  public var type: Server_MediaObjectDownload.TypeEnum = .post

  public var mediaType: Server_MediaObjectDownload.MediaType = .photo

  /// time in ms it took to download the media object
  public var durationMs: UInt64 = 0

  /// byte size of the object
  public var size: UInt64 = 0

  /// number of bytes downloaded during this attempt
  public var progressBytes: UInt64 = 0

  /// should be cloudfront for now
  public var cdn: Server_MediaObjectDownload.Cdn = .unknownCdn

  /// value of the `x-amz-cf-pop` result header
  public var cdnPop: String = String()

  /// value of the `x-amz-cf-id` result header
  public var cdnID: String = String()

  public var cdnCache: Server_MediaObjectDownload.CdnCache = .unknownCache

  public var status: Server_MediaObjectDownload.Status = .ok

  /// number of attempts to download, either so far or until status=ok
  public var retryCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case post // = 0
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum MediaType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case photo // = 0
    case video // = 1
    case audio // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .photo
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .photo
      case 1: self = .video
      case 2: self = .audio
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .photo: return 0
      case .video: return 1
      case .audio: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Cdn: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownCdn // = 0
    case cloudfront // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownCdn
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownCdn
      case 1: self = .cloudfront
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownCdn: return 0
      case .cloudfront: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum CdnCache: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownCache // = 0
    case hit // = 1
    case miss // = 2
    case refreshHit // = 3
    case refreshMiss // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownCache
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownCache
      case 1: self = .hit
      case 2: self = .miss
      case 3: self = .refreshHit
      case 4: self = .refreshMiss
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownCache: return 0
      case .hit: return 1
      case .miss: return 2
      case .refreshHit: return 3
      case .refreshMiss: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaObjectDownload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaObjectDownload.MediaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.MediaType] = [
    .photo,
    .video,
    .audio,
  ]
}

extension Server_MediaObjectDownload.Cdn: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.Cdn] = [
    .unknownCdn,
    .cloudfront,
  ]
}

extension Server_MediaObjectDownload.CdnCache: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.CdnCache] = [
    .unknownCache,
    .hit,
    .miss,
    .refreshHit,
    .refreshMiss,
  ]
}

extension Server_MediaObjectDownload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaUpload.TypeEnum = .post

  /// time in ms it took to upload all the media and send iq/message
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects uploaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaUpload.Status = .ok

  /// 0 if upload worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaUpload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaUpload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaDownload.TypeEnum = .post

  /// time in ms it took to download all the media
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects downloaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaDownload.Status = .ok

  /// 0 if download worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaDownload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaDownload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaComposeLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// time in ms it took to load all the media and transcode them.
  public var durationMs: UInt32 = 0

  /// Basically until the share button shows up.
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects
  public var totalSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PushReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var clientTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DecryptionReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_DecryptionReport.Status = .ok

  public var reason: String = String()

  public var msgID: String = String()

  /// at time message id was first encountered
  public var originalVersion: String = String()

  public var senderPlatform: Server_Platform = .unknown

  public var senderVersion: String = String()

  public var rerequestCount: UInt32 = 0

  public var timeTakenS: UInt32 = 0

  public var isSilent: Bool = false

  public var contentType: Server_DecryptionReport.ContentType = .chat

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case groupHistory // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .groupHistory
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .groupHistory: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_DecryptionReport.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_DecryptionReport.Status] = [
    .ok,
    .fail,
  ]
}

extension Server_DecryptionReport.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_DecryptionReport.ContentType] = [
    .chat,
    .groupHistory,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupDecryptionReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_GroupDecryptionReport.Status = .unknownStatus

  public var reason: String = String()

  public var contentID: String = String()

  public var gid: String = String()

  public var itemType: Server_GroupDecryptionReport.ItemType = .unknownType

  /// at time msg id was first encountered
  public var originalVersion: String = String()

  public var rerequestCount: UInt32 = 0

  public var timeTakenS: UInt32 = 0

  public var senderPlatform: Server_Platform = .unknown

  public var senderVersion: String = String()

  public var schedule: Server_GroupDecryptionReport.Schedule = .daily

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownStatus // = 0
    case ok // = 1
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownStatus
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownStatus
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownStatus: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ItemType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case post // = 1
    case comment // = 2
    case historyResend // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .post
      case 2: self = .comment
      case 3: self = .historyResend
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .post: return 1
      case .comment: return 2
      case .historyResend: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Schedule: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case daily // = 0
    case resultBased // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .daily
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .daily
      case 1: self = .resultBased
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .daily: return 0
      case .resultBased: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupDecryptionReport.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupDecryptionReport.Status] = [
    .unknownStatus,
    .ok,
    .fail,
  ]
}

extension Server_GroupDecryptionReport.ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupDecryptionReport.ItemType] = [
    .unknownType,
    .post,
    .comment,
    .historyResend,
  ]
}

extension Server_GroupDecryptionReport.Schedule: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupDecryptionReport.Schedule] = [
    .daily,
    .resultBased,
  ]
}

#endif  // swift(>=4.2)

public struct Server_HomeDecryptionReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_HomeDecryptionReport.Status = .unknownStatus

  public var reason: String = String()

  public var contentID: String = String()

  public var audienceType: Server_HomeDecryptionReport.AudienceType = .unknownAudienceType

  public var itemType: Server_HomeDecryptionReport.ItemType = .unknownType

  /// at time msg id was first encountered
  public var originalVersion: String = String()

  public var rerequestCount: UInt32 = 0

  public var timeTakenS: UInt32 = 0

  public var senderPlatform: Server_Platform = .unknown

  public var senderVersion: String = String()

  public var schedule: Server_HomeDecryptionReport.Schedule = .daily

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownStatus // = 0
    case ok // = 1
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownStatus
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownStatus
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownStatus: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum AudienceType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownAudienceType // = 0
    case all // = 1
    case only // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownAudienceType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownAudienceType
      case 1: self = .all
      case 2: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownAudienceType: return 0
      case .all: return 1
      case .only: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ItemType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case post // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .post
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .post: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Schedule: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case daily // = 0
    case resultBased // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .daily
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .daily
      case 1: self = .resultBased
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .daily: return 0
      case .resultBased: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_HomeDecryptionReport.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeDecryptionReport.Status] = [
    .unknownStatus,
    .ok,
    .fail,
  ]
}

extension Server_HomeDecryptionReport.AudienceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeDecryptionReport.AudienceType] = [
    .unknownAudienceType,
    .all,
    .only,
  ]
}

extension Server_HomeDecryptionReport.ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeDecryptionReport.ItemType] = [
    .unknownType,
    .post,
    .comment,
  ]
}

extension Server_HomeDecryptionReport.Schedule: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeDecryptionReport.Schedule] = [
    .daily,
    .resultBased,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupHistoryReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var numExpected: UInt32 = 0

  public var numDecrypted: UInt32 = 0

  public var originalVersion: String = String()

  public var rerequestCount: UInt32 = 0

  public var timeTakenS: UInt32 = 0

  public var schedule: Server_GroupHistoryReport.Schedule = .daily

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Schedule: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case daily // = 0
    case resultBased // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .daily
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .daily
      case 1: self = .resultBased
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .daily: return 0
      case .resultBased: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupHistoryReport.Schedule: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupHistoryReport.Schedule] = [
    .daily,
    .resultBased,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Permissions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_Permissions.TypeEnum = .contacts

  public var status: Server_Permissions.Status = .allowed

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case contacts // = 0
    case notifications // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .contacts
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .contacts
      case 1: self = .notifications
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .contacts: return 0
      case .notifications: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case allowed // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowed
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowed
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowed: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Permissions.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Permissions.TypeEnum] = [
    .contacts,
    .notifications,
  ]
}

extension Server_Permissions.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Permissions.Status] = [
    .allowed,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var peerUid: UInt64 = 0

  public var type: Server_Call.CallType = .unknownType

  public var direction: Server_Call.CallDirection = .unknownDirection

  /// true if the call was answered
  public var answered: Bool = false

  /// true if the webrtc connects successful
  public var connected: Bool = false

  /// number of ms this call was in the in-call state
  public var durationMs: UInt64 = 0

  /// string representation of the end call reason as defined in the EndCall.Reason
  public var endCallReason: String = String()

  /// true if the end call happened locally, or false if the end call was received remotely
  public var localEndCall: Bool = false

  /// wifi or cellular
  public var networkType: Server_Call.NetworkType = .unknownNetwork

  public var isKrispActive: Bool = false

  /// time taken for ice connection state to be connected in ms.
  public var iceTimeTakenMs: UInt64 = 0

  public var webrtcStats: String = String()

  /// summary of the result of peer_connection.get_stats at the end of the call
  public var webrtcSummary: Server_WebrtcSummary {
    get {return _webrtcSummary ?? Server_WebrtcSummary()}
    set {_webrtcSummary = newValue}
  }
  /// Returns true if `webrtcSummary` has been explicitly set.
  public var hasWebrtcSummary: Bool {return self._webrtcSummary != nil}
  /// Clears the value of `webrtcSummary`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcSummary() {self._webrtcSummary = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CallType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case audio // = 1
    case video // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .audio
      case 2: self = .video
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .audio: return 1
      case .video: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum CallDirection: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownDirection // = 0
    case outgoing // = 1
    case incoming // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownDirection
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownDirection
      case 1: self = .outgoing
      case 2: self = .incoming
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownDirection: return 0
      case .outgoing: return 1
      case .incoming: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum NetworkType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownNetwork // = 0
    case wifi // = 1
    case cellular // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownNetwork
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownNetwork
      case 1: self = .wifi
      case 2: self = .cellular
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownNetwork: return 0
      case .wifi: return 1
      case .cellular: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _webrtcSummary: Server_WebrtcSummary? = nil
}

#if swift(>=4.2)

extension Server_Call.CallType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Call.CallType] = [
    .unknownType,
    .audio,
    .video,
  ]
}

extension Server_Call.CallDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Call.CallDirection] = [
    .unknownDirection,
    .outgoing,
    .incoming,
  ]
}

extension Server_Call.NetworkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Call.NetworkType] = [
    .unknownNetwork,
    .wifi,
    .cellular,
  ]
}

#endif  // swift(>=4.2)

public struct Server_WebrtcSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// everything here refers to local incoming / outgoing - no remote streams are considered
  public var audioStream: Server_StreamStats {
    get {return _storage._audioStream ?? Server_StreamStats()}
    set {_uniqueStorage()._audioStream = newValue}
  }
  /// Returns true if `audioStream` has been explicitly set.
  public var hasAudioStream: Bool {return _storage._audioStream != nil}
  /// Clears the value of `audioStream`. Subsequent reads from it will return its default value.
  public mutating func clearAudioStream() {_uniqueStorage()._audioStream = nil}

  public var videoStream: Server_StreamStats {
    get {return _storage._videoStream ?? Server_StreamStats()}
    set {_uniqueStorage()._videoStream = newValue}
  }
  /// Returns true if `videoStream` has been explicitly set.
  public var hasVideoStream: Bool {return _storage._videoStream != nil}
  /// Clears the value of `videoStream`. Subsequent reads from it will return its default value.
  public mutating func clearVideoStream() {_uniqueStorage()._videoStream = nil}

  public var audio: Server_AudioStats {
    get {return _storage._audio ?? Server_AudioStats()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {_uniqueStorage()._audio = nil}

  public var video: Server_VideoStats {
    get {return _storage._video ?? Server_VideoStats()}
    set {_uniqueStorage()._video = newValue}
  }
  /// Returns true if `video` has been explicitly set.
  public var hasVideo: Bool {return _storage._video != nil}
  /// Clears the value of `video`. Subsequent reads from it will return its default value.
  public mutating func clearVideo() {_uniqueStorage()._video = nil}

  public var candidatePairs: [Server_CandidatePairStats] {
    get {return _storage._candidatePairs}
    set {_uniqueStorage()._candidatePairs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Server_StreamStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///outgoing
  public var packetsSent: UInt64 = 0

  /// incoming
  public var packetsLost: UInt64 = 0

  public var packetsReceived: UInt64 = 0

  public var bytesReceived: UInt64 = 0

  ///jitter stats - incoming quality
  public var jitter: Double = 0

  public var jitterBufferDelay: Double = 0

  public var jitterBufferEmittedCount: UInt64 = 0

  public var jitterBufferMinimumDelay: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_AudioStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tracks quality of incoming audio
  public var insertedSamplesForDeceleration: UInt64 = 0

  public var removedSamplesForAcceleration: UInt64 = 0

  public var packetsDiscarded: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_VideoStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tracks performance of incoming video
  public var framesReceived: UInt64 = 0

  public var framesDropped: UInt64 = 0

  /// these track performance of our outgoing video
  public var qualityLimitationDurationBandwidth: Double = 0

  public var qualityLimitationDurationCpu: Double = 0

  public var qualityLimitationDurationNone: Double = 0

  public var qualityLimitationDurationOther: Double = 0

  /// tracks compression in incoming video
  public var averageQp: Double = 0

  /// tracks how long in total encoding video took
  public var totalProcessingDelay: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_CandidatePairStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var local: Server_CandidatePairStats.CandidateType = .prflx

  public var localIp: String = String()

  public var remote: Server_CandidatePairStats.CandidateType = .prflx

  public var remoteIp: String = String()

  public var packetsSent: UInt64 = 0

  public var packetsReceived: UInt64 = 0

  public var bytesSent: UInt64 = 0

  public var bytesReceived: UInt64 = 0

  public var averageRoundTripTime: Double = 0

  public var currentRoundTripTime: Double = 0

  public var availableOutgoingBitrate: Double = 0

  public var availableIncomingBitrate: Double = 0

  public var state: Server_CandidatePairStats.CandidatePairState = .frozen

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CandidateType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case prflx // = 0
    case srflx // = 1
    case relay // = 2
    case host // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .prflx
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .prflx
      case 1: self = .srflx
      case 2: self = .relay
      case 3: self = .host
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .prflx: return 0
      case .srflx: return 1
      case .relay: return 2
      case .host: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum CandidatePairState: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case frozen // = 0
    case waiting // = 1
    case inProgress // = 2
    case failed // = 3
    case succeeded // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .frozen
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .frozen
      case 1: self = .waiting
      case 2: self = .inProgress
      case 3: self = .failed
      case 4: self = .succeeded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .frozen: return 0
      case .waiting: return 1
      case .inProgress: return 2
      case .failed: return 3
      case .succeeded: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_CandidatePairStats.CandidateType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_CandidatePairStats.CandidateType] = [
    .prflx,
    .srflx,
    .relay,
    .host,
  ]
}

extension Server_CandidatePairStats.CandidatePairState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_CandidatePairStats.CandidatePairState] = [
    .frozen,
    .waiting,
    .inProgress,
    .failed,
    .succeeded,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FabAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_FabAction.FabActionType = .unknownType

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FabActionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case gallery // = 1
    case audio // = 2
    case text // = 3
    case camera // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .gallery
      case 2: self = .audio
      case 3: self = .text
      case 4: self = .camera
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .gallery: return 1
      case .audio: return 2
      case .text: return 3
      case .camera: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FabAction.FabActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FabAction.FabActionType] = [
    .unknownType,
    .gallery,
    .audio,
    .text,
    .camera,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Server_Platform: @unchecked Sendable {}
extension Server_EventData: @unchecked Sendable {}
extension Server_EventData.OneOf_Edata: @unchecked Sendable {}
extension Server_MediaObjectDownload: @unchecked Sendable {}
extension Server_MediaObjectDownload.TypeEnum: @unchecked Sendable {}
extension Server_MediaObjectDownload.MediaType: @unchecked Sendable {}
extension Server_MediaObjectDownload.Cdn: @unchecked Sendable {}
extension Server_MediaObjectDownload.CdnCache: @unchecked Sendable {}
extension Server_MediaObjectDownload.Status: @unchecked Sendable {}
extension Server_MediaUpload: @unchecked Sendable {}
extension Server_MediaUpload.TypeEnum: @unchecked Sendable {}
extension Server_MediaUpload.Status: @unchecked Sendable {}
extension Server_MediaDownload: @unchecked Sendable {}
extension Server_MediaDownload.TypeEnum: @unchecked Sendable {}
extension Server_MediaDownload.Status: @unchecked Sendable {}
extension Server_MediaComposeLoad: @unchecked Sendable {}
extension Server_PushReceived: @unchecked Sendable {}
extension Server_DecryptionReport: @unchecked Sendable {}
extension Server_DecryptionReport.Status: @unchecked Sendable {}
extension Server_DecryptionReport.ContentType: @unchecked Sendable {}
extension Server_GroupDecryptionReport: @unchecked Sendable {}
extension Server_GroupDecryptionReport.Status: @unchecked Sendable {}
extension Server_GroupDecryptionReport.ItemType: @unchecked Sendable {}
extension Server_GroupDecryptionReport.Schedule: @unchecked Sendable {}
extension Server_HomeDecryptionReport: @unchecked Sendable {}
extension Server_HomeDecryptionReport.Status: @unchecked Sendable {}
extension Server_HomeDecryptionReport.AudienceType: @unchecked Sendable {}
extension Server_HomeDecryptionReport.ItemType: @unchecked Sendable {}
extension Server_HomeDecryptionReport.Schedule: @unchecked Sendable {}
extension Server_GroupHistoryReport: @unchecked Sendable {}
extension Server_GroupHistoryReport.Schedule: @unchecked Sendable {}
extension Server_Permissions: @unchecked Sendable {}
extension Server_Permissions.TypeEnum: @unchecked Sendable {}
extension Server_Permissions.Status: @unchecked Sendable {}
extension Server_Call: @unchecked Sendable {}
extension Server_Call.CallType: @unchecked Sendable {}
extension Server_Call.CallDirection: @unchecked Sendable {}
extension Server_Call.NetworkType: @unchecked Sendable {}
extension Server_WebrtcSummary: @unchecked Sendable {}
extension Server_StreamStats: @unchecked Sendable {}
extension Server_AudioStats: @unchecked Sendable {}
extension Server_VideoStats: @unchecked Sendable {}
extension Server_CandidatePairStats: @unchecked Sendable {}
extension Server_CandidatePairStats.CandidateType: @unchecked Sendable {}
extension Server_CandidatePairStats.CandidatePairState: @unchecked Sendable {}
extension Server_FabAction: @unchecked Sendable {}
extension Server_FabAction.FabActionType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "IOS"),
    2: .same(proto: "ANDROID"),
  ]
}

extension Server_EventData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "platform"),
    3: .same(proto: "version"),
    4: .standard(proto: "timestamp_ms"),
    5: .same(proto: "cc"),
    10: .standard(proto: "media_upload"),
    11: .standard(proto: "media_download"),
    12: .standard(proto: "media_compose_load"),
    13: .standard(proto: "push_received"),
    14: .standard(proto: "decryption_report"),
    15: .same(proto: "permissions"),
    16: .standard(proto: "media_object_download"),
    17: .standard(proto: "group_decryption_report"),
    18: .same(proto: "call"),
    19: .standard(proto: "fab_action"),
    20: .standard(proto: "group_history_report"),
    21: .standard(proto: "home_decryption_report"),
  ]

  fileprivate class _StorageClass {
    var _uid: UInt64 = 0
    var _platform: Server_Platform = .unknown
    var _version: String = String()
    var _timestampMs: UInt64 = 0
    var _cc: String = String()
    var _edata: Server_EventData.OneOf_Edata?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uid = source._uid
      _platform = source._platform
      _version = source._version
      _timestampMs = source._timestampMs
      _cc = source._cc
      _edata = source._edata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._uid) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._platform) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestampMs) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._cc) }()
        case 10: try {
          var v: Server_MediaUpload?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaUpload(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaUpload(v)
          }
        }()
        case 11: try {
          var v: Server_MediaDownload?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaDownload(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaDownload(v)
          }
        }()
        case 12: try {
          var v: Server_MediaComposeLoad?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaComposeLoad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaComposeLoad(v)
          }
        }()
        case 13: try {
          var v: Server_PushReceived?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .pushReceived(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .pushReceived(v)
          }
        }()
        case 14: try {
          var v: Server_DecryptionReport?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .decryptionReport(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .decryptionReport(v)
          }
        }()
        case 15: try {
          var v: Server_Permissions?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .permissions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .permissions(v)
          }
        }()
        case 16: try {
          var v: Server_MediaObjectDownload?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaObjectDownload(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaObjectDownload(v)
          }
        }()
        case 17: try {
          var v: Server_GroupDecryptionReport?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .groupDecryptionReport(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .groupDecryptionReport(v)
          }
        }()
        case 18: try {
          var v: Server_Call?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .call(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .call(v)
          }
        }()
        case 19: try {
          var v: Server_FabAction?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .fabAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .fabAction(v)
          }
        }()
        case 20: try {
          var v: Server_GroupHistoryReport?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .groupHistoryReport(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .groupHistoryReport(v)
          }
        }()
        case 21: try {
          var v: Server_HomeDecryptionReport?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .homeDecryptionReport(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .homeDecryptionReport(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._uid != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._uid, fieldNumber: 1)
      }
      if _storage._platform != .unknown {
        try visitor.visitSingularEnumField(value: _storage._platform, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      if _storage._timestampMs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestampMs, fieldNumber: 4)
      }
      if !_storage._cc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cc, fieldNumber: 5)
      }
      switch _storage._edata {
      case .mediaUpload?: try {
        guard case .mediaUpload(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .mediaDownload?: try {
        guard case .mediaDownload(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .mediaComposeLoad?: try {
        guard case .mediaComposeLoad(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .pushReceived?: try {
        guard case .pushReceived(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .decryptionReport?: try {
        guard case .decryptionReport(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .permissions?: try {
        guard case .permissions(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .mediaObjectDownload?: try {
        guard case .mediaObjectDownload(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .groupDecryptionReport?: try {
        guard case .groupDecryptionReport(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .call?: try {
        guard case .call(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .fabAction?: try {
        guard case .fabAction(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .groupHistoryReport?: try {
        guard case .groupHistoryReport(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .homeDecryptionReport?: try {
        guard case .homeDecryptionReport(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EventData, rhs: Server_EventData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._timestampMs != rhs_storage._timestampMs {return false}
        if _storage._cc != rhs_storage._cc {return false}
        if _storage._edata != rhs_storage._edata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaObjectDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaObjectDownload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "index"),
    3: .same(proto: "type"),
    4: .standard(proto: "media_type"),
    5: .standard(proto: "duration_ms"),
    6: .same(proto: "size"),
    7: .standard(proto: "progress_bytes"),
    8: .same(proto: "cdn"),
    9: .standard(proto: "cdn_pop"),
    10: .standard(proto: "cdn_id"),
    11: .standard(proto: "cdn_cache"),
    12: .same(proto: "status"),
    13: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.mediaType) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.durationMs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.progressBytes) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.cdn) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.cdnPop) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.cdnID) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.cdnCache) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 2)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.mediaType != .photo {
      try visitor.visitSingularEnumField(value: self.mediaType, fieldNumber: 4)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.durationMs, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 6)
    }
    if self.progressBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.progressBytes, fieldNumber: 7)
    }
    if self.cdn != .unknownCdn {
      try visitor.visitSingularEnumField(value: self.cdn, fieldNumber: 8)
    }
    if !self.cdnPop.isEmpty {
      try visitor.visitSingularStringField(value: self.cdnPop, fieldNumber: 9)
    }
    if !self.cdnID.isEmpty {
      try visitor.visitSingularStringField(value: self.cdnID, fieldNumber: 10)
    }
    if self.cdnCache != .unknownCache {
      try visitor.visitSingularEnumField(value: self.cdnCache, fieldNumber: 11)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 12)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.retryCount, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaObjectDownload, rhs: Server_MediaObjectDownload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.index != rhs.index {return false}
    if lhs.type != rhs.type {return false}
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.size != rhs.size {return false}
    if lhs.progressBytes != rhs.progressBytes {return false}
    if lhs.cdn != rhs.cdn {return false}
    if lhs.cdnPop != rhs.cdnPop {return false}
    if lhs.cdnID != rhs.cdnID {return false}
    if lhs.cdnCache != rhs.cdnCache {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaObjectDownload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaObjectDownload.MediaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHOTO"),
    1: .same(proto: "VIDEO"),
    2: .same(proto: "AUDIO"),
  ]
}

extension Server_MediaObjectDownload.Cdn: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CDN"),
    1: .same(proto: "CLOUDFRONT"),
  ]
}

extension Server_MediaObjectDownload.CdnCache: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CACHE"),
    1: .same(proto: "HIT"),
    2: .same(proto: "MISS"),
    3: .same(proto: "REFRESH_HIT"),
    4: .same(proto: "REFRESH_MISS"),
  ]
}

extension Server_MediaObjectDownload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaUpload, rhs: Server_MediaUpload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUpload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaUpload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaDownload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaDownload, rhs: Server_MediaDownload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaDownload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaDownload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaComposeLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaComposeLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_ms"),
    2: .standard(proto: "num_photos"),
    3: .standard(proto: "num_videos"),
    4: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 1)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 2)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 3)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaComposeLoad, rhs: Server_MediaComposeLoad) -> Bool {
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushReceived"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "client_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.clientTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.clientTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushReceived, rhs: Server_PushReceived) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.clientTimestamp != rhs.clientTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DecryptionReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptionReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "msg_id"),
    4: .standard(proto: "original_version"),
    5: .standard(proto: "sender_platform"),
    6: .standard(proto: "sender_version"),
    7: .standard(proto: "rerequest_count"),
    8: .standard(proto: "time_taken_s"),
    9: .standard(proto: "is_silent"),
    10: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.originalVersion) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.senderPlatform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.senderVersion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.rerequestCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.timeTakenS) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isSilent) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 3)
    }
    if !self.originalVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.originalVersion, fieldNumber: 4)
    }
    if self.senderPlatform != .unknown {
      try visitor.visitSingularEnumField(value: self.senderPlatform, fieldNumber: 5)
    }
    if !self.senderVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderVersion, fieldNumber: 6)
    }
    if self.rerequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rerequestCount, fieldNumber: 7)
    }
    if self.timeTakenS != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTakenS, fieldNumber: 8)
    }
    if self.isSilent != false {
      try visitor.visitSingularBoolField(value: self.isSilent, fieldNumber: 9)
    }
    if self.contentType != .chat {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DecryptionReport, rhs: Server_DecryptionReport) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.originalVersion != rhs.originalVersion {return false}
    if lhs.senderPlatform != rhs.senderPlatform {return false}
    if lhs.senderVersion != rhs.senderVersion {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs.timeTakenS != rhs.timeTakenS {return false}
    if lhs.isSilent != rhs.isSilent {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DecryptionReport.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_DecryptionReport.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "GROUP_HISTORY"),
  ]
}

extension Server_GroupDecryptionReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupDecryptionReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "content_id"),
    4: .same(proto: "gid"),
    5: .standard(proto: "item_type"),
    6: .standard(proto: "original_version"),
    7: .standard(proto: "rerequest_count"),
    8: .standard(proto: "time_taken_s"),
    9: .standard(proto: "sender_platform"),
    10: .standard(proto: "sender_version"),
    11: .same(proto: "schedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.originalVersion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.rerequestCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.timeTakenS) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.senderPlatform) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.senderVersion) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.schedule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknownStatus {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 3)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 4)
    }
    if self.itemType != .unknownType {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 5)
    }
    if !self.originalVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.originalVersion, fieldNumber: 6)
    }
    if self.rerequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rerequestCount, fieldNumber: 7)
    }
    if self.timeTakenS != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTakenS, fieldNumber: 8)
    }
    if self.senderPlatform != .unknown {
      try visitor.visitSingularEnumField(value: self.senderPlatform, fieldNumber: 9)
    }
    if !self.senderVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderVersion, fieldNumber: 10)
    }
    if self.schedule != .daily {
      try visitor.visitSingularEnumField(value: self.schedule, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupDecryptionReport, rhs: Server_GroupDecryptionReport) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.itemType != rhs.itemType {return false}
    if lhs.originalVersion != rhs.originalVersion {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs.timeTakenS != rhs.timeTakenS {return false}
    if lhs.senderPlatform != rhs.senderPlatform {return false}
    if lhs.senderVersion != rhs.senderVersion {return false}
    if lhs.schedule != rhs.schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupDecryptionReport.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATUS"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_GroupDecryptionReport.ItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "POST"),
    2: .same(proto: "COMMENT"),
    3: .same(proto: "HISTORY_RESEND"),
  ]
}

extension Server_GroupDecryptionReport.Schedule: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAILY"),
    1: .same(proto: "RESULT_BASED"),
  ]
}

extension Server_HomeDecryptionReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HomeDecryptionReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "content_id"),
    4: .standard(proto: "audience_type"),
    5: .standard(proto: "item_type"),
    6: .standard(proto: "original_version"),
    7: .standard(proto: "rerequest_count"),
    8: .standard(proto: "time_taken_s"),
    9: .standard(proto: "sender_platform"),
    10: .standard(proto: "sender_version"),
    11: .same(proto: "schedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.audienceType) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.originalVersion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.rerequestCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.timeTakenS) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.senderPlatform) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.senderVersion) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.schedule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknownStatus {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 3)
    }
    if self.audienceType != .unknownAudienceType {
      try visitor.visitSingularEnumField(value: self.audienceType, fieldNumber: 4)
    }
    if self.itemType != .unknownType {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 5)
    }
    if !self.originalVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.originalVersion, fieldNumber: 6)
    }
    if self.rerequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rerequestCount, fieldNumber: 7)
    }
    if self.timeTakenS != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTakenS, fieldNumber: 8)
    }
    if self.senderPlatform != .unknown {
      try visitor.visitSingularEnumField(value: self.senderPlatform, fieldNumber: 9)
    }
    if !self.senderVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderVersion, fieldNumber: 10)
    }
    if self.schedule != .daily {
      try visitor.visitSingularEnumField(value: self.schedule, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HomeDecryptionReport, rhs: Server_HomeDecryptionReport) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.audienceType != rhs.audienceType {return false}
    if lhs.itemType != rhs.itemType {return false}
    if lhs.originalVersion != rhs.originalVersion {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs.timeTakenS != rhs.timeTakenS {return false}
    if lhs.senderPlatform != rhs.senderPlatform {return false}
    if lhs.senderVersion != rhs.senderVersion {return false}
    if lhs.schedule != rhs.schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HomeDecryptionReport.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATUS"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_HomeDecryptionReport.AudienceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_AUDIENCE_TYPE"),
    1: .same(proto: "ALL"),
    2: .same(proto: "ONLY"),
  ]
}

extension Server_HomeDecryptionReport.ItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "POST"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_HomeDecryptionReport.Schedule: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAILY"),
    1: .same(proto: "RESULT_BASED"),
  ]
}

extension Server_GroupHistoryReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupHistoryReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .standard(proto: "num_expected"),
    3: .standard(proto: "num_decrypted"),
    4: .standard(proto: "original_version"),
    5: .standard(proto: "rerequest_count"),
    6: .standard(proto: "time_taken_s"),
    7: .same(proto: "schedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numExpected) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numDecrypted) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.originalVersion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.rerequestCount) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.timeTakenS) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.schedule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if self.numExpected != 0 {
      try visitor.visitSingularUInt32Field(value: self.numExpected, fieldNumber: 2)
    }
    if self.numDecrypted != 0 {
      try visitor.visitSingularUInt32Field(value: self.numDecrypted, fieldNumber: 3)
    }
    if !self.originalVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.originalVersion, fieldNumber: 4)
    }
    if self.rerequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rerequestCount, fieldNumber: 5)
    }
    if self.timeTakenS != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTakenS, fieldNumber: 6)
    }
    if self.schedule != .daily {
      try visitor.visitSingularEnumField(value: self.schedule, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupHistoryReport, rhs: Server_GroupHistoryReport) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.numExpected != rhs.numExpected {return false}
    if lhs.numDecrypted != rhs.numDecrypted {return false}
    if lhs.originalVersion != rhs.originalVersion {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs.timeTakenS != rhs.timeTakenS {return false}
    if lhs.schedule != rhs.schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupHistoryReport.Schedule: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAILY"),
    1: .same(proto: "RESULT_BASED"),
  ]
}

extension Server_Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .contacts {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.status != .allowed {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Permissions, rhs: Server_Permissions) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Permissions.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTACTS"),
    1: .same(proto: "NOTIFICATIONS"),
  ]
}

extension Server_Permissions.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOWED"),
    1: .same(proto: "DENIED"),
  ]
}

extension Server_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Call"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "peer_uid"),
    3: .same(proto: "type"),
    4: .same(proto: "direction"),
    5: .same(proto: "answered"),
    6: .same(proto: "connected"),
    7: .standard(proto: "duration_ms"),
    9: .standard(proto: "end_call_reason"),
    10: .standard(proto: "local_end_call"),
    11: .standard(proto: "network_type"),
    12: .standard(proto: "is_krisp_active"),
    13: .standard(proto: "ice_time_taken_ms"),
    20: .standard(proto: "webrtc_stats"),
    21: .standard(proto: "webrtc_summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.peerUid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.answered) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.durationMs) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.endCallReason) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.localEndCall) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.networkType) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.isKrispActive) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.iceTimeTakenMs) }()
      case 20: try { try decoder.decodeSingularStringField(value: &self.webrtcStats) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._webrtcSummary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.peerUid != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerUid, fieldNumber: 2)
    }
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.direction != .unknownDirection {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 4)
    }
    if self.answered != false {
      try visitor.visitSingularBoolField(value: self.answered, fieldNumber: 5)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 6)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.durationMs, fieldNumber: 7)
    }
    if !self.endCallReason.isEmpty {
      try visitor.visitSingularStringField(value: self.endCallReason, fieldNumber: 9)
    }
    if self.localEndCall != false {
      try visitor.visitSingularBoolField(value: self.localEndCall, fieldNumber: 10)
    }
    if self.networkType != .unknownNetwork {
      try visitor.visitSingularEnumField(value: self.networkType, fieldNumber: 11)
    }
    if self.isKrispActive != false {
      try visitor.visitSingularBoolField(value: self.isKrispActive, fieldNumber: 12)
    }
    if self.iceTimeTakenMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.iceTimeTakenMs, fieldNumber: 13)
    }
    if !self.webrtcStats.isEmpty {
      try visitor.visitSingularStringField(value: self.webrtcStats, fieldNumber: 20)
    }
    try { if let v = self._webrtcSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Call, rhs: Server_Call) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.peerUid != rhs.peerUid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.answered != rhs.answered {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.endCallReason != rhs.endCallReason {return false}
    if lhs.localEndCall != rhs.localEndCall {return false}
    if lhs.networkType != rhs.networkType {return false}
    if lhs.isKrispActive != rhs.isKrispActive {return false}
    if lhs.iceTimeTakenMs != rhs.iceTimeTakenMs {return false}
    if lhs.webrtcStats != rhs.webrtcStats {return false}
    if lhs._webrtcSummary != rhs._webrtcSummary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Call.CallType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO"),
    2: .same(proto: "VIDEO"),
  ]
}

extension Server_Call.CallDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DIRECTION"),
    1: .same(proto: "OUTGOING"),
    2: .same(proto: "INCOMING"),
  ]
}

extension Server_Call.NetworkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_NETWORK"),
    1: .same(proto: "WIFI"),
    2: .same(proto: "CELLULAR"),
  ]
}

extension Server_WebrtcSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebrtcSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_stream"),
    2: .standard(proto: "video_stream"),
    3: .same(proto: "audio"),
    4: .same(proto: "video"),
    5: .same(proto: "candidatePairs"),
  ]

  fileprivate class _StorageClass {
    var _audioStream: Server_StreamStats? = nil
    var _videoStream: Server_StreamStats? = nil
    var _audio: Server_AudioStats? = nil
    var _video: Server_VideoStats? = nil
    var _candidatePairs: [Server_CandidatePairStats] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _audioStream = source._audioStream
      _videoStream = source._videoStream
      _audio = source._audio
      _video = source._video
      _candidatePairs = source._candidatePairs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._audioStream) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._videoStream) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._video) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._candidatePairs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._audioStream {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._videoStream {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._video {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._candidatePairs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._candidatePairs, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WebrtcSummary, rhs: Server_WebrtcSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._audioStream != rhs_storage._audioStream {return false}
        if _storage._videoStream != rhs_storage._videoStream {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._video != rhs_storage._video {return false}
        if _storage._candidatePairs != rhs_storage._candidatePairs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StreamStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packetsSent"),
    2: .same(proto: "packetsLost"),
    3: .same(proto: "packetsReceived"),
    4: .same(proto: "bytesReceived"),
    5: .same(proto: "jitter"),
    6: .same(proto: "jitterBufferDelay"),
    7: .same(proto: "jitterBufferEmittedCount"),
    8: .same(proto: "jitterBufferMinimumDelay"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.packetsSent) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.packetsLost) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.packetsReceived) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.bytesReceived) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.jitter) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.jitterBufferDelay) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.jitterBufferEmittedCount) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.jitterBufferMinimumDelay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetsSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsSent, fieldNumber: 1)
    }
    if self.packetsLost != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsLost, fieldNumber: 2)
    }
    if self.packetsReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsReceived, fieldNumber: 3)
    }
    if self.bytesReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesReceived, fieldNumber: 4)
    }
    if self.jitter != 0 {
      try visitor.visitSingularDoubleField(value: self.jitter, fieldNumber: 5)
    }
    if self.jitterBufferDelay != 0 {
      try visitor.visitSingularDoubleField(value: self.jitterBufferDelay, fieldNumber: 6)
    }
    if self.jitterBufferEmittedCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.jitterBufferEmittedCount, fieldNumber: 7)
    }
    if self.jitterBufferMinimumDelay != 0 {
      try visitor.visitSingularDoubleField(value: self.jitterBufferMinimumDelay, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_StreamStats, rhs: Server_StreamStats) -> Bool {
    if lhs.packetsSent != rhs.packetsSent {return false}
    if lhs.packetsLost != rhs.packetsLost {return false}
    if lhs.packetsReceived != rhs.packetsReceived {return false}
    if lhs.bytesReceived != rhs.bytesReceived {return false}
    if lhs.jitter != rhs.jitter {return false}
    if lhs.jitterBufferDelay != rhs.jitterBufferDelay {return false}
    if lhs.jitterBufferEmittedCount != rhs.jitterBufferEmittedCount {return false}
    if lhs.jitterBufferMinimumDelay != rhs.jitterBufferMinimumDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AudioStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insertedSamplesForDeceleration"),
    2: .same(proto: "removedSamplesForAcceleration"),
    3: .same(proto: "packetsDiscarded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.insertedSamplesForDeceleration) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.removedSamplesForAcceleration) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.packetsDiscarded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.insertedSamplesForDeceleration != 0 {
      try visitor.visitSingularUInt64Field(value: self.insertedSamplesForDeceleration, fieldNumber: 1)
    }
    if self.removedSamplesForAcceleration != 0 {
      try visitor.visitSingularUInt64Field(value: self.removedSamplesForAcceleration, fieldNumber: 2)
    }
    if self.packetsDiscarded != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsDiscarded, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AudioStats, rhs: Server_AudioStats) -> Bool {
    if lhs.insertedSamplesForDeceleration != rhs.insertedSamplesForDeceleration {return false}
    if lhs.removedSamplesForAcceleration != rhs.removedSamplesForAcceleration {return false}
    if lhs.packetsDiscarded != rhs.packetsDiscarded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_VideoStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "framesReceived"),
    2: .same(proto: "framesDropped"),
    3: .standard(proto: "qualityLimitationDuration_bandwidth"),
    4: .standard(proto: "qualityLimitationDuration_cpu"),
    5: .standard(proto: "qualityLimitationDuration_none"),
    6: .standard(proto: "qualityLimitationDuration_other"),
    7: .same(proto: "averageQp"),
    8: .same(proto: "totalProcessingDelay"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.framesReceived) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.framesDropped) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.qualityLimitationDurationBandwidth) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.qualityLimitationDurationCpu) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.qualityLimitationDurationNone) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.qualityLimitationDurationOther) }()
      case 7: try { try decoder.decodeSingularDoubleField(value: &self.averageQp) }()
      case 8: try { try decoder.decodeSingularDoubleField(value: &self.totalProcessingDelay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.framesReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.framesReceived, fieldNumber: 1)
    }
    if self.framesDropped != 0 {
      try visitor.visitSingularUInt64Field(value: self.framesDropped, fieldNumber: 2)
    }
    if self.qualityLimitationDurationBandwidth != 0 {
      try visitor.visitSingularDoubleField(value: self.qualityLimitationDurationBandwidth, fieldNumber: 3)
    }
    if self.qualityLimitationDurationCpu != 0 {
      try visitor.visitSingularDoubleField(value: self.qualityLimitationDurationCpu, fieldNumber: 4)
    }
    if self.qualityLimitationDurationNone != 0 {
      try visitor.visitSingularDoubleField(value: self.qualityLimitationDurationNone, fieldNumber: 5)
    }
    if self.qualityLimitationDurationOther != 0 {
      try visitor.visitSingularDoubleField(value: self.qualityLimitationDurationOther, fieldNumber: 6)
    }
    if self.averageQp != 0 {
      try visitor.visitSingularDoubleField(value: self.averageQp, fieldNumber: 7)
    }
    if self.totalProcessingDelay != 0 {
      try visitor.visitSingularDoubleField(value: self.totalProcessingDelay, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_VideoStats, rhs: Server_VideoStats) -> Bool {
    if lhs.framesReceived != rhs.framesReceived {return false}
    if lhs.framesDropped != rhs.framesDropped {return false}
    if lhs.qualityLimitationDurationBandwidth != rhs.qualityLimitationDurationBandwidth {return false}
    if lhs.qualityLimitationDurationCpu != rhs.qualityLimitationDurationCpu {return false}
    if lhs.qualityLimitationDurationNone != rhs.qualityLimitationDurationNone {return false}
    if lhs.qualityLimitationDurationOther != rhs.qualityLimitationDurationOther {return false}
    if lhs.averageQp != rhs.averageQp {return false}
    if lhs.totalProcessingDelay != rhs.totalProcessingDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CandidatePairStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidatePairStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "localIP"),
    3: .same(proto: "remote"),
    4: .same(proto: "remoteIP"),
    5: .same(proto: "packetsSent"),
    6: .same(proto: "packetsReceived"),
    7: .same(proto: "bytesSent"),
    8: .same(proto: "bytesReceived"),
    9: .same(proto: "averageRoundTripTime"),
    10: .same(proto: "currentRoundTripTime"),
    11: .same(proto: "availableOutgoingBitrate"),
    12: .same(proto: "availableIncomingBitrate"),
    13: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.local) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.localIp) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.remote) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.remoteIp) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.packetsSent) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.packetsReceived) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.bytesSent) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.bytesReceived) }()
      case 9: try { try decoder.decodeSingularDoubleField(value: &self.averageRoundTripTime) }()
      case 10: try { try decoder.decodeSingularDoubleField(value: &self.currentRoundTripTime) }()
      case 11: try { try decoder.decodeSingularDoubleField(value: &self.availableOutgoingBitrate) }()
      case 12: try { try decoder.decodeSingularDoubleField(value: &self.availableIncomingBitrate) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.local != .prflx {
      try visitor.visitSingularEnumField(value: self.local, fieldNumber: 1)
    }
    if !self.localIp.isEmpty {
      try visitor.visitSingularStringField(value: self.localIp, fieldNumber: 2)
    }
    if self.remote != .prflx {
      try visitor.visitSingularEnumField(value: self.remote, fieldNumber: 3)
    }
    if !self.remoteIp.isEmpty {
      try visitor.visitSingularStringField(value: self.remoteIp, fieldNumber: 4)
    }
    if self.packetsSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsSent, fieldNumber: 5)
    }
    if self.packetsReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.packetsReceived, fieldNumber: 6)
    }
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 7)
    }
    if self.bytesReceived != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesReceived, fieldNumber: 8)
    }
    if self.averageRoundTripTime != 0 {
      try visitor.visitSingularDoubleField(value: self.averageRoundTripTime, fieldNumber: 9)
    }
    if self.currentRoundTripTime != 0 {
      try visitor.visitSingularDoubleField(value: self.currentRoundTripTime, fieldNumber: 10)
    }
    if self.availableOutgoingBitrate != 0 {
      try visitor.visitSingularDoubleField(value: self.availableOutgoingBitrate, fieldNumber: 11)
    }
    if self.availableIncomingBitrate != 0 {
      try visitor.visitSingularDoubleField(value: self.availableIncomingBitrate, fieldNumber: 12)
    }
    if self.state != .frozen {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CandidatePairStats, rhs: Server_CandidatePairStats) -> Bool {
    if lhs.local != rhs.local {return false}
    if lhs.localIp != rhs.localIp {return false}
    if lhs.remote != rhs.remote {return false}
    if lhs.remoteIp != rhs.remoteIp {return false}
    if lhs.packetsSent != rhs.packetsSent {return false}
    if lhs.packetsReceived != rhs.packetsReceived {return false}
    if lhs.bytesSent != rhs.bytesSent {return false}
    if lhs.bytesReceived != rhs.bytesReceived {return false}
    if lhs.averageRoundTripTime != rhs.averageRoundTripTime {return false}
    if lhs.currentRoundTripTime != rhs.currentRoundTripTime {return false}
    if lhs.availableOutgoingBitrate != rhs.availableOutgoingBitrate {return false}
    if lhs.availableIncomingBitrate != rhs.availableIncomingBitrate {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CandidatePairStats.CandidateType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRFLX"),
    1: .same(proto: "SRFLX"),
    2: .same(proto: "RELAY"),
    3: .same(proto: "HOST"),
  ]
}

extension Server_CandidatePairStats.CandidatePairState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FROZEN"),
    1: .same(proto: "WAITING"),
    2: .same(proto: "IN_PROGRESS"),
    3: .same(proto: "FAILED"),
    4: .same(proto: "SUCCEEDED"),
  ]
}

extension Server_FabAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FabAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FabAction, rhs: Server_FabAction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FabAction.FabActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "GALLERY"),
    2: .same(proto: "AUDIO"),
    3: .same(proto: "TEXT"),
    4: .same(proto: "CAMERA"),
  ]
}
