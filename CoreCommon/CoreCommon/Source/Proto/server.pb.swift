// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Calls
public enum Server_CallType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownType // = 0
  case audio // = 1
  case video // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownType
    case 1: self = .audio
    case 2: self = .video
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownType: return 0
    case .audio: return 1
    case .video: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_CallType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_CallType] = [
    .unknownType,
    .audio,
    .video,
  ]
}

#endif  // swift(>=4.2)

public struct Server_UploadAvatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// scaled-down binary jpeg data.
  public var data: Data = Data()

  /// full binary jpeg data.
  public var fullData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Avatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Avatars {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var avatars: [Server_Avatar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UploadGroupAvatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  /// scaled-down binary jpeg data.
  public var data: Data = Data()

  /// full binary jpeg data.
  public var fullData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_CertMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var serverKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ClientMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Server_ClientMode.Mode = .active

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Mode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case active // = 0
    case passive // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .active
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .active
      case 1: self = .passive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .active: return 0
      case .passive: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ClientMode.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientMode.Mode] = [
    .active,
    .passive,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ClientVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var expiresInSeconds: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Brand + ":" + Model Ex: "Iphone:12 Pro" / "OnePlus:KB2005".
  public var device: String = String()

  /// "14.8" for iOS / "29" for API level in Android.
  public var osVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ClientLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var counts: [Server_Count] = []

  public var events: [Server_EventData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Count {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var namespace: String = String()

  public var metric: String = String()

  public var count: Int64 = 0

  public var dims: [Server_Dim] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Dim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_Contact.Action = .add

  public var raw: String = String()

  public var normalized: String = String()

  public var uid: Int64 = 0

  public var avatarID: String = String()

  public var name: String = String()

  public var numPotentialFriends: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Contact.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Contact.Action] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ContactList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ContactList.TypeEnum = .full

  public var syncID: String = String()

  public var batchIndex: Int32 = 0

  public var isLast: Bool = false

  public var contacts: [Server_Contact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case full // = 0
    case delta // = 1
    case normal // = 2
    case friendNotice // = 3
    case inviterNotice // = 4
    case deleteNotice // = 5
    case contactNotice // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .full
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .full
      case 1: self = .delta
      case 2: self = .normal
      case 3: self = .friendNotice
      case 4: self = .inviterNotice
      case 5: self = .deleteNotice
      case 6: self = .contactNotice
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .full: return 0
      case .delta: return 1
      case .normal: return 2
      case .friendNotice: return 3
      case .inviterNotice: return 4
      case .deleteNotice: return 5
      case .contactNotice: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ContactList.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ContactList.TypeEnum] = [
    .full,
    .delta,
    .normal,
    .friendNotice,
    .inviterNotice,
    .deleteNotice,
    .contactNotice,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ContactHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ContactSyncError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var retryAfterSecs: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MediaCounters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numImages: Int32 = 0

  public var numVideos: Int32 = 0

  public var numAudio: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Audience {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_Audience.TypeEnum = .all

  public var uids: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case except // = 1
    case only // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .except
      case 2: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .except: return 1
      case .only: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Audience.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Audience.TypeEnum] = [
    .all,
    .except,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Post {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var publisherUid: Int64 = 0

  public var payload: Data = Data()

  public var audience: Server_Audience {
    get {return _audience ?? Server_Audience()}
    set {_audience = newValue}
  }
  /// Returns true if `audience` has been explicitly set.
  public var hasAudience: Bool {return self._audience != nil}
  /// Clears the value of `audience`. Subsequent reads from it will return its default value.
  public mutating func clearAudience() {self._audience = nil}

  public var timestamp: Int64 = 0

  public var publisherName: String = String()

  /// Serialized EncryptedPayload (from client.proto).
  public var encPayload: Data = Data()

  public var mediaCounters: Server_MediaCounters {
    get {return _mediaCounters ?? Server_MediaCounters()}
    set {_mediaCounters = newValue}
  }
  /// Returns true if `mediaCounters` has been explicitly set.
  public var hasMediaCounters: Bool {return self._mediaCounters != nil}
  /// Clears the value of `mediaCounters`. Subsequent reads from it will return its default value.
  public mutating func clearMediaCounters() {self._mediaCounters = nil}

  public var tag: Server_Post.Tag = .empty

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Tag: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case empty // = 0
    case secretPost // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .empty
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .empty
      case 1: self = .secretPost
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .empty: return 0
      case .secretPost: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _audience: Server_Audience? = nil
  fileprivate var _mediaCounters: Server_MediaCounters? = nil
}

#if swift(>=4.2)

extension Server_Post.Tag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Post.Tag] = [
    .empty,
    .secretPost,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Comment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var postID: String = String()

  public var parentCommentID: String = String()

  public var publisherUid: Int64 = 0

  public var publisherName: String = String()

  public var payload: Data = Data()

  public var timestamp: Int64 = 0

  /// Serialized EncryptedPayload (from client.proto).
  public var encPayload: Data = Data()

  public var mediaCounters: Server_MediaCounters {
    get {return _mediaCounters ?? Server_MediaCounters()}
    set {_mediaCounters = newValue}
  }
  /// Returns true if `mediaCounters` has been explicitly set.
  public var hasMediaCounters: Bool {return self._mediaCounters != nil}
  /// Clears the value of `mediaCounters`. Subsequent reads from it will return its default value.
  public mutating func clearMediaCounters() {self._mediaCounters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mediaCounters: Server_MediaCounters? = nil
}

public struct Server_ShareStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var postIds: [String] = []

  public var result: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_FeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_FeedItem.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var item: OneOf_Item? {
    get {return _storage._item}
    set {_uniqueStorage()._item = newValue}
  }

  public var post: Server_Post {
    get {
      if case .post(let v)? = _storage._item {return v}
      return Server_Post()
    }
    set {_uniqueStorage()._item = .post(newValue)}
  }

  public var comment: Server_Comment {
    get {
      if case .comment(let v)? = _storage._item {return v}
      return Server_Comment()
    }
    set {_uniqueStorage()._item = .comment(newValue)}
  }

  public var shareStanzas: [Server_ShareStanza] {
    get {return _storage._shareStanzas}
    set {_uniqueStorage()._shareStanzas = newValue}
  }

  /// Sent by the publisher.
  public var senderStateBundles: [Server_SenderStateBundle] {
    get {return _storage._senderStateBundles}
    set {_uniqueStorage()._senderStateBundles = newValue}
  }

  /// Meant for the receiver, computed by the server using `sender_state_bundles`.
  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _storage._senderState ?? Server_SenderStateWithKeyInfo()}
    set {_uniqueStorage()._senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return _storage._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {_uniqueStorage()._senderState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Item: Equatable {
    case post(Server_Post)
    case comment(Server_Comment)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_FeedItem.OneOf_Item, rhs: Server_FeedItem.OneOf_Item) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.post, .post): return {
        guard case .post(let l) = lhs, case .post(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.comment, .comment): return {
        guard case .comment(let l) = lhs, case .comment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case publish // = 0
    case retract // = 1
    case share // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .publish
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .publish
      case 1: self = .retract
      case 2: self = .share
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .publish: return 0
      case .retract: return 1
      case .share: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_FeedItem.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FeedItem.Action] = [
    .publish,
    .retract,
    .share,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FeedItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var items: [Server_FeedItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_SenderStateWithKeyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int64 = 0

  public var encSenderState: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_SenderStateBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _senderState ?? Server_SenderStateWithKeyInfo()}
    set {_senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return self._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {self._senderState = nil}

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _senderState: Server_SenderStateWithKeyInfo? = nil
}

public struct Server_GroupFeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupFeedItem.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var gid: String {
    get {return _storage._gid}
    set {_uniqueStorage()._gid = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatarID: String {
    get {return _storage._avatarID}
    set {_uniqueStorage()._avatarID = newValue}
  }

  public var item: OneOf_Item? {
    get {return _storage._item}
    set {_uniqueStorage()._item = newValue}
  }

  public var post: Server_Post {
    get {
      if case .post(let v)? = _storage._item {return v}
      return Server_Post()
    }
    set {_uniqueStorage()._item = .post(newValue)}
  }

  public var comment: Server_Comment {
    get {
      if case .comment(let v)? = _storage._item {return v}
      return Server_Comment()
    }
    set {_uniqueStorage()._item = .comment(newValue)}
  }

  /// Sent by the publisher.
  public var senderStateBundles: [Server_SenderStateBundle] {
    get {return _storage._senderStateBundles}
    set {_uniqueStorage()._senderStateBundles = newValue}
  }

  /// Meant for the receiver, computed by the server using `sender_state_bundles`.
  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _storage._senderState ?? Server_SenderStateWithKeyInfo()}
    set {_uniqueStorage()._senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return _storage._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {_uniqueStorage()._senderState = nil}

  public var audienceHash: Data {
    get {return _storage._audienceHash}
    set {_uniqueStorage()._audienceHash = newValue}
  }

  public var isResentHistory: Bool {
    get {return _storage._isResentHistory}
    set {_uniqueStorage()._isResentHistory = newValue}
  }

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String {
    get {return _storage._senderLogInfo}
    set {_uniqueStorage()._senderLogInfo = newValue}
  }

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String {
    get {return _storage._senderClientVersion}
    set {_uniqueStorage()._senderClientVersion = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Item: Equatable {
    case post(Server_Post)
    case comment(Server_Comment)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_GroupFeedItem.OneOf_Item, rhs: Server_GroupFeedItem.OneOf_Item) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.post, .post): return {
        guard case .post(let l) = lhs, case .post(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.comment, .comment): return {
        guard case .comment(let l) = lhs, case .comment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case publish // = 0
    case retract // = 1
    case share // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .publish
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .publish
      case 1: self = .retract
      case 2: self = .share
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .publish: return 0
      case .retract: return 1
      case .share: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_GroupFeedItem.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupFeedItem.Action] = [
    .publish,
    .retract,
    .share,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupFeedItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var items: [Server_GroupFeedItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupFeedHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var id: String = String()

  public var payload: Data = Data()

  /// Serialized GroupFeedItems stanza and then encrypted using 1-1 channel.
  public var encPayload: Data = Data()

  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int32 = 0

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String = String()

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupMember.Action = .add

  public var uid: Int64 = 0

  public var type: Server_GroupMember.TypeEnum = .member

  public var name: String = String()

  public var avatarID: String = String()

  public var result: String = String()

  public var reason: String = String()

  /// Identity key to be returned on `GET_MEMBER_IDENTITY_KEYS` IQ.
  public var identityKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case remove // = 1
    case promote // = 2
    case demote // = 3
    case leave // = 4
    case join // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .remove
      case 2: self = .promote
      case 3: self = .demote
      case 4: self = .leave
      case 5: self = .join
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .remove: return 1
      case .promote: return 2
      case .demote: return 3
      case .leave: return 4
      case .join: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case member // = 0
    case admin // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .member
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .member
      case 1: self = .admin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .member: return 0
      case .admin: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupMember.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupMember.Action] = [
    .add,
    .remove,
    .promote,
    .demote,
    .leave,
    .join,
  ]
}

extension Server_GroupMember.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupMember.TypeEnum] = [
    .member,
    .admin,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupStanza.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var gid: String {
    get {return _storage._gid}
    set {_uniqueStorage()._gid = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatarID: String {
    get {return _storage._avatarID}
    set {_uniqueStorage()._avatarID = newValue}
  }

  public var senderUid: Int64 {
    get {return _storage._senderUid}
    set {_uniqueStorage()._senderUid = newValue}
  }

  public var senderName: String {
    get {return _storage._senderName}
    set {_uniqueStorage()._senderName = newValue}
  }

  public var members: [Server_GroupMember] {
    get {return _storage._members}
    set {_uniqueStorage()._members = newValue}
  }

  public var background: String {
    get {return _storage._background}
    set {_uniqueStorage()._background = newValue}
  }

  /// Audience hash to be returned on `GET_MEMBER_IDENTITY_KEYS` IQ.
  public var audienceHash: Data {
    get {return _storage._audienceHash}
    set {_uniqueStorage()._audienceHash = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// HistoryResend to be sent or received only on adding-members iq or share-history iq.
  public var historyResend: Server_HistoryResend {
    get {return _storage._historyResend ?? Server_HistoryResend()}
    set {_uniqueStorage()._historyResend = newValue}
  }
  /// Returns true if `historyResend` has been explicitly set.
  public var hasHistoryResend: Bool {return _storage._historyResend != nil}
  /// Clears the value of `historyResend`. Subsequent reads from it will return its default value.
  public mutating func clearHistoryResend() {_uniqueStorage()._historyResend = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case set // = 0
    case get // = 1
    case create // = 2
    case delete // = 3
    case leave // = 4
    case changeAvatar // = 5
    case changeName // = 6
    case modifyAdmins // = 7
    case modifyMembers // = 8
    case autoPromoteAdmins // = 9
    case setName // = 10
    case join // = 11
    case preview // = 12
    case setBackground // = 13
    case getMemberIdentityKeys // = 14
    case changeDescription // = 15
    case shareHistory // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .set
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .set
      case 1: self = .get
      case 2: self = .create
      case 3: self = .delete
      case 4: self = .leave
      case 5: self = .changeAvatar
      case 6: self = .changeName
      case 7: self = .modifyAdmins
      case 8: self = .modifyMembers
      case 9: self = .autoPromoteAdmins
      case 10: self = .setName
      case 11: self = .join
      case 12: self = .preview
      case 13: self = .setBackground
      case 14: self = .getMemberIdentityKeys
      case 15: self = .changeDescription
      case 16: self = .shareHistory
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .set: return 0
      case .get: return 1
      case .create: return 2
      case .delete: return 3
      case .leave: return 4
      case .changeAvatar: return 5
      case .changeName: return 6
      case .modifyAdmins: return 7
      case .modifyMembers: return 8
      case .autoPromoteAdmins: return 9
      case .setName: return 10
      case .join: return 11
      case .preview: return 12
      case .setBackground: return 13
      case .getMemberIdentityKeys: return 14
      case .changeDescription: return 15
      case .shareHistory: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_GroupStanza.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupStanza.Action] = [
    .set,
    .get,
    .create,
    .delete,
    .leave,
    .changeAvatar,
    .changeName,
    .modifyAdmins,
    .modifyMembers,
    .autoPromoteAdmins,
    .setName,
    .join,
    .preview,
    .setBackground,
    .getMemberIdentityKeys,
    .changeDescription,
    .shareHistory,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupChat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var senderUid: Int64 = 0

  public var senderName: String = String()

  public var timestamp: Int64 = 0

  public var payload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupsStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupsStanza.Action = .get

  public var groupStanzas: [Server_GroupStanza] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupsStanza.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupsStanza.Action] = [
    .get,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupInviteLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupInviteLink.Action = .unknown

  public var gid: String = String()

  public var link: String = String()

  public var result: String = String()

  public var reason: String = String()

  ///only present for action=JOIN
  public var group: Server_GroupStanza {
    get {return _group ?? Server_GroupStanza()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case get // = 1
    case reset // = 2
    case join // = 3
    case preview // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .get
      case 2: self = .reset
      case 3: self = .join
      case 4: self = .preview
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .get: return 1
      case .reset: return 2
      case .join: return 3
      case .preview: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _group: Server_GroupStanza? = nil
}

#if swift(>=4.2)

extension Server_GroupInviteLink.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupInviteLink.Action] = [
    .unknown,
    .get,
    .reset,
    .join,
    .preview,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var pwd: String = String()

  public var clientMode: Server_ClientMode {
    get {return _clientMode ?? Server_ClientMode()}
    set {_clientMode = newValue}
  }
  /// Returns true if `clientMode` has been explicitly set.
  public var hasClientMode: Bool {return self._clientMode != nil}
  /// Clears the value of `clientMode`. Subsequent reads from it will return its default value.
  public mutating func clearClientMode() {self._clientMode = nil}

  public var clientVersion: Server_ClientVersion {
    get {return _clientVersion ?? Server_ClientVersion()}
    set {_clientVersion = newValue}
  }
  /// Returns true if `clientVersion` has been explicitly set.
  public var hasClientVersion: Bool {return self._clientVersion != nil}
  /// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
  public mutating func clearClientVersion() {self._clientVersion = nil}

  public var resource: String = String()

  public var deviceInfo: Server_DeviceInfo {
    get {return _deviceInfo ?? Server_DeviceInfo()}
    set {_deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return self._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {self._deviceInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientMode: Server_ClientMode? = nil
  fileprivate var _clientVersion: Server_ClientVersion? = nil
  fileprivate var _deviceInfo: Server_DeviceInfo? = nil
}

/// Left them to be string for now, will update these later as necessary.
public struct Server_AuthResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resultString: String = String()

  public var reasonString: String = String()

  public var propsHash: Data = Data()

  public var versionTtl: Int64 = 0

  public var result: Server_AuthResult.Result = .unknown

  public var reason: Server_AuthResult.Reason = .unknownReason

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case ok // = 1
    case spubMismatch // = 2
    case invalidClientVersion // = 3
    case invalidResource // = 4
    case accountDeleted // = 5
    case invalidUidOrPassword // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .ok
      case 2: self = .spubMismatch
      case 3: self = .invalidClientVersion
      case 4: self = .invalidResource
      case 5: self = .accountDeleted
      case 6: self = .invalidUidOrPassword
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .ok: return 1
      case .spubMismatch: return 2
      case .invalidClientVersion: return 3
      case .invalidResource: return 4
      case .accountDeleted: return 5
      case .invalidUidOrPassword: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_AuthResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AuthResult.Result] = [
    .unknown,
    .success,
    .failure,
  ]
}

extension Server_AuthResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AuthResult.Reason] = [
    .unknownReason,
    .ok,
    .spubMismatch,
    .invalidClientVersion,
    .invalidResource,
    .accountDeleted,
    .invalidUidOrPassword,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Invite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var result: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_InvitesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invites: [Server_Invite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_InvitesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invitesLeft: Int32 = 0

  public var timeUntilRefresh: Int64 = 0

  public var invites: [Server_Invite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MediaUrl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var get: String = String()

  public var put: String = String()

  public var patch: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UploadMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Int64 = 0

  public var url: Server_MediaUrl {
    get {return _url ?? Server_MediaUrl()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  public var downloadURL: String = String()

  public var type: Server_UploadMedia.TypeEnum = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case `default` // = 0
    case resumable // = 1
    case direct // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .resumable
      case 2: self = .direct
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .resumable: return 1
      case .direct: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _url: Server_MediaUrl? = nil
}

#if swift(>=4.2)

extension Server_UploadMedia.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UploadMedia.TypeEnum] = [
    .default,
    .resumable,
    .direct,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ChatStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var payload: Data = Data()

  public var encPayload: Data = Data()

  /// Temporarily added two payloads: one is for unencrypted and the other is encrypted.
  /// Clients currently send both of them at times.
  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int64 = 0

  public var senderName: String = String()

  public var senderPhone: String = String()

  public var mediaCounters: Server_MediaCounters {
    get {return _mediaCounters ?? Server_MediaCounters()}
    set {_mediaCounters = newValue}
  }
  /// Returns true if `mediaCounters` has been explicitly set.
  public var hasMediaCounters: Bool {return self._mediaCounters != nil}
  /// Clears the value of `mediaCounters`. Subsequent reads from it will return its default value.
  public mutating func clearMediaCounters() {self._mediaCounters = nil}

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String = String()

  public var senderClientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mediaCounters: Server_MediaCounters? = nil
}

/// clients should decrypt, report stats, and then drop this message
public struct Server_SilentChatStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatStanza: Server_ChatStanza {
    get {return _chatStanza ?? Server_ChatStanza()}
    set {_chatStanza = newValue}
  }
  /// Returns true if `chatStanza` has been explicitly set.
  public var hasChatStanza: Bool {return self._chatStanza != nil}
  /// Clears the value of `chatStanza`. Subsequent reads from it will return its default value.
  public mutating func clearChatStanza() {self._chatStanza = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatStanza: Server_ChatStanza? = nil
}

public struct Server_Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ErrorStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Name {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_EndOfQueue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trimmed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HistoryResend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var id: String = String()

  public var payload: Data = Data()

  /// Encrypted payload using the group feed channel.
  public var encPayload: Data = Data()

  /// Sent by the sender.
  public var senderStateBundles: [Server_SenderStateBundle] = []

  /// Meant for the receiver, selected by the server from `sender_state_bundles`.
  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _senderState ?? Server_SenderStateWithKeyInfo()}
    set {_senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return self._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {self._senderState = nil}

  public var audienceHash: Data = Data()

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String = String()

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _senderState: Server_SenderStateWithKeyInfo? = nil
}

public struct Server_StunServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var port: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_TurnServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var port: UInt32 = 0

  public var username: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetCallServers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var peerUid: Int64 = 0

  public var callType: Server_CallType = .unknownType

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetCallServersResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_GetCallServersResult.Result = .unknown

  public var stunServers: [Server_StunServer] = []

  public var turnServers: [Server_TurnServer] = []

  public var callConfig: Server_CallConfig {
    get {return _callConfig ?? Server_CallConfig()}
    set {_callConfig = newValue}
  }
  /// Returns true if `callConfig` has been explicitly set.
  public var hasCallConfig: Bool {return self._callConfig != nil}
  /// Clears the value of `callConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCallConfig() {self._callConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _callConfig: Server_CallConfig? = nil
}

#if swift(>=4.2)

extension Server_GetCallServersResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GetCallServersResult.Result] = [
    .unknown,
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_CallCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// true if the initiator supports pre-answering the call
  public var preAnswer: Bool = false

  /// true if the initiator supports CallSdp ice restart
  public var sdpRestart: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_StartCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var peerUid: Int64 = 0

  public var callType: Server_CallType = .unknownType

  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return self._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {self._webrtcOffer = nil}

  public var rerequestCount: Int32 = 0

  public var callCapabilities: Server_CallCapabilities {
    get {return _callCapabilities ?? Server_CallCapabilities()}
    set {_callCapabilities = newValue}
  }
  /// Returns true if `callCapabilities` has been explicitly set.
  public var hasCallCapabilities: Bool {return self._callCapabilities != nil}
  /// Clears the value of `callCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCallCapabilities() {self._callCapabilities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcOffer: Server_WebRtcSessionDescription? = nil
  fileprivate var _callCapabilities: Server_CallCapabilities? = nil
}

public struct Server_StartCallResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_StartCallResult.Result = .unknown

  public var stunServers: [Server_StunServer] = []

  public var turnServers: [Server_TurnServer] = []

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1

    /// TODO:(nikola) we will likely have to add some sort of reasons here
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_StartCallResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_StartCallResult.Result] = [
    .unknown,
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_WebRtcSessionDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var encPayload: Data = Data()

  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_IncomingCallPush {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  public var callType: Server_CallType {
    get {return _storage._callType}
    set {_uniqueStorage()._callType = newValue}
  }

  public var stunServers: [Server_StunServer] {
    get {return _storage._stunServers}
    set {_uniqueStorage()._stunServers = newValue}
  }

  public var turnServers: [Server_TurnServer] {
    get {return _storage._turnServers}
    set {_uniqueStorage()._turnServers = newValue}
  }

  /// ts when message is generated by the server
  public var timestampMs: Int64 {
    get {return _storage._timestampMs}
    set {_uniqueStorage()._timestampMs = newValue}
  }

  public var callConfig: Server_CallConfig {
    get {return _storage._callConfig ?? Server_CallConfig()}
    set {_uniqueStorage()._callConfig = newValue}
  }
  /// Returns true if `callConfig` has been explicitly set.
  public var hasCallConfig: Bool {return _storage._callConfig != nil}
  /// Clears the value of `callConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCallConfig() {_uniqueStorage()._callConfig = nil}

  public var callCapabilities: Server_CallCapabilities {
    get {return _storage._callCapabilities ?? Server_CallCapabilities()}
    set {_uniqueStorage()._callCapabilities = newValue}
  }
  /// Returns true if `callCapabilities` has been explicitly set.
  public var hasCallCapabilities: Bool {return _storage._callCapabilities != nil}
  /// Clears the value of `callCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCallCapabilities() {_uniqueStorage()._callCapabilities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Server_IncomingCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  public var callType: Server_CallType {
    get {return _storage._callType}
    set {_uniqueStorage()._callType = newValue}
  }

  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _storage._webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_uniqueStorage()._webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return _storage._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {_uniqueStorage()._webrtcOffer = nil}

  public var stunServers: [Server_StunServer] {
    get {return _storage._stunServers}
    set {_uniqueStorage()._stunServers = newValue}
  }

  public var turnServers: [Server_TurnServer] {
    get {return _storage._turnServers}
    set {_uniqueStorage()._turnServers = newValue}
  }

  /// ts when message is generated by the server
  public var timestampMs: Int64 {
    get {return _storage._timestampMs}
    set {_uniqueStorage()._timestampMs = newValue}
  }

  /// ts when the message is send to receiver
  public var serverSentTsMs: Int64 {
    get {return _storage._serverSentTsMs}
    set {_uniqueStorage()._serverSentTsMs = newValue}
  }

  public var callConfig: Server_CallConfig {
    get {return _storage._callConfig ?? Server_CallConfig()}
    set {_uniqueStorage()._callConfig = newValue}
  }
  /// Returns true if `callConfig` has been explicitly set.
  public var hasCallConfig: Bool {return _storage._callConfig != nil}
  /// Clears the value of `callConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCallConfig() {_uniqueStorage()._callConfig = nil}

  public var callCapabilities: Server_CallCapabilities {
    get {return _storage._callCapabilities ?? Server_CallCapabilities()}
    set {_uniqueStorage()._callCapabilities = newValue}
  }
  /// Returns true if `callCapabilities` has been explicitly set.
  public var hasCallCapabilities: Bool {return _storage._callCapabilities != nil}
  /// Clears the value of `callCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCallCapabilities() {_uniqueStorage()._callCapabilities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///RFC 4566 https://datatracker.ietf.org/doc/html/rfc4566#section-5.14
public struct Server_IceCandidate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var sdpMediaID: String = String()

  public var sdpMediaLineIndex: Int32 = 0

  public var sdp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// send when the receiver of the calls starts ringing.
public struct Server_CallRinging {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var timestampMs: Int64 = 0

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
}

/// send before the AnswerCall so we can connect the PeerConnection
/// DEPRECATED send the answer with the pre-answer with the ringing message.
public struct Server_PreAnswerCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
}

public struct Server_AnswerCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var timestampMs: Int64 = 0

  /// used when both sides have pre-answer capabilites
  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return self._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {self._webrtcOffer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
  fileprivate var _webrtcOffer: Server_WebRtcSessionDescription? = nil
}

public struct Server_CallSdp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var sdp: Server_CallSdp.OneOf_Sdp? = nil

  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {
      if case .webrtcOffer(let v)? = sdp {return v}
      return Server_WebRtcSessionDescription()
    }
    set {sdp = .webrtcOffer(newValue)}
  }

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {
      if case .webrtcAnswer(let v)? = sdp {return v}
      return Server_WebRtcSessionDescription()
    }
    set {sdp = .webrtcAnswer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Sdp: Equatable {
    case webrtcOffer(Server_WebRtcSessionDescription)
    case webrtcAnswer(Server_WebRtcSessionDescription)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_CallSdp.OneOf_Sdp, rhs: Server_CallSdp.OneOf_Sdp) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.webrtcOffer, .webrtcOffer): return {
        guard case .webrtcOffer(let l) = lhs, case .webrtcOffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webrtcAnswer, .webrtcAnswer): return {
        guard case .webrtcAnswer(let l) = lhs, case .webrtcAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_EndCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var reason: Server_EndCall.Reason = .unknown

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// receiver rejects the incoming call
    case reject // = 1

    /// receiver is in another call
    case busy // = 2

    /// sender or receiver times out the call after ringing for some time.
    case timeout // = 3

    /// initiator or receiver end the call.
    case callEnd // = 4

    /// initiator hangups before the call connects.
    case cancel // = 5

    /// receiver could not decrypt the content.
    case decryptionFailed // = 6

    /// receiver could not encrypt the answer.
    case encryptionFailed // = 7

    /// system errors or crashes.
    case systemError // = 8

    /// unsupported video calls.
    case videoUnsupported // = 9

    /// ice connection state error.
    case connectionError // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .reject
      case 2: self = .busy
      case 3: self = .timeout
      case 4: self = .callEnd
      case 5: self = .cancel
      case 6: self = .decryptionFailed
      case 7: self = .encryptionFailed
      case 8: self = .systemError
      case 9: self = .videoUnsupported
      case 10: self = .connectionError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .reject: return 1
      case .busy: return 2
      case .timeout: return 3
      case .callEnd: return 4
      case .cancel: return 5
      case .decryptionFailed: return 6
      case .encryptionFailed: return 7
      case .systemError: return 8
      case .videoUnsupported: return 9
      case .connectionError: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_EndCall.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_EndCall.Reason] = [
    .unknown,
    .reject,
    .busy,
    .timeout,
    .callEnd,
    .cancel,
    .decryptionFailed,
    .encryptionFailed,
    .systemError,
    .videoUnsupported,
    .connectionError,
  ]
}

#endif  // swift(>=4.2)

/// DEPRECATED
public struct Server_IceRestartOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var idx: Int32 = 0

  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return self._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {self._webrtcOffer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcOffer: Server_WebRtcSessionDescription? = nil
}

/// DEPRECATED
public struct Server_IceRestartAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var idx: Int32 = 0

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
}

public struct Server_HoldCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var hold: Bool = false

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MuteCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var mediaType: Server_MuteCall.MediaType = .audio

  public var muted: Bool = false

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MediaType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case audio // = 0
    case video // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .audio
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .audio
      case 1: self = .video
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .audio: return 0
      case .video: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MuteCall.MediaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MuteCall.MediaType] = [
    .audio,
    .video,
  ]
}

#endif  // swift(>=4.2)

public struct Server_CallConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioBitrateMax: Int32 = 0

  public var videoBitrateMax: Int32 = 0

  public var audioCodec: Int32 = 0

  public var videoCodec: Int32 = 0

  public var videoWidth: Int32 = 0

  public var videoHeight: Int32 = 0

  public var videoFps: Int32 = 0

  public var audioJitterBufferMaxPackets: Int32 = 0

  public var audioJitterBufferFastAccelerate: Bool = false

  public var iceTransportPolicy: Server_CallConfig.IceTransportPolicy = .all

  public var iceRestartDelayMs: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum IceTransportPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case relay // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .relay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .relay: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_CallConfig.IceTransportPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_CallConfig.IceTransportPolicy] = [
    .all,
    .relay,
  ]
}

#endif  // swift(>=4.2)

/// External Sharing
public struct Server_OgTagInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var description_p: String = String()

  public var thumbnailURL: String = String()

  public var thumbnailWidth: Int32 = 0

  public var thumbnailHeight: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ExternalSharePost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_ExternalSharePost.Action = .store

  public var blobID: String = String()

  public var blob: Data = Data()

  public var expiresInSeconds: Int64 = 0

  public var ogTagInfo: Server_OgTagInfo {
    get {return _ogTagInfo ?? Server_OgTagInfo()}
    set {_ogTagInfo = newValue}
  }
  /// Returns true if `ogTagInfo` has been explicitly set.
  public var hasOgTagInfo: Bool {return self._ogTagInfo != nil}
  /// Clears the value of `ogTagInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOgTagInfo() {self._ogTagInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case store // = 0
    case delete // = 1
    case get // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .store
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .store
      case 1: self = .delete
      case 2: self = .get
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .store: return 0
      case .delete: return 1
      case .get: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _ogTagInfo: Server_OgTagInfo? = nil
}

#if swift(>=4.2)

extension Server_ExternalSharePost.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ExternalSharePost.Action] = [
    .store,
    .delete,
    .get,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ExternalSharePostContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var blob: Data = Data()

  public var ogTagInfo: Server_OgTagInfo {
    get {return _ogTagInfo ?? Server_OgTagInfo()}
    set {_ogTagInfo = newValue}
  }
  /// Returns true if `ogTagInfo` has been explicitly set.
  public var hasOgTagInfo: Bool {return self._ogTagInfo != nil}
  /// Clears the value of `ogTagInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOgTagInfo() {self._ogTagInfo = nil}

  public var name: String = String()

  public var avatarID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ogTagInfo: Server_OgTagInfo? = nil
}

public struct Server_WebClientInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_WebClientInfo.Action = .unknownAction

  public var staticKey: Data = Data()

  public var result: Server_WebClientInfo.Result = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownAction // = 0

    /// Used by web client
    case addKey // = 1

    /// Used by web client
    case isKeyAuthenticated // = 2

    /// Used by mobile client
    case authenticateKey // = 3

    /// Used by web client and mobile client
    case removeKey // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownAction
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownAction
      case 1: self = .addKey
      case 2: self = .isKeyAuthenticated
      case 3: self = .authenticateKey
      case 4: self = .removeKey
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownAction: return 0
      case .addKey: return 1
      case .isKeyAuthenticated: return 2
      case .authenticateKey: return 3
      case .removeKey: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1
    case authenticated // = 2
    case notAuthenticated // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .authenticated
      case 3: self = .notAuthenticated
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .authenticated: return 2
      case .notAuthenticated: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_WebClientInfo.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WebClientInfo.Action] = [
    .unknownAction,
    .addKey,
    .isKeyAuthenticated,
    .authenticateKey,
    .removeKey,
  ]
}

extension Server_WebClientInfo.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WebClientInfo.Result] = [
    .unknown,
    .ok,
    .authenticated,
    .notAuthenticated,
  ]
}

#endif  // swift(>=4.2)

public struct Server_WebStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Used to identify the user. Must be set on every packet exchanged
  public var staticKey: Data = Data()

  /// between mobile and web client.
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Iq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: Server_Iq.TypeEnum = .get

  public var payload: Server_Iq.OneOf_Payload? = nil

  public var uploadMedia: Server_UploadMedia {
    get {
      if case .uploadMedia(let v)? = payload {return v}
      return Server_UploadMedia()
    }
    set {payload = .uploadMedia(newValue)}
  }

  public var contactList: Server_ContactList {
    get {
      if case .contactList(let v)? = payload {return v}
      return Server_ContactList()
    }
    set {payload = .contactList(newValue)}
  }

  public var uploadAvatar: Server_UploadAvatar {
    get {
      if case .uploadAvatar(let v)? = payload {return v}
      return Server_UploadAvatar()
    }
    set {payload = .uploadAvatar(newValue)}
  }

  public var avatar: Server_Avatar {
    get {
      if case .avatar(let v)? = payload {return v}
      return Server_Avatar()
    }
    set {payload = .avatar(newValue)}
  }

  public var avatars: Server_Avatars {
    get {
      if case .avatars(let v)? = payload {return v}
      return Server_Avatars()
    }
    set {payload = .avatars(newValue)}
  }

  public var clientMode: Server_ClientMode {
    get {
      if case .clientMode(let v)? = payload {return v}
      return Server_ClientMode()
    }
    set {payload = .clientMode(newValue)}
  }

  public var clientVersion: Server_ClientVersion {
    get {
      if case .clientVersion(let v)? = payload {return v}
      return Server_ClientVersion()
    }
    set {payload = .clientVersion(newValue)}
  }

  public var pushRegister: Server_PushRegister {
    get {
      if case .pushRegister(let v)? = payload {return v}
      return Server_PushRegister()
    }
    set {payload = .pushRegister(newValue)}
  }

  public var whisperKeys: Server_WhisperKeys {
    get {
      if case .whisperKeys(let v)? = payload {return v}
      return Server_WhisperKeys()
    }
    set {payload = .whisperKeys(newValue)}
  }

  public var ping: Server_Ping {
    get {
      if case .ping(let v)? = payload {return v}
      return Server_Ping()
    }
    set {payload = .ping(newValue)}
  }

  public var feedItem: Server_FeedItem {
    get {
      if case .feedItem(let v)? = payload {return v}
      return Server_FeedItem()
    }
    set {payload = .feedItem(newValue)}
  }

  public var privacyList: Server_PrivacyList {
    get {
      if case .privacyList(let v)? = payload {return v}
      return Server_PrivacyList()
    }
    set {payload = .privacyList(newValue)}
  }

  public var privacyLists: Server_PrivacyLists {
    get {
      if case .privacyLists(let v)? = payload {return v}
      return Server_PrivacyLists()
    }
    set {payload = .privacyLists(newValue)}
  }

  public var groupStanza: Server_GroupStanza {
    get {
      if case .groupStanza(let v)? = payload {return v}
      return Server_GroupStanza()
    }
    set {payload = .groupStanza(newValue)}
  }

  public var groupsStanza: Server_GroupsStanza {
    get {
      if case .groupsStanza(let v)? = payload {return v}
      return Server_GroupsStanza()
    }
    set {payload = .groupsStanza(newValue)}
  }

  public var clientLog: Server_ClientLog {
    get {
      if case .clientLog(let v)? = payload {return v}
      return Server_ClientLog()
    }
    set {payload = .clientLog(newValue)}
  }

  public var name: Server_Name {
    get {
      if case .name(let v)? = payload {return v}
      return Server_Name()
    }
    set {payload = .name(newValue)}
  }

  public var errorStanza: Server_ErrorStanza {
    get {
      if case .errorStanza(let v)? = payload {return v}
      return Server_ErrorStanza()
    }
    set {payload = .errorStanza(newValue)}
  }

  public var props: Server_Props {
    get {
      if case .props(let v)? = payload {return v}
      return Server_Props()
    }
    set {payload = .props(newValue)}
  }

  public var invitesRequest: Server_InvitesRequest {
    get {
      if case .invitesRequest(let v)? = payload {return v}
      return Server_InvitesRequest()
    }
    set {payload = .invitesRequest(newValue)}
  }

  public var invitesResponse: Server_InvitesResponse {
    get {
      if case .invitesResponse(let v)? = payload {return v}
      return Server_InvitesResponse()
    }
    set {payload = .invitesResponse(newValue)}
  }

  public var notificationPrefs: Server_NotificationPrefs {
    get {
      if case .notificationPrefs(let v)? = payload {return v}
      return Server_NotificationPrefs()
    }
    set {payload = .notificationPrefs(newValue)}
  }

  public var groupFeedItem: Server_GroupFeedItem {
    get {
      if case .groupFeedItem(let v)? = payload {return v}
      return Server_GroupFeedItem()
    }
    set {payload = .groupFeedItem(newValue)}
  }

  public var groupAvatar: Server_UploadGroupAvatar {
    get {
      if case .groupAvatar(let v)? = payload {return v}
      return Server_UploadGroupAvatar()
    }
    set {payload = .groupAvatar(newValue)}
  }

  public var deleteAccount: Server_DeleteAccount {
    get {
      if case .deleteAccount(let v)? = payload {return v}
      return Server_DeleteAccount()
    }
    set {payload = .deleteAccount(newValue)}
  }

  public var groupInviteLink: Server_GroupInviteLink {
    get {
      if case .groupInviteLink(let v)? = payload {return v}
      return Server_GroupInviteLink()
    }
    set {payload = .groupInviteLink(newValue)}
  }

  public var historyResend: Server_HistoryResend {
    get {
      if case .historyResend(let v)? = payload {return v}
      return Server_HistoryResend()
    }
    set {payload = .historyResend(newValue)}
  }

  public var exportData: Server_ExportData {
    get {
      if case .exportData(let v)? = payload {return v}
      return Server_ExportData()
    }
    set {payload = .exportData(newValue)}
  }

  public var contactSyncError: Server_ContactSyncError {
    get {
      if case .contactSyncError(let v)? = payload {return v}
      return Server_ContactSyncError()
    }
    set {payload = .contactSyncError(newValue)}
  }

  /// only for sms_app gateway use
  public var clientOtpRequest: Server_ClientOtpRequest {
    get {
      if case .clientOtpRequest(let v)? = payload {return v}
      return Server_ClientOtpRequest()
    }
    set {payload = .clientOtpRequest(newValue)}
  }

  /// only for sms_app gateway use
  public var clientOtpResponse: Server_ClientOtpResponse {
    get {
      if case .clientOtpResponse(let v)? = payload {return v}
      return Server_ClientOtpResponse()
    }
    set {payload = .clientOtpResponse(newValue)}
  }

  public var whisperKeysCollection: Server_WhisperKeysCollection {
    get {
      if case .whisperKeysCollection(let v)? = payload {return v}
      return Server_WhisperKeysCollection()
    }
    set {payload = .whisperKeysCollection(newValue)}
  }

  public var getCallServers: Server_GetCallServers {
    get {
      if case .getCallServers(let v)? = payload {return v}
      return Server_GetCallServers()
    }
    set {payload = .getCallServers(newValue)}
  }

  public var getCallServersResult: Server_GetCallServersResult {
    get {
      if case .getCallServersResult(let v)? = payload {return v}
      return Server_GetCallServersResult()
    }
    set {payload = .getCallServersResult(newValue)}
  }

  public var startCall: Server_StartCall {
    get {
      if case .startCall(let v)? = payload {return v}
      return Server_StartCall()
    }
    set {payload = .startCall(newValue)}
  }

  public var startCallResult: Server_StartCallResult {
    get {
      if case .startCallResult(let v)? = payload {return v}
      return Server_StartCallResult()
    }
    set {payload = .startCallResult(newValue)}
  }

  public var truncWhisperKeysCollection: Server_TruncWhisperKeysCollection {
    get {
      if case .truncWhisperKeysCollection(let v)? = payload {return v}
      return Server_TruncWhisperKeysCollection()
    }
    set {payload = .truncWhisperKeysCollection(newValue)}
  }

  public var externalSharePost: Server_ExternalSharePost {
    get {
      if case .externalSharePost(let v)? = payload {return v}
      return Server_ExternalSharePost()
    }
    set {payload = .externalSharePost(newValue)}
  }

  public var externalSharePostContainer: Server_ExternalSharePostContainer {
    get {
      if case .externalSharePostContainer(let v)? = payload {return v}
      return Server_ExternalSharePostContainer()
    }
    set {payload = .externalSharePostContainer(newValue)}
  }

  public var webClientInfo: Server_WebClientInfo {
    get {
      if case .webClientInfo(let v)? = payload {return v}
      return Server_WebClientInfo()
    }
    set {payload = .webClientInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case uploadMedia(Server_UploadMedia)
    case contactList(Server_ContactList)
    case uploadAvatar(Server_UploadAvatar)
    case avatar(Server_Avatar)
    case avatars(Server_Avatars)
    case clientMode(Server_ClientMode)
    case clientVersion(Server_ClientVersion)
    case pushRegister(Server_PushRegister)
    case whisperKeys(Server_WhisperKeys)
    case ping(Server_Ping)
    case feedItem(Server_FeedItem)
    case privacyList(Server_PrivacyList)
    case privacyLists(Server_PrivacyLists)
    case groupStanza(Server_GroupStanza)
    case groupsStanza(Server_GroupsStanza)
    case clientLog(Server_ClientLog)
    case name(Server_Name)
    case errorStanza(Server_ErrorStanza)
    case props(Server_Props)
    case invitesRequest(Server_InvitesRequest)
    case invitesResponse(Server_InvitesResponse)
    case notificationPrefs(Server_NotificationPrefs)
    case groupFeedItem(Server_GroupFeedItem)
    case groupAvatar(Server_UploadGroupAvatar)
    case deleteAccount(Server_DeleteAccount)
    case groupInviteLink(Server_GroupInviteLink)
    case historyResend(Server_HistoryResend)
    case exportData(Server_ExportData)
    case contactSyncError(Server_ContactSyncError)
    /// only for sms_app gateway use
    case clientOtpRequest(Server_ClientOtpRequest)
    /// only for sms_app gateway use
    case clientOtpResponse(Server_ClientOtpResponse)
    case whisperKeysCollection(Server_WhisperKeysCollection)
    case getCallServers(Server_GetCallServers)
    case getCallServersResult(Server_GetCallServersResult)
    case startCall(Server_StartCall)
    case startCallResult(Server_StartCallResult)
    case truncWhisperKeysCollection(Server_TruncWhisperKeysCollection)
    case externalSharePost(Server_ExternalSharePost)
    case externalSharePostContainer(Server_ExternalSharePostContainer)
    case webClientInfo(Server_WebClientInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Iq.OneOf_Payload, rhs: Server_Iq.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uploadMedia, .uploadMedia): return {
        guard case .uploadMedia(let l) = lhs, case .uploadMedia(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactList, .contactList): return {
        guard case .contactList(let l) = lhs, case .contactList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uploadAvatar, .uploadAvatar): return {
        guard case .uploadAvatar(let l) = lhs, case .uploadAvatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avatar, .avatar): return {
        guard case .avatar(let l) = lhs, case .avatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avatars, .avatars): return {
        guard case .avatars(let l) = lhs, case .avatars(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientMode, .clientMode): return {
        guard case .clientMode(let l) = lhs, case .clientMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientVersion, .clientVersion): return {
        guard case .clientVersion(let l) = lhs, case .clientVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pushRegister, .pushRegister): return {
        guard case .pushRegister(let l) = lhs, case .pushRegister(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whisperKeys, .whisperKeys): return {
        guard case .whisperKeys(let l) = lhs, case .whisperKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feedItem, .feedItem): return {
        guard case .feedItem(let l) = lhs, case .feedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.privacyList, .privacyList): return {
        guard case .privacyList(let l) = lhs, case .privacyList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.privacyLists, .privacyLists): return {
        guard case .privacyLists(let l) = lhs, case .privacyLists(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupStanza, .groupStanza): return {
        guard case .groupStanza(let l) = lhs, case .groupStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupsStanza, .groupsStanza): return {
        guard case .groupsStanza(let l) = lhs, case .groupsStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientLog, .clientLog): return {
        guard case .clientLog(let l) = lhs, case .clientLog(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorStanza, .errorStanza): return {
        guard case .errorStanza(let l) = lhs, case .errorStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.props, .props): return {
        guard case .props(let l) = lhs, case .props(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invitesRequest, .invitesRequest): return {
        guard case .invitesRequest(let l) = lhs, case .invitesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invitesResponse, .invitesResponse): return {
        guard case .invitesResponse(let l) = lhs, case .invitesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationPrefs, .notificationPrefs): return {
        guard case .notificationPrefs(let l) = lhs, case .notificationPrefs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedItem, .groupFeedItem): return {
        guard case .groupFeedItem(let l) = lhs, case .groupFeedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupAvatar, .groupAvatar): return {
        guard case .groupAvatar(let l) = lhs, case .groupAvatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteAccount, .deleteAccount): return {
        guard case .deleteAccount(let l) = lhs, case .deleteAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInviteLink, .groupInviteLink): return {
        guard case .groupInviteLink(let l) = lhs, case .groupInviteLink(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.historyResend, .historyResend): return {
        guard case .historyResend(let l) = lhs, case .historyResend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exportData, .exportData): return {
        guard case .exportData(let l) = lhs, case .exportData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactSyncError, .contactSyncError): return {
        guard case .contactSyncError(let l) = lhs, case .contactSyncError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientOtpRequest, .clientOtpRequest): return {
        guard case .clientOtpRequest(let l) = lhs, case .clientOtpRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientOtpResponse, .clientOtpResponse): return {
        guard case .clientOtpResponse(let l) = lhs, case .clientOtpResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whisperKeysCollection, .whisperKeysCollection): return {
        guard case .whisperKeysCollection(let l) = lhs, case .whisperKeysCollection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCallServers, .getCallServers): return {
        guard case .getCallServers(let l) = lhs, case .getCallServers(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCallServersResult, .getCallServersResult): return {
        guard case .getCallServersResult(let l) = lhs, case .getCallServersResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startCall, .startCall): return {
        guard case .startCall(let l) = lhs, case .startCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startCallResult, .startCallResult): return {
        guard case .startCallResult(let l) = lhs, case .startCallResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.truncWhisperKeysCollection, .truncWhisperKeysCollection): return {
        guard case .truncWhisperKeysCollection(let l) = lhs, case .truncWhisperKeysCollection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalSharePost, .externalSharePost): return {
        guard case .externalSharePost(let l) = lhs, case .externalSharePost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalSharePostContainer, .externalSharePostContainer): return {
        guard case .externalSharePostContainer(let l) = lhs, case .externalSharePostContainer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webClientInfo, .webClientInfo): return {
        guard case .webClientInfo(let l) = lhs, case .webClientInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case set // = 1
    case result // = 2
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .set
      case 2: self = .result
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .set: return 1
      case .result: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Iq.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Iq.TypeEnum] = [
    .get,
    .set,
    .result,
    .error,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Msg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: Server_Msg.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var toUid: Int64 {
    get {return _storage._toUid}
    set {_uniqueStorage()._toUid = newValue}
  }

  public var fromUid: Int64 {
    get {return _storage._fromUid}
    set {_uniqueStorage()._fromUid = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var contactList: Server_ContactList {
    get {
      if case .contactList(let v)? = _storage._payload {return v}
      return Server_ContactList()
    }
    set {_uniqueStorage()._payload = .contactList(newValue)}
  }

  public var avatar: Server_Avatar {
    get {
      if case .avatar(let v)? = _storage._payload {return v}
      return Server_Avatar()
    }
    set {_uniqueStorage()._payload = .avatar(newValue)}
  }

  public var whisperKeys: Server_WhisperKeys {
    get {
      if case .whisperKeys(let v)? = _storage._payload {return v}
      return Server_WhisperKeys()
    }
    set {_uniqueStorage()._payload = .whisperKeys(newValue)}
  }

  public var seenReceipt: Server_SeenReceipt {
    get {
      if case .seenReceipt(let v)? = _storage._payload {return v}
      return Server_SeenReceipt()
    }
    set {_uniqueStorage()._payload = .seenReceipt(newValue)}
  }

  public var deliveryReceipt: Server_DeliveryReceipt {
    get {
      if case .deliveryReceipt(let v)? = _storage._payload {return v}
      return Server_DeliveryReceipt()
    }
    set {_uniqueStorage()._payload = .deliveryReceipt(newValue)}
  }

  public var chatStanza: Server_ChatStanza {
    get {
      if case .chatStanza(let v)? = _storage._payload {return v}
      return Server_ChatStanza()
    }
    set {_uniqueStorage()._payload = .chatStanza(newValue)}
  }

  public var feedItem: Server_FeedItem {
    get {
      if case .feedItem(let v)? = _storage._payload {return v}
      return Server_FeedItem()
    }
    set {_uniqueStorage()._payload = .feedItem(newValue)}
  }

  public var feedItems: Server_FeedItems {
    get {
      if case .feedItems(let v)? = _storage._payload {return v}
      return Server_FeedItems()
    }
    set {_uniqueStorage()._payload = .feedItems(newValue)}
  }

  public var contactHash: Server_ContactHash {
    get {
      if case .contactHash(let v)? = _storage._payload {return v}
      return Server_ContactHash()
    }
    set {_uniqueStorage()._payload = .contactHash(newValue)}
  }

  public var groupStanza: Server_GroupStanza {
    get {
      if case .groupStanza(let v)? = _storage._payload {return v}
      return Server_GroupStanza()
    }
    set {_uniqueStorage()._payload = .groupStanza(newValue)}
  }

  public var groupChat: Server_GroupChat {
    get {
      if case .groupChat(let v)? = _storage._payload {return v}
      return Server_GroupChat()
    }
    set {_uniqueStorage()._payload = .groupChat(newValue)}
  }

  public var name: Server_Name {
    get {
      if case .name(let v)? = _storage._payload {return v}
      return Server_Name()
    }
    set {_uniqueStorage()._payload = .name(newValue)}
  }

  public var errorStanza: Server_ErrorStanza {
    get {
      if case .errorStanza(let v)? = _storage._payload {return v}
      return Server_ErrorStanza()
    }
    set {_uniqueStorage()._payload = .errorStanza(newValue)}
  }

  public var groupchatRetract: Server_GroupChatRetract {
    get {
      if case .groupchatRetract(let v)? = _storage._payload {return v}
      return Server_GroupChatRetract()
    }
    set {_uniqueStorage()._payload = .groupchatRetract(newValue)}
  }

  public var chatRetract: Server_ChatRetract {
    get {
      if case .chatRetract(let v)? = _storage._payload {return v}
      return Server_ChatRetract()
    }
    set {_uniqueStorage()._payload = .chatRetract(newValue)}
  }

  public var groupFeedItem: Server_GroupFeedItem {
    get {
      if case .groupFeedItem(let v)? = _storage._payload {return v}
      return Server_GroupFeedItem()
    }
    set {_uniqueStorage()._payload = .groupFeedItem(newValue)}
  }

  public var rerequest: Server_Rerequest {
    get {
      if case .rerequest(let v)? = _storage._payload {return v}
      return Server_Rerequest()
    }
    set {_uniqueStorage()._payload = .rerequest(newValue)}
  }

  public var silentChatStanza: Server_SilentChatStanza {
    get {
      if case .silentChatStanza(let v)? = _storage._payload {return v}
      return Server_SilentChatStanza()
    }
    set {_uniqueStorage()._payload = .silentChatStanza(newValue)}
  }

  public var groupFeedItems: Server_GroupFeedItems {
    get {
      if case .groupFeedItems(let v)? = _storage._payload {return v}
      return Server_GroupFeedItems()
    }
    set {_uniqueStorage()._payload = .groupFeedItems(newValue)}
  }

  public var endOfQueue: Server_EndOfQueue {
    get {
      if case .endOfQueue(let v)? = _storage._payload {return v}
      return Server_EndOfQueue()
    }
    set {_uniqueStorage()._payload = .endOfQueue(newValue)}
  }

  public var inviteeNotice: Server_InviteeNotice {
    get {
      if case .inviteeNotice(let v)? = _storage._payload {return v}
      return Server_InviteeNotice()
    }
    set {_uniqueStorage()._payload = .inviteeNotice(newValue)}
  }

  public var groupFeedRerequest: Server_GroupFeedRerequest {
    get {
      if case .groupFeedRerequest(let v)? = _storage._payload {return v}
      return Server_GroupFeedRerequest()
    }
    set {_uniqueStorage()._payload = .groupFeedRerequest(newValue)}
  }

  public var historyResend: Server_HistoryResend {
    get {
      if case .historyResend(let v)? = _storage._payload {return v}
      return Server_HistoryResend()
    }
    set {_uniqueStorage()._payload = .historyResend(newValue)}
  }

  public var playedReceipt: Server_PlayedReceipt {
    get {
      if case .playedReceipt(let v)? = _storage._payload {return v}
      return Server_PlayedReceipt()
    }
    set {_uniqueStorage()._payload = .playedReceipt(newValue)}
  }

  public var requestLogs: Server_RequestLogs {
    get {
      if case .requestLogs(let v)? = _storage._payload {return v}
      return Server_RequestLogs()
    }
    set {_uniqueStorage()._payload = .requestLogs(newValue)}
  }

  /// only for use with SMSApp clients
  public var wakeup: Server_WakeUp {
    get {
      if case .wakeup(let v)? = _storage._payload {return v}
      return Server_WakeUp()
    }
    set {_uniqueStorage()._payload = .wakeup(newValue)}
  }

  public var homeFeedRerequest: Server_HomeFeedRerequest {
    get {
      if case .homeFeedRerequest(let v)? = _storage._payload {return v}
      return Server_HomeFeedRerequest()
    }
    set {_uniqueStorage()._payload = .homeFeedRerequest(newValue)}
  }

  public var incomingCall: Server_IncomingCall {
    get {
      if case .incomingCall(let v)? = _storage._payload {return v}
      return Server_IncomingCall()
    }
    set {_uniqueStorage()._payload = .incomingCall(newValue)}
  }

  public var callRinging: Server_CallRinging {
    get {
      if case .callRinging(let v)? = _storage._payload {return v}
      return Server_CallRinging()
    }
    set {_uniqueStorage()._payload = .callRinging(newValue)}
  }

  public var answerCall: Server_AnswerCall {
    get {
      if case .answerCall(let v)? = _storage._payload {return v}
      return Server_AnswerCall()
    }
    set {_uniqueStorage()._payload = .answerCall(newValue)}
  }

  public var endCall: Server_EndCall {
    get {
      if case .endCall(let v)? = _storage._payload {return v}
      return Server_EndCall()
    }
    set {_uniqueStorage()._payload = .endCall(newValue)}
  }

  public var iceCandidate: Server_IceCandidate {
    get {
      if case .iceCandidate(let v)? = _storage._payload {return v}
      return Server_IceCandidate()
    }
    set {_uniqueStorage()._payload = .iceCandidate(newValue)}
  }

  /// only for server use
  public var marketingAlert: Server_MarketingAlert {
    get {
      if case .marketingAlert(let v)? = _storage._payload {return v}
      return Server_MarketingAlert()
    }
    set {_uniqueStorage()._payload = .marketingAlert(newValue)}
  }

  /// deprecated, use call_sdp
  public var iceRestartOffer: Server_IceRestartOffer {
    get {
      if case .iceRestartOffer(let v)? = _storage._payload {return v}
      return Server_IceRestartOffer()
    }
    set {_uniqueStorage()._payload = .iceRestartOffer(newValue)}
  }

  /// deprecated, use call_sdp
  public var iceRestartAnswer: Server_IceRestartAnswer {
    get {
      if case .iceRestartAnswer(let v)? = _storage._payload {return v}
      return Server_IceRestartAnswer()
    }
    set {_uniqueStorage()._payload = .iceRestartAnswer(newValue)}
  }

  public var groupFeedHistory: Server_GroupFeedHistory {
    get {
      if case .groupFeedHistory(let v)? = _storage._payload {return v}
      return Server_GroupFeedHistory()
    }
    set {_uniqueStorage()._payload = .groupFeedHistory(newValue)}
  }

  /// deprecated, set answer in ringing
  public var preAnswerCall: Server_PreAnswerCall {
    get {
      if case .preAnswerCall(let v)? = _storage._payload {return v}
      return Server_PreAnswerCall()
    }
    set {_uniqueStorage()._payload = .preAnswerCall(newValue)}
  }

  public var holdCall: Server_HoldCall {
    get {
      if case .holdCall(let v)? = _storage._payload {return v}
      return Server_HoldCall()
    }
    set {_uniqueStorage()._payload = .holdCall(newValue)}
  }

  public var muteCall: Server_MuteCall {
    get {
      if case .muteCall(let v)? = _storage._payload {return v}
      return Server_MuteCall()
    }
    set {_uniqueStorage()._payload = .muteCall(newValue)}
  }

  public var incomingCallPush: Server_IncomingCallPush {
    get {
      if case .incomingCallPush(let v)? = _storage._payload {return v}
      return Server_IncomingCallPush()
    }
    set {_uniqueStorage()._payload = .incomingCallPush(newValue)}
  }

  public var callSdp: Server_CallSdp {
    get {
      if case .callSdp(let v)? = _storage._payload {return v}
      return Server_CallSdp()
    }
    set {_uniqueStorage()._payload = .callSdp(newValue)}
  }

  public var webStanza: Server_WebStanza {
    get {
      if case .webStanza(let v)? = _storage._payload {return v}
      return Server_WebStanza()
    }
    set {_uniqueStorage()._payload = .webStanza(newValue)}
  }

  public var retryCount: Int32 {
    get {return _storage._retryCount}
    set {_uniqueStorage()._retryCount = newValue}
  }

  public var rerequestCount: Int32 {
    get {return _storage._rerequestCount}
    set {_uniqueStorage()._rerequestCount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case contactList(Server_ContactList)
    case avatar(Server_Avatar)
    case whisperKeys(Server_WhisperKeys)
    case seenReceipt(Server_SeenReceipt)
    case deliveryReceipt(Server_DeliveryReceipt)
    case chatStanza(Server_ChatStanza)
    case feedItem(Server_FeedItem)
    case feedItems(Server_FeedItems)
    case contactHash(Server_ContactHash)
    case groupStanza(Server_GroupStanza)
    case groupChat(Server_GroupChat)
    case name(Server_Name)
    case errorStanza(Server_ErrorStanza)
    case groupchatRetract(Server_GroupChatRetract)
    case chatRetract(Server_ChatRetract)
    case groupFeedItem(Server_GroupFeedItem)
    case rerequest(Server_Rerequest)
    case silentChatStanza(Server_SilentChatStanza)
    case groupFeedItems(Server_GroupFeedItems)
    case endOfQueue(Server_EndOfQueue)
    case inviteeNotice(Server_InviteeNotice)
    case groupFeedRerequest(Server_GroupFeedRerequest)
    case historyResend(Server_HistoryResend)
    case playedReceipt(Server_PlayedReceipt)
    case requestLogs(Server_RequestLogs)
    /// only for use with SMSApp clients
    case wakeup(Server_WakeUp)
    case homeFeedRerequest(Server_HomeFeedRerequest)
    case incomingCall(Server_IncomingCall)
    case callRinging(Server_CallRinging)
    case answerCall(Server_AnswerCall)
    case endCall(Server_EndCall)
    case iceCandidate(Server_IceCandidate)
    /// only for server use
    case marketingAlert(Server_MarketingAlert)
    /// deprecated, use call_sdp
    case iceRestartOffer(Server_IceRestartOffer)
    /// deprecated, use call_sdp
    case iceRestartAnswer(Server_IceRestartAnswer)
    case groupFeedHistory(Server_GroupFeedHistory)
    /// deprecated, set answer in ringing
    case preAnswerCall(Server_PreAnswerCall)
    case holdCall(Server_HoldCall)
    case muteCall(Server_MuteCall)
    case incomingCallPush(Server_IncomingCallPush)
    case callSdp(Server_CallSdp)
    case webStanza(Server_WebStanza)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Msg.OneOf_Payload, rhs: Server_Msg.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contactList, .contactList): return {
        guard case .contactList(let l) = lhs, case .contactList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avatar, .avatar): return {
        guard case .avatar(let l) = lhs, case .avatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whisperKeys, .whisperKeys): return {
        guard case .whisperKeys(let l) = lhs, case .whisperKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seenReceipt, .seenReceipt): return {
        guard case .seenReceipt(let l) = lhs, case .seenReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deliveryReceipt, .deliveryReceipt): return {
        guard case .deliveryReceipt(let l) = lhs, case .deliveryReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatStanza, .chatStanza): return {
        guard case .chatStanza(let l) = lhs, case .chatStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feedItem, .feedItem): return {
        guard case .feedItem(let l) = lhs, case .feedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feedItems, .feedItems): return {
        guard case .feedItems(let l) = lhs, case .feedItems(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactHash, .contactHash): return {
        guard case .contactHash(let l) = lhs, case .contactHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupStanza, .groupStanza): return {
        guard case .groupStanza(let l) = lhs, case .groupStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupChat, .groupChat): return {
        guard case .groupChat(let l) = lhs, case .groupChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorStanza, .errorStanza): return {
        guard case .errorStanza(let l) = lhs, case .errorStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupchatRetract, .groupchatRetract): return {
        guard case .groupchatRetract(let l) = lhs, case .groupchatRetract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatRetract, .chatRetract): return {
        guard case .chatRetract(let l) = lhs, case .chatRetract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedItem, .groupFeedItem): return {
        guard case .groupFeedItem(let l) = lhs, case .groupFeedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rerequest, .rerequest): return {
        guard case .rerequest(let l) = lhs, case .rerequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.silentChatStanza, .silentChatStanza): return {
        guard case .silentChatStanza(let l) = lhs, case .silentChatStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedItems, .groupFeedItems): return {
        guard case .groupFeedItems(let l) = lhs, case .groupFeedItems(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endOfQueue, .endOfQueue): return {
        guard case .endOfQueue(let l) = lhs, case .endOfQueue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inviteeNotice, .inviteeNotice): return {
        guard case .inviteeNotice(let l) = lhs, case .inviteeNotice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedRerequest, .groupFeedRerequest): return {
        guard case .groupFeedRerequest(let l) = lhs, case .groupFeedRerequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.historyResend, .historyResend): return {
        guard case .historyResend(let l) = lhs, case .historyResend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playedReceipt, .playedReceipt): return {
        guard case .playedReceipt(let l) = lhs, case .playedReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestLogs, .requestLogs): return {
        guard case .requestLogs(let l) = lhs, case .requestLogs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wakeup, .wakeup): return {
        guard case .wakeup(let l) = lhs, case .wakeup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.homeFeedRerequest, .homeFeedRerequest): return {
        guard case .homeFeedRerequest(let l) = lhs, case .homeFeedRerequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.incomingCall, .incomingCall): return {
        guard case .incomingCall(let l) = lhs, case .incomingCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callRinging, .callRinging): return {
        guard case .callRinging(let l) = lhs, case .callRinging(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.answerCall, .answerCall): return {
        guard case .answerCall(let l) = lhs, case .answerCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endCall, .endCall): return {
        guard case .endCall(let l) = lhs, case .endCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceCandidate, .iceCandidate): return {
        guard case .iceCandidate(let l) = lhs, case .iceCandidate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.marketingAlert, .marketingAlert): return {
        guard case .marketingAlert(let l) = lhs, case .marketingAlert(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceRestartOffer, .iceRestartOffer): return {
        guard case .iceRestartOffer(let l) = lhs, case .iceRestartOffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceRestartAnswer, .iceRestartAnswer): return {
        guard case .iceRestartAnswer(let l) = lhs, case .iceRestartAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedHistory, .groupFeedHistory): return {
        guard case .groupFeedHistory(let l) = lhs, case .groupFeedHistory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preAnswerCall, .preAnswerCall): return {
        guard case .preAnswerCall(let l) = lhs, case .preAnswerCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.holdCall, .holdCall): return {
        guard case .holdCall(let l) = lhs, case .holdCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.muteCall, .muteCall): return {
        guard case .muteCall(let l) = lhs, case .muteCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.incomingCallPush, .incomingCallPush): return {
        guard case .incomingCallPush(let l) = lhs, case .incomingCallPush(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callSdp, .callSdp): return {
        guard case .callSdp(let l) = lhs, case .callSdp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webStanza, .webStanza): return {
        guard case .webStanza(let l) = lhs, case .webStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case error // = 1
    case groupchat // = 2
    case headline // = 3

    /// Not used yet.
    case chat // = 4
    case call // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .error
      case 2: self = .groupchat
      case 3: self = .headline
      case 4: self = .chat
      case 5: self = .call
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .error: return 1
      case .groupchat: return 2
      case .headline: return 3
      case .chat: return 4
      case .call: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_Msg.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Msg.TypeEnum] = [
    .normal,
    .error,
    .groupchat,
    .headline,
    .chat,
    .call,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Presence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: Server_Presence.TypeEnum = .available

  /// Clients must stop using this field.
  public var uid: Int64 = 0

  public var lastSeen: Int64 = 0

  public var toUid: Int64 = 0

  public var fromUid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case away // = 1
    case subscribe // = 2
    case unsubscribe // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .away
      case 2: self = .subscribe
      case 3: self = .unsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .away: return 1
      case .subscribe: return 2
      case .unsubscribe: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Presence.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Presence.TypeEnum] = [
    .available,
    .away,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ChatState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ChatState.TypeEnum = .available

  public var threadID: String = String()

  public var threadType: Server_ChatState.ThreadType = .chat

  public var fromUid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case typing // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .typing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .typing: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ThreadType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case groupChat // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .groupChat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .groupChat: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ChatState.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ChatState.TypeEnum] = [
    .available,
    .typing,
  ]
}

extension Server_ChatState.ThreadType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ChatState.ThreadType] = [
    .chat,
    .groupChat,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Ack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HaError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stanza: Server_Packet.OneOf_Stanza? = nil

  public var msg: Server_Msg {
    get {
      if case .msg(let v)? = stanza {return v}
      return Server_Msg()
    }
    set {stanza = .msg(newValue)}
  }

  public var iq: Server_Iq {
    get {
      if case .iq(let v)? = stanza {return v}
      return Server_Iq()
    }
    set {stanza = .iq(newValue)}
  }

  public var ack: Server_Ack {
    get {
      if case .ack(let v)? = stanza {return v}
      return Server_Ack()
    }
    set {stanza = .ack(newValue)}
  }

  public var presence: Server_Presence {
    get {
      if case .presence(let v)? = stanza {return v}
      return Server_Presence()
    }
    set {stanza = .presence(newValue)}
  }

  public var haError: Server_HaError {
    get {
      if case .haError(let v)? = stanza {return v}
      return Server_HaError()
    }
    set {stanza = .haError(newValue)}
  }

  public var chatState: Server_ChatState {
    get {
      if case .chatState(let v)? = stanza {return v}
      return Server_ChatState()
    }
    set {stanza = .chatState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Stanza: Equatable {
    case msg(Server_Msg)
    case iq(Server_Iq)
    case ack(Server_Ack)
    case presence(Server_Presence)
    case haError(Server_HaError)
    case chatState(Server_ChatState)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Packet.OneOf_Stanza, rhs: Server_Packet.OneOf_Stanza) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.msg, .msg): return {
        guard case .msg(let l) = lhs, case .msg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iq, .iq): return {
        guard case .iq(let l) = lhs, case .iq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ack, .ack): return {
        guard case .ack(let l) = lhs, case .ack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.presence, .presence): return {
        guard case .presence(let l) = lhs, case .presence(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.haError, .haError): return {
        guard case .haError(let l) = lhs, case .haError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatState, .chatState): return {
        guard case .chatState(let l) = lhs, case .chatState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_UidElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_UidElement.Action = .add

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_UidElement.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UidElement.Action] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PhoneElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_PhoneElement.Action = .add

  public var phone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PhoneElement.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PhoneElement.Action] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PrivacyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_PrivacyList.TypeEnum = .all

  public var uidElements: [Server_UidElement] = []

  public var hash: Data = Data()

  public var phoneElements: [Server_PhoneElement] = []

  public var usingPhones: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case block // = 1
    case except // = 2
    case mute // = 3
    case only // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .block
      case 2: self = .except
      case 3: self = .mute
      case 4: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .block: return 1
      case .except: return 2
      case .mute: return 3
      case .only: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PrivacyList.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PrivacyList.TypeEnum] = [
    .all,
    .block,
    .except,
    .mute,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PrivacyLists {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeType: Server_PrivacyLists.TypeEnum = .all

  public var lists: [Server_PrivacyList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case block // = 1
    case except // = 2
    case only // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .block
      case 2: self = .except
      case 3: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .block: return 1
      case .except: return 2
      case .only: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PrivacyLists.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PrivacyLists.TypeEnum] = [
    .all,
    .block,
    .except,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PushToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenType: Server_PushToken.TokenType = .android

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TokenType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case android // = 0
    case ios // = 1
    case iosDev // = 2
    case iosAppclip // = 3
    case iosVoip // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .android
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .android
      case 1: self = .ios
      case 2: self = .iosDev
      case 3: self = .iosAppclip
      case 4: self = .iosVoip
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .android: return 0
      case .ios: return 1
      case .iosDev: return 2
      case .iosAppclip: return 3
      case .iosVoip: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PushToken.TokenType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PushToken.TokenType] = [
    .android,
    .ios,
    .iosDev,
    .iosAppclip,
    .iosVoip,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PushRegister {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pushToken: Server_PushToken {
    get {return _pushToken ?? Server_PushToken()}
    set {_pushToken = newValue}
  }
  /// Returns true if `pushToken` has been explicitly set.
  public var hasPushToken: Bool {return self._pushToken != nil}
  /// Clears the value of `pushToken`. Subsequent reads from it will return its default value.
  public mutating func clearPushToken() {self._pushToken = nil}

  public var langID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pushToken: Server_PushToken? = nil
}

public struct Server_PushPref {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Server_PushPref.Name = .post

  public var value: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Name: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case post // = 0
    case comment // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .comment: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PushPref.Name: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PushPref.Name] = [
    .post,
    .comment,
  ]
}

#endif  // swift(>=4.2)

public struct Server_NotificationPrefs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pushPrefs: [Server_PushPref] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Rerequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var identityKey: Data = Data()

  public var signedPreKeyID: Int64 = 0

  public var oneTimePreKeyID: Int64 = 0

  public var sessionSetupEphemeralKey: Data = Data()

  public var messageEphemeralKey: Data = Data()

  public var contentType: Server_Rerequest.ContentType = .chat

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case call // = 1
    case groupHistory // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .call
      case 2: self = .groupHistory
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .call: return 1
      case .groupHistory: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Rerequest.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Rerequest.ContentType] = [
    .chat,
    .call,
    .groupHistory,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupFeedRerequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  /// Post id or Comment id or HistoryResend id
  public var id: String = String()

  public var rerequestType: Server_GroupFeedRerequest.RerequestType = .payload

  public var contentType: Server_GroupFeedRerequest.ContentType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// To capture the type of decryption failure.
  public enum RerequestType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unable to decrypt post/comment/history-resend payload
    case payload // = 0

    /// Unable to decrypt sender state.
    case senderState // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .payload
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .payload
      case 1: self = .senderState
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .payload: return 0
      case .senderState: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case post // = 1
    case comment // = 2
    case historyResend // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .post
      case 2: self = .comment
      case 3: self = .historyResend
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .post: return 1
      case .comment: return 2
      case .historyResend: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupFeedRerequest.RerequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupFeedRerequest.RerequestType] = [
    .payload,
    .senderState,
  ]
}

extension Server_GroupFeedRerequest.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupFeedRerequest.ContentType] = [
    .unknown,
    .post,
    .comment,
    .historyResend,
  ]
}

#endif  // swift(>=4.2)

public struct Server_HomeFeedRerequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Post id or Comment id.
  public var id: String = String()

  public var rerequestType: Server_HomeFeedRerequest.RerequestType = .unknownType

  public var contentType: Server_HomeFeedRerequest.ContentType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// To capture the type of decryption failure.
  public enum RerequestType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0

    /// Unable to decrypt post/comment's payload
    case payload // = 1

    /// Unable to decrypt sender state.
    case senderState // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .payload
      case 2: self = .senderState
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .payload: return 1
      case .senderState: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case post // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .post
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .post: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_HomeFeedRerequest.RerequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeFeedRerequest.RerequestType] = [
    .unknownType,
    .payload,
    .senderState,
  ]
}

extension Server_HomeFeedRerequest.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeFeedRerequest.ContentType] = [
    .unknown,
    .post,
    .comment,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SeenReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DeliveryReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PlayedReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupChatRetract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var gid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ChatRetract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Prop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Props {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = Data()

  public var props: [Server_Prop] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_WhisperKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var action: Server_WhisperKeys.Action = .normal

  public var identityKey: Data = Data()

  public var signedKey: Data = Data()

  public var otpKeyCount: Int32 = 0

  public var oneTimeKeys: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case add // = 1
    case count // = 2
    case get // = 3
    case set // = 4
    case update // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .add
      case 2: self = .count
      case 3: self = .get
      case 4: self = .set
      case 5: self = .update
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .add: return 1
      case .count: return 2
      case .get: return 3
      case .set: return 4
      case .update: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_WhisperKeys.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WhisperKeys.Action] = [
    .normal,
    .add,
    .count,
    .get,
    .set,
    .update,
  ]
}

#endif  // swift(>=4.2)

public struct Server_TruncWhisperKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  /// The following field is first 4 bytes of the public part of the identity key.
  public var truncPublicIdentityKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_WhisperKeysCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Action is always get.
  public var collection: [Server_WhisperKeys] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_TruncWhisperKeysCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Action is always get.
  public var collection: [Server_TruncWhisperKeys] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_NoiseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageType: Server_NoiseMessage.MessageType = .xxA

  /// Third party library we use for Noise handshake provides API to read/write Noise messages.
  /// The following content represent the bytes returned by write message and such content is
  /// correctly consumed by the receiving library for matching handshake pattern and handshake
  /// state.
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MessageType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// -> e
    case xxA // = 0

    /// <- e, ee, s, es
    case xxB // = 1

    /// -> s, se
    case xxC // = 2

    /// (<- s ...) -> e, es, s, ss
    case ikA // = 3

    /// <- e, ee, se
    case ikB // = 4

    /// (-> e ...) <- e, ee, s, es
    case xxFallbackA // = 5

    /// -> s, se
    case xxFallbackB // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .xxA
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .xxA
      case 1: self = .xxB
      case 2: self = .xxC
      case 3: self = .ikA
      case 4: self = .ikB
      case 5: self = .xxFallbackA
      case 6: self = .xxFallbackB
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .xxA: return 0
      case .xxB: return 1
      case .xxC: return 2
      case .ikA: return 3
      case .ikB: return 4
      case .xxFallbackA: return 5
      case .xxFallbackB: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_NoiseMessage.MessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_NoiseMessage.MessageType] = [
    .xxA,
    .xxB,
    .xxC,
    .ikA,
    .ikB,
    .xxFallbackA,
    .xxFallbackB,
  ]
}

#endif  // swift(>=4.2)

public struct Server_DeleteAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var reason: Server_DeleteAccount.Reason = .unknownDeleteReason

  public var feedback: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownDeleteReason // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownDeleteReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownDeleteReason
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownDeleteReason: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_DeleteAccount.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_DeleteAccount.Reason] = [
    .unknownDeleteReason,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ExportData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataReadyTs: Int64 = 0

  public var status: Server_ExportData.Status = .unknown

  public var dataURL: String = String()

  public var availableUntilTs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case pending // = 1
    case ready // = 2
    case notStarted // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .pending
      case 2: self = .ready
      case 3: self = .notStarted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .pending: return 1
      case .ready: return 2
      case .notStarted: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ExportData.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ExportData.Status] = [
    .unknown,
    .pending,
    .ready,
    .notStarted,
  ]
}

#endif  // swift(>=4.2)

/// PushContent
public struct Server_PushContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var certificate: Data = Data()

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Invitee Notice
public struct Server_InviteeNotice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inviters: [Server_Inviter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Inviter details
public struct Server_Inviter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var name: String = String()

  public var phone: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Identity Key
public struct Server_IdentityKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Logs request
public struct Server_RequestLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_RegisterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Server_RegisterRequest.OneOf_Request? = nil

  public var otpRequest: Server_OtpRequest {
    get {
      if case .otpRequest(let v)? = request {return v}
      return Server_OtpRequest()
    }
    set {request = .otpRequest(newValue)}
  }

  public var verifyRequest: Server_VerifyOtpRequest {
    get {
      if case .verifyRequest(let v)? = request {return v}
      return Server_VerifyOtpRequest()
    }
    set {request = .verifyRequest(newValue)}
  }

  public var hashcashRequest: Server_HashcashRequest {
    get {
      if case .hashcashRequest(let v)? = request {return v}
      return Server_HashcashRequest()
    }
    set {request = .hashcashRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case otpRequest(Server_OtpRequest)
    case verifyRequest(Server_VerifyOtpRequest)
    case hashcashRequest(Server_HashcashRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_RegisterRequest.OneOf_Request, rhs: Server_RegisterRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.otpRequest, .otpRequest): return {
        guard case .otpRequest(let l) = lhs, case .otpRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyRequest, .verifyRequest): return {
        guard case .verifyRequest(let l) = lhs, case .verifyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcashRequest, .hashcashRequest): return {
        guard case .hashcashRequest(let l) = lhs, case .hashcashRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_RegisterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Server_RegisterResponse.OneOf_Response? = nil

  public var otpResponse: Server_OtpResponse {
    get {
      if case .otpResponse(let v)? = response {return v}
      return Server_OtpResponse()
    }
    set {response = .otpResponse(newValue)}
  }

  public var verifyResponse: Server_VerifyOtpResponse {
    get {
      if case .verifyResponse(let v)? = response {return v}
      return Server_VerifyOtpResponse()
    }
    set {response = .verifyResponse(newValue)}
  }

  public var hashcashResponse: Server_HashcashResponse {
    get {
      if case .hashcashResponse(let v)? = response {return v}
      return Server_HashcashResponse()
    }
    set {response = .hashcashResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case otpResponse(Server_OtpResponse)
    case verifyResponse(Server_VerifyOtpResponse)
    case hashcashResponse(Server_HashcashResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_RegisterResponse.OneOf_Response, rhs: Server_RegisterResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.otpResponse, .otpResponse): return {
        guard case .otpResponse(let l) = lhs, case .otpResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyResponse, .verifyResponse): return {
        guard case .verifyResponse(let l) = lhs, case .verifyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcashResponse, .hashcashResponse): return {
        guard case .hashcashResponse(let l) = lhs, case .hashcashResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_HashcashRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var countryCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HashcashResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hashcashChallenge: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_OtpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var method: Server_OtpRequest.Method = .sms

  public var langID: String = String()

  public var groupInviteToken: String = String()

  public var userAgent: String = String()

  public var hashcashSolution: String = String()

  public var hashcashSolutionTimeTakenMs: Int64 = 0

  public var campaignID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Method: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sms // = 0
    case voiceCall // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .sms
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sms
      case 1: self = .voiceCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sms: return 0
      case .voiceCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_OtpRequest.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_OtpRequest.Method] = [
    .sms,
    .voiceCall,
  ]
}

#endif  // swift(>=4.2)

public struct Server_OtpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var result: Server_OtpResponse.Result = .unknownResult

  public var reason: Server_OtpResponse.Reason = .unknownReason

  public var retryAfterSecs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case invalidPhoneNumber // = 1
    case invalidClientVersion // = 2
    case badMethod // = 3
    case otpFail // = 4
    case notInvited // = 5
    case invalidGroupInviteToken // = 6
    case retriedTooSoon // = 7
    case badRequest // = 8
    case internalServerError // = 9
    case invalidHashcashNonce // = 10
    case wrongHashcashSolution // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .invalidPhoneNumber
      case 2: self = .invalidClientVersion
      case 3: self = .badMethod
      case 4: self = .otpFail
      case 5: self = .notInvited
      case 6: self = .invalidGroupInviteToken
      case 7: self = .retriedTooSoon
      case 8: self = .badRequest
      case 9: self = .internalServerError
      case 10: self = .invalidHashcashNonce
      case 11: self = .wrongHashcashSolution
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .invalidPhoneNumber: return 1
      case .invalidClientVersion: return 2
      case .badMethod: return 3
      case .otpFail: return 4
      case .notInvited: return 5
      case .invalidGroupInviteToken: return 6
      case .retriedTooSoon: return 7
      case .badRequest: return 8
      case .internalServerError: return 9
      case .invalidHashcashNonce: return 10
      case .wrongHashcashSolution: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_OtpResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_OtpResponse.Result] = [
    .unknownResult,
    .success,
    .failure,
  ]
}

extension Server_OtpResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_OtpResponse.Reason] = [
    .unknownReason,
    .invalidPhoneNumber,
    .invalidClientVersion,
    .badMethod,
    .otpFail,
    .notInvited,
    .invalidGroupInviteToken,
    .retriedTooSoon,
    .badRequest,
    .internalServerError,
    .invalidHashcashNonce,
    .wrongHashcashSolution,
  ]
}

#endif  // swift(>=4.2)

public struct Server_VerifyOtpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var code: String = String()

  public var name: String = String()

  public var staticKey: Data = Data()

  public var signedPhrase: Data = Data()

  public var identityKey: Data = Data()

  public var signedKey: Data = Data()

  public var oneTimeKeys: [Data] = []

  public var groupInviteToken: String = String()

  /// Only for ios-appclip
  public var pushRegister: Server_PushRegister {
    get {return _pushRegister ?? Server_PushRegister()}
    set {_pushRegister = newValue}
  }
  /// Returns true if `pushRegister` has been explicitly set.
  public var hasPushRegister: Bool {return self._pushRegister != nil}
  /// Clears the value of `pushRegister`. Subsequent reads from it will return its default value.
  public mutating func clearPushRegister() {self._pushRegister = nil}

  public var userAgent: String = String()

  public var campaignID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pushRegister: Server_PushRegister? = nil
}

public struct Server_VerifyOtpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var uid: Int64 = 0

  public var name: String = String()

  public var result: Server_VerifyOtpResponse.Result = .unknownResult

  public var reason: Server_VerifyOtpResponse.Reason = .unknownReason

  public var groupInviteResult: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case invalidPhoneNumber // = 1
    case invalidClientVersion // = 2
    case wrongSmsCode // = 3
    case missingPhone // = 4
    case missingCode // = 5
    case missingName // = 6
    case invalidName // = 7
    case missingIdentityKey // = 8
    case missingSignedKey // = 9
    case missingOneTimeKeys // = 10
    case badBase64Key // = 11
    case invalidOneTimeKeys // = 12
    case tooFewOneTimeKeys // = 13
    case tooManyOneTimeKeys // = 14
    case tooBigIdentityKey // = 15
    case tooBigSignedKey // = 16
    case tooBigOneTimeKeys // = 17
    case invalidSEdPub // = 18
    case invalidSignedPhrase // = 19
    case unableToOpenSignedPhrase // = 20
    case badRequest // = 21
    case internalServerError // = 22
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .invalidPhoneNumber
      case 2: self = .invalidClientVersion
      case 3: self = .wrongSmsCode
      case 4: self = .missingPhone
      case 5: self = .missingCode
      case 6: self = .missingName
      case 7: self = .invalidName
      case 8: self = .missingIdentityKey
      case 9: self = .missingSignedKey
      case 10: self = .missingOneTimeKeys
      case 11: self = .badBase64Key
      case 12: self = .invalidOneTimeKeys
      case 13: self = .tooFewOneTimeKeys
      case 14: self = .tooManyOneTimeKeys
      case 15: self = .tooBigIdentityKey
      case 16: self = .tooBigSignedKey
      case 17: self = .tooBigOneTimeKeys
      case 18: self = .invalidSEdPub
      case 19: self = .invalidSignedPhrase
      case 20: self = .unableToOpenSignedPhrase
      case 21: self = .badRequest
      case 22: self = .internalServerError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .invalidPhoneNumber: return 1
      case .invalidClientVersion: return 2
      case .wrongSmsCode: return 3
      case .missingPhone: return 4
      case .missingCode: return 5
      case .missingName: return 6
      case .invalidName: return 7
      case .missingIdentityKey: return 8
      case .missingSignedKey: return 9
      case .missingOneTimeKeys: return 10
      case .badBase64Key: return 11
      case .invalidOneTimeKeys: return 12
      case .tooFewOneTimeKeys: return 13
      case .tooManyOneTimeKeys: return 14
      case .tooBigIdentityKey: return 15
      case .tooBigSignedKey: return 16
      case .tooBigOneTimeKeys: return 17
      case .invalidSEdPub: return 18
      case .invalidSignedPhrase: return 19
      case .unableToOpenSignedPhrase: return 20
      case .badRequest: return 21
      case .internalServerError: return 22
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_VerifyOtpResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_VerifyOtpResponse.Result] = [
    .unknownResult,
    .success,
    .failure,
  ]
}

extension Server_VerifyOtpResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_VerifyOtpResponse.Reason] = [
    .unknownReason,
    .invalidPhoneNumber,
    .invalidClientVersion,
    .wrongSmsCode,
    .missingPhone,
    .missingCode,
    .missingName,
    .invalidName,
    .missingIdentityKey,
    .missingSignedKey,
    .missingOneTimeKeys,
    .badBase64Key,
    .invalidOneTimeKeys,
    .tooFewOneTimeKeys,
    .tooManyOneTimeKeys,
    .tooBigIdentityKey,
    .tooBigSignedKey,
    .tooBigOneTimeKeys,
    .invalidSEdPub,
    .invalidSignedPhrase,
    .unableToOpenSignedPhrase,
    .badRequest,
    .internalServerError,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ClientOtpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: Server_ClientOtpRequest.Method = .sms

  public var phone: String = String()

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Method: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sms // = 0
    case voiceCall // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .sms
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sms
      case 1: self = .voiceCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sms: return 0
      case .voiceCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ClientOtpRequest.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientOtpRequest.Method] = [
    .sms,
    .voiceCall,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ClientOtpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_ClientOtpResponse.Result = .unknownResult

  public var reason: Server_ClientOtpResponse.Reason = .unknownReason

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case setupIssue // = 1
    case permissionIssue // = 2
    case formattingIssue // = 3

    /// Client should retry a few times in this case.
    case networkingIssue // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .setupIssue
      case 2: self = .permissionIssue
      case 3: self = .formattingIssue
      case 4: self = .networkingIssue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .setupIssue: return 1
      case .permissionIssue: return 2
      case .formattingIssue: return 3
      case .networkingIssue: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ClientOtpResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientOtpResponse.Result] = [
    .unknownResult,
    .success,
    .failure,
  ]
}

extension Server_ClientOtpResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientOtpResponse.Reason] = [
    .unknownReason,
    .setupIssue,
    .permissionIssue,
    .formattingIssue,
    .networkingIssue,
  ]
}

#endif  // swift(>=4.2)

public struct Server_WakeUp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MarketingAlert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_MarketingAlert.TypeEnum = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case inviteFriends // = 1
    case sharePost // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .inviteFriends
      case 2: self = .sharePost
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .inviteFriends: return 1
      case .sharePost: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MarketingAlert.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MarketingAlert.TypeEnum] = [
    .unknown,
    .inviteFriends,
    .sharePost,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Server_CallType: @unchecked Sendable {}
extension Server_UploadAvatar: @unchecked Sendable {}
extension Server_Avatar: @unchecked Sendable {}
extension Server_Avatars: @unchecked Sendable {}
extension Server_UploadGroupAvatar: @unchecked Sendable {}
extension Server_CertMessage: @unchecked Sendable {}
extension Server_ClientMode: @unchecked Sendable {}
extension Server_ClientMode.Mode: @unchecked Sendable {}
extension Server_ClientVersion: @unchecked Sendable {}
extension Server_DeviceInfo: @unchecked Sendable {}
extension Server_ClientLog: @unchecked Sendable {}
extension Server_Count: @unchecked Sendable {}
extension Server_Dim: @unchecked Sendable {}
extension Server_Contact: @unchecked Sendable {}
extension Server_Contact.Action: @unchecked Sendable {}
extension Server_ContactList: @unchecked Sendable {}
extension Server_ContactList.TypeEnum: @unchecked Sendable {}
extension Server_ContactHash: @unchecked Sendable {}
extension Server_ContactSyncError: @unchecked Sendable {}
extension Server_MediaCounters: @unchecked Sendable {}
extension Server_Audience: @unchecked Sendable {}
extension Server_Audience.TypeEnum: @unchecked Sendable {}
extension Server_Post: @unchecked Sendable {}
extension Server_Post.Tag: @unchecked Sendable {}
extension Server_Comment: @unchecked Sendable {}
extension Server_ShareStanza: @unchecked Sendable {}
extension Server_FeedItem: @unchecked Sendable {}
extension Server_FeedItem.OneOf_Item: @unchecked Sendable {}
extension Server_FeedItem.Action: @unchecked Sendable {}
extension Server_FeedItems: @unchecked Sendable {}
extension Server_SenderStateWithKeyInfo: @unchecked Sendable {}
extension Server_SenderStateBundle: @unchecked Sendable {}
extension Server_GroupFeedItem: @unchecked Sendable {}
extension Server_GroupFeedItem.OneOf_Item: @unchecked Sendable {}
extension Server_GroupFeedItem.Action: @unchecked Sendable {}
extension Server_GroupFeedItems: @unchecked Sendable {}
extension Server_GroupFeedHistory: @unchecked Sendable {}
extension Server_GroupMember: @unchecked Sendable {}
extension Server_GroupMember.Action: @unchecked Sendable {}
extension Server_GroupMember.TypeEnum: @unchecked Sendable {}
extension Server_GroupStanza: @unchecked Sendable {}
extension Server_GroupStanza.Action: @unchecked Sendable {}
extension Server_GroupChat: @unchecked Sendable {}
extension Server_GroupsStanza: @unchecked Sendable {}
extension Server_GroupsStanza.Action: @unchecked Sendable {}
extension Server_GroupInviteLink: @unchecked Sendable {}
extension Server_GroupInviteLink.Action: @unchecked Sendable {}
extension Server_AuthRequest: @unchecked Sendable {}
extension Server_AuthResult: @unchecked Sendable {}
extension Server_AuthResult.Result: @unchecked Sendable {}
extension Server_AuthResult.Reason: @unchecked Sendable {}
extension Server_Invite: @unchecked Sendable {}
extension Server_InvitesRequest: @unchecked Sendable {}
extension Server_InvitesResponse: @unchecked Sendable {}
extension Server_MediaUrl: @unchecked Sendable {}
extension Server_UploadMedia: @unchecked Sendable {}
extension Server_UploadMedia.TypeEnum: @unchecked Sendable {}
extension Server_ChatStanza: @unchecked Sendable {}
extension Server_SilentChatStanza: @unchecked Sendable {}
extension Server_Ping: @unchecked Sendable {}
extension Server_ErrorStanza: @unchecked Sendable {}
extension Server_Name: @unchecked Sendable {}
extension Server_EndOfQueue: @unchecked Sendable {}
extension Server_HistoryResend: @unchecked Sendable {}
extension Server_StunServer: @unchecked Sendable {}
extension Server_TurnServer: @unchecked Sendable {}
extension Server_GetCallServers: @unchecked Sendable {}
extension Server_GetCallServersResult: @unchecked Sendable {}
extension Server_GetCallServersResult.Result: @unchecked Sendable {}
extension Server_CallCapabilities: @unchecked Sendable {}
extension Server_StartCall: @unchecked Sendable {}
extension Server_StartCallResult: @unchecked Sendable {}
extension Server_StartCallResult.Result: @unchecked Sendable {}
extension Server_WebRtcSessionDescription: @unchecked Sendable {}
extension Server_IncomingCallPush: @unchecked Sendable {}
extension Server_IncomingCall: @unchecked Sendable {}
extension Server_IceCandidate: @unchecked Sendable {}
extension Server_CallRinging: @unchecked Sendable {}
extension Server_PreAnswerCall: @unchecked Sendable {}
extension Server_AnswerCall: @unchecked Sendable {}
extension Server_CallSdp: @unchecked Sendable {}
extension Server_CallSdp.OneOf_Sdp: @unchecked Sendable {}
extension Server_EndCall: @unchecked Sendable {}
extension Server_EndCall.Reason: @unchecked Sendable {}
extension Server_IceRestartOffer: @unchecked Sendable {}
extension Server_IceRestartAnswer: @unchecked Sendable {}
extension Server_HoldCall: @unchecked Sendable {}
extension Server_MuteCall: @unchecked Sendable {}
extension Server_MuteCall.MediaType: @unchecked Sendable {}
extension Server_CallConfig: @unchecked Sendable {}
extension Server_CallConfig.IceTransportPolicy: @unchecked Sendable {}
extension Server_OgTagInfo: @unchecked Sendable {}
extension Server_ExternalSharePost: @unchecked Sendable {}
extension Server_ExternalSharePost.Action: @unchecked Sendable {}
extension Server_ExternalSharePostContainer: @unchecked Sendable {}
extension Server_WebClientInfo: @unchecked Sendable {}
extension Server_WebClientInfo.Action: @unchecked Sendable {}
extension Server_WebClientInfo.Result: @unchecked Sendable {}
extension Server_WebStanza: @unchecked Sendable {}
extension Server_Iq: @unchecked Sendable {}
extension Server_Iq.OneOf_Payload: @unchecked Sendable {}
extension Server_Iq.TypeEnum: @unchecked Sendable {}
extension Server_Msg: @unchecked Sendable {}
extension Server_Msg.OneOf_Payload: @unchecked Sendable {}
extension Server_Msg.TypeEnum: @unchecked Sendable {}
extension Server_Presence: @unchecked Sendable {}
extension Server_Presence.TypeEnum: @unchecked Sendable {}
extension Server_ChatState: @unchecked Sendable {}
extension Server_ChatState.TypeEnum: @unchecked Sendable {}
extension Server_ChatState.ThreadType: @unchecked Sendable {}
extension Server_Ack: @unchecked Sendable {}
extension Server_HaError: @unchecked Sendable {}
extension Server_Packet: @unchecked Sendable {}
extension Server_Packet.OneOf_Stanza: @unchecked Sendable {}
extension Server_UidElement: @unchecked Sendable {}
extension Server_UidElement.Action: @unchecked Sendable {}
extension Server_PhoneElement: @unchecked Sendable {}
extension Server_PhoneElement.Action: @unchecked Sendable {}
extension Server_PrivacyList: @unchecked Sendable {}
extension Server_PrivacyList.TypeEnum: @unchecked Sendable {}
extension Server_PrivacyLists: @unchecked Sendable {}
extension Server_PrivacyLists.TypeEnum: @unchecked Sendable {}
extension Server_PushToken: @unchecked Sendable {}
extension Server_PushToken.TokenType: @unchecked Sendable {}
extension Server_PushRegister: @unchecked Sendable {}
extension Server_PushPref: @unchecked Sendable {}
extension Server_PushPref.Name: @unchecked Sendable {}
extension Server_NotificationPrefs: @unchecked Sendable {}
extension Server_Rerequest: @unchecked Sendable {}
extension Server_Rerequest.ContentType: @unchecked Sendable {}
extension Server_GroupFeedRerequest: @unchecked Sendable {}
extension Server_GroupFeedRerequest.RerequestType: @unchecked Sendable {}
extension Server_GroupFeedRerequest.ContentType: @unchecked Sendable {}
extension Server_HomeFeedRerequest: @unchecked Sendable {}
extension Server_HomeFeedRerequest.RerequestType: @unchecked Sendable {}
extension Server_HomeFeedRerequest.ContentType: @unchecked Sendable {}
extension Server_SeenReceipt: @unchecked Sendable {}
extension Server_DeliveryReceipt: @unchecked Sendable {}
extension Server_PlayedReceipt: @unchecked Sendable {}
extension Server_GroupChatRetract: @unchecked Sendable {}
extension Server_ChatRetract: @unchecked Sendable {}
extension Server_Prop: @unchecked Sendable {}
extension Server_Props: @unchecked Sendable {}
extension Server_WhisperKeys: @unchecked Sendable {}
extension Server_WhisperKeys.Action: @unchecked Sendable {}
extension Server_TruncWhisperKeys: @unchecked Sendable {}
extension Server_WhisperKeysCollection: @unchecked Sendable {}
extension Server_TruncWhisperKeysCollection: @unchecked Sendable {}
extension Server_NoiseMessage: @unchecked Sendable {}
extension Server_NoiseMessage.MessageType: @unchecked Sendable {}
extension Server_DeleteAccount: @unchecked Sendable {}
extension Server_DeleteAccount.Reason: @unchecked Sendable {}
extension Server_ExportData: @unchecked Sendable {}
extension Server_ExportData.Status: @unchecked Sendable {}
extension Server_PushContent: @unchecked Sendable {}
extension Server_InviteeNotice: @unchecked Sendable {}
extension Server_Inviter: @unchecked Sendable {}
extension Server_IdentityKey: @unchecked Sendable {}
extension Server_RequestLogs: @unchecked Sendable {}
extension Server_RegisterRequest: @unchecked Sendable {}
extension Server_RegisterRequest.OneOf_Request: @unchecked Sendable {}
extension Server_RegisterResponse: @unchecked Sendable {}
extension Server_RegisterResponse.OneOf_Response: @unchecked Sendable {}
extension Server_HashcashRequest: @unchecked Sendable {}
extension Server_HashcashResponse: @unchecked Sendable {}
extension Server_OtpRequest: @unchecked Sendable {}
extension Server_OtpRequest.Method: @unchecked Sendable {}
extension Server_OtpResponse: @unchecked Sendable {}
extension Server_OtpResponse.Result: @unchecked Sendable {}
extension Server_OtpResponse.Reason: @unchecked Sendable {}
extension Server_VerifyOtpRequest: @unchecked Sendable {}
extension Server_VerifyOtpResponse: @unchecked Sendable {}
extension Server_VerifyOtpResponse.Result: @unchecked Sendable {}
extension Server_VerifyOtpResponse.Reason: @unchecked Sendable {}
extension Server_ClientOtpRequest: @unchecked Sendable {}
extension Server_ClientOtpRequest.Method: @unchecked Sendable {}
extension Server_ClientOtpResponse: @unchecked Sendable {}
extension Server_ClientOtpResponse.Result: @unchecked Sendable {}
extension Server_ClientOtpResponse.Reason: @unchecked Sendable {}
extension Server_WakeUp: @unchecked Sendable {}
extension Server_MarketingAlert: @unchecked Sendable {}
extension Server_MarketingAlert.TypeEnum: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_CallType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO"),
    2: .same(proto: "VIDEO"),
  ]
}

extension Server_UploadAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadAvatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
    3: .standard(proto: "full_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.fullData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.fullData.isEmpty {
      try visitor.visitSingularBytesField(value: self.fullData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadAvatar, rhs: Server_UploadAvatar) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.data != rhs.data {return false}
    if lhs.fullData != rhs.fullData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Avatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Avatar, rhs: Server_Avatar) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Avatars: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Avatars"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.avatars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.avatars, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Avatars, rhs: Server_Avatars) -> Bool {
    if lhs.avatars != rhs.avatars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadGroupAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadGroupAvatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "data"),
    3: .standard(proto: "full_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.fullData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.fullData.isEmpty {
      try visitor.visitSingularBytesField(value: self.fullData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadGroupAvatar, rhs: Server_UploadGroupAvatar) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.data != rhs.data {return false}
    if lhs.fullData != rhs.fullData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CertMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "server_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.serverKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.serverKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CertMessage, rhs: Server_CertMessage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.serverKey != rhs.serverKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .active {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientMode, rhs: Server_ClientMode) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientMode.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "PASSIVE"),
  ]
}

extension Server_ClientVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "expires_in_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expiresInSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.expiresInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresInSeconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientVersion, rhs: Server_ClientVersion) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.expiresInSeconds != rhs.expiresInSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .standard(proto: "os_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DeviceInfo, rhs: Server_DeviceInfo) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counts"),
    2: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.counts) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.counts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.counts, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientLog, rhs: Server_ClientLog) -> Bool {
    if lhs.counts != rhs.counts {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Count"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .same(proto: "metric"),
    3: .same(proto: "count"),
    4: .same(proto: "dims"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metric) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.dims) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.metric.isEmpty {
      try visitor.visitSingularStringField(value: self.metric, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    if !self.dims.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dims, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Count, rhs: Server_Count) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.metric != rhs.metric {return false}
    if lhs.count != rhs.count {return false}
    if lhs.dims != rhs.dims {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Dim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dim"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Dim, rhs: Server_Dim) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "raw"),
    3: .same(proto: "normalized"),
    4: .same(proto: "uid"),
    5: .standard(proto: "avatar_id"),
    7: .same(proto: "name"),
    8: .standard(proto: "num_potential_friends"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.raw) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.normalized) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.numPotentialFriends) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 2)
    }
    if !self.normalized.isEmpty {
      try visitor.visitSingularStringField(value: self.normalized, fieldNumber: 3)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    if self.numPotentialFriends != 0 {
      try visitor.visitSingularInt64Field(value: self.numPotentialFriends, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Contact, rhs: Server_Contact) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.normalized != rhs.normalized {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.numPotentialFriends != rhs.numPotentialFriends {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Contact.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_ContactList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "sync_id"),
    3: .standard(proto: "batch_index"),
    4: .standard(proto: "is_last"),
    5: .same(proto: "contacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.syncID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.batchIndex) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isLast) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .full {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.syncID.isEmpty {
      try visitor.visitSingularStringField(value: self.syncID, fieldNumber: 2)
    }
    if self.batchIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.batchIndex, fieldNumber: 3)
    }
    if self.isLast != false {
      try visitor.visitSingularBoolField(value: self.isLast, fieldNumber: 4)
    }
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactList, rhs: Server_ContactList) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.syncID != rhs.syncID {return false}
    if lhs.batchIndex != rhs.batchIndex {return false}
    if lhs.isLast != rhs.isLast {return false}
    if lhs.contacts != rhs.contacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ContactList.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FULL"),
    1: .same(proto: "DELTA"),
    2: .same(proto: "NORMAL"),
    3: .same(proto: "FRIEND_NOTICE"),
    4: .same(proto: "INVITER_NOTICE"),
    5: .same(proto: "DELETE_NOTICE"),
    6: .same(proto: "CONTACT_NOTICE"),
  ]
}

extension Server_ContactHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactHash, rhs: Server_ContactHash) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ContactSyncError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactSyncError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retry_after_secs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.retryAfterSecs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retryAfterSecs != 0 {
      try visitor.visitSingularInt32Field(value: self.retryAfterSecs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactSyncError, rhs: Server_ContactSyncError) -> Bool {
    if lhs.retryAfterSecs != rhs.retryAfterSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaCounters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaCounters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_images"),
    2: .standard(proto: "num_videos"),
    3: .standard(proto: "num_audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numImages) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numVideos) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numAudio) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numImages != 0 {
      try visitor.visitSingularInt32Field(value: self.numImages, fieldNumber: 1)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularInt32Field(value: self.numVideos, fieldNumber: 2)
    }
    if self.numAudio != 0 {
      try visitor.visitSingularInt32Field(value: self.numAudio, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaCounters, rhs: Server_MediaCounters) -> Bool {
    if lhs.numImages != rhs.numImages {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.numAudio != rhs.numAudio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Audience: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Audience"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "uids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.uids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.uids.isEmpty {
      try visitor.visitPackedInt64Field(value: self.uids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Audience, rhs: Server_Audience) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.uids != rhs.uids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Audience.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "EXCEPT"),
    2: .same(proto: "ONLY"),
  ]
}

extension Server_Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Post"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "publisher_uid"),
    3: .same(proto: "payload"),
    4: .same(proto: "audience"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "publisher_name"),
    7: .standard(proto: "enc_payload"),
    8: .standard(proto: "media_counters"),
    9: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.publisherUid) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._audience) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.publisherName) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._mediaCounters) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.publisherUid != 0 {
      try visitor.visitSingularInt64Field(value: self.publisherUid, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    try { if let v = self._audience {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    if !self.publisherName.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherName, fieldNumber: 6)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 7)
    }
    try { if let v = self._mediaCounters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.tag != .empty {
      try visitor.visitSingularEnumField(value: self.tag, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Post, rhs: Server_Post) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.publisherUid != rhs.publisherUid {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._audience != rhs._audience {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.publisherName != rhs.publisherName {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs._mediaCounters != rhs._mediaCounters {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Post.Tag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY"),
    1: .same(proto: "SECRET_POST"),
  ]
}

extension Server_Comment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Comment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "post_id"),
    3: .standard(proto: "parent_comment_id"),
    4: .standard(proto: "publisher_uid"),
    5: .standard(proto: "publisher_name"),
    6: .same(proto: "payload"),
    7: .same(proto: "timestamp"),
    8: .standard(proto: "enc_payload"),
    9: .standard(proto: "media_counters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parentCommentID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.publisherUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.publisherName) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._mediaCounters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 2)
    }
    if !self.parentCommentID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentCommentID, fieldNumber: 3)
    }
    if self.publisherUid != 0 {
      try visitor.visitSingularInt64Field(value: self.publisherUid, fieldNumber: 4)
    }
    if !self.publisherName.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherName, fieldNumber: 5)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 6)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 7)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 8)
    }
    try { if let v = self._mediaCounters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Comment, rhs: Server_Comment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.parentCommentID != rhs.parentCommentID {return false}
    if lhs.publisherUid != rhs.publisherUid {return false}
    if lhs.publisherName != rhs.publisherName {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs._mediaCounters != rhs._mediaCounters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ShareStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "post_ids"),
    3: .same(proto: "result"),
    4: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.postIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.postIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.postIds, fieldNumber: 2)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ShareStanza, rhs: Server_ShareStanza) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.postIds != rhs.postIds {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "post"),
    3: .same(proto: "comment"),
    4: .standard(proto: "share_stanzas"),
    5: .standard(proto: "sender_state_bundles"),
    6: .standard(proto: "sender_state"),
  ]

  fileprivate class _StorageClass {
    var _action: Server_FeedItem.Action = .publish
    var _item: Server_FeedItem.OneOf_Item?
    var _shareStanzas: [Server_ShareStanza] = []
    var _senderStateBundles: [Server_SenderStateBundle] = []
    var _senderState: Server_SenderStateWithKeyInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _item = source._item
      _shareStanzas = source._shareStanzas
      _senderStateBundles = source._senderStateBundles
      _senderState = source._senderState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 2: try {
          var v: Server_Post?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .post(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .post(v)
          }
        }()
        case 3: try {
          var v: Server_Comment?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .comment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .comment(v)
          }
        }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._shareStanzas) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._senderStateBundles) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._senderState) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._action != .publish {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 1)
      }
      switch _storage._item {
      case .post?: try {
        guard case .post(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .comment?: try {
        guard case .comment(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if !_storage._shareStanzas.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._shareStanzas, fieldNumber: 4)
      }
      if !_storage._senderStateBundles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._senderStateBundles, fieldNumber: 5)
      }
      try { if let v = _storage._senderState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FeedItem, rhs: Server_FeedItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._shareStanzas != rhs_storage._shareStanzas {return false}
        if _storage._senderStateBundles != rhs_storage._senderStateBundles {return false}
        if _storage._senderState != rhs_storage._senderState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FeedItem.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLISH"),
    1: .same(proto: "RETRACT"),
    2: .same(proto: "SHARE"),
  ]
}

extension Server_FeedItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedItems"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FeedItems, rhs: Server_FeedItems) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SenderStateWithKeyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SenderStateWithKeyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "one_time_pre_key_id"),
    3: .standard(proto: "enc_sender_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encSenderState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 2)
    }
    if !self.encSenderState.isEmpty {
      try visitor.visitSingularBytesField(value: self.encSenderState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SenderStateWithKeyInfo, rhs: Server_SenderStateWithKeyInfo) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.encSenderState != rhs.encSenderState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SenderStateBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SenderStateBundle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_state"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._senderState) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SenderStateBundle, rhs: Server_SenderStateBundle) -> Bool {
    if lhs._senderState != rhs._senderState {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .same(proto: "post"),
    6: .same(proto: "comment"),
    7: .standard(proto: "sender_state_bundles"),
    8: .standard(proto: "sender_state"),
    9: .standard(proto: "audience_hash"),
    10: .standard(proto: "is_resent_history"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  fileprivate class _StorageClass {
    var _action: Server_GroupFeedItem.Action = .publish
    var _gid: String = String()
    var _name: String = String()
    var _avatarID: String = String()
    var _item: Server_GroupFeedItem.OneOf_Item?
    var _senderStateBundles: [Server_SenderStateBundle] = []
    var _senderState: Server_SenderStateWithKeyInfo? = nil
    var _audienceHash: Data = Data()
    var _isResentHistory: Bool = false
    var _senderLogInfo: String = String()
    var _senderClientVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _gid = source._gid
      _name = source._name
      _avatarID = source._avatarID
      _item = source._item
      _senderStateBundles = source._senderStateBundles
      _senderState = source._senderState
      _audienceHash = source._audienceHash
      _isResentHistory = source._isResentHistory
      _senderLogInfo = source._senderLogInfo
      _senderClientVersion = source._senderClientVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._gid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarID) }()
        case 5: try {
          var v: Server_Post?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .post(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .post(v)
          }
        }()
        case 6: try {
          var v: Server_Comment?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .comment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .comment(v)
          }
        }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._senderStateBundles) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._senderState) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._audienceHash) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isResentHistory) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._senderLogInfo) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._senderClientVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._action != .publish {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 1)
      }
      if !_storage._gid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gid, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._avatarID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarID, fieldNumber: 4)
      }
      switch _storage._item {
      case .post?: try {
        guard case .post(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .comment?: try {
        guard case .comment(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      if !_storage._senderStateBundles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._senderStateBundles, fieldNumber: 7)
      }
      try { if let v = _storage._senderState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._audienceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._audienceHash, fieldNumber: 9)
      }
      if _storage._isResentHistory != false {
        try visitor.visitSingularBoolField(value: _storage._isResentHistory, fieldNumber: 10)
      }
      if !_storage._senderLogInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderLogInfo, fieldNumber: 16)
      }
      if !_storage._senderClientVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderClientVersion, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedItem, rhs: Server_GroupFeedItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._gid != rhs_storage._gid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatarID != rhs_storage._avatarID {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._senderStateBundles != rhs_storage._senderStateBundles {return false}
        if _storage._senderState != rhs_storage._senderState {return false}
        if _storage._audienceHash != rhs_storage._audienceHash {return false}
        if _storage._isResentHistory != rhs_storage._isResentHistory {return false}
        if _storage._senderLogInfo != rhs_storage._senderLogInfo {return false}
        if _storage._senderClientVersion != rhs_storage._senderClientVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedItem.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLISH"),
    1: .same(proto: "RETRACT"),
    2: .same(proto: "SHARE"),
  ]
}

extension Server_GroupFeedItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedItems"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "name"),
    3: .standard(proto: "avatar_id"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedItems, rhs: Server_GroupFeedItems) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "id"),
    3: .same(proto: "payload"),
    4: .standard(proto: "enc_payload"),
    5: .standard(proto: "public_key"),
    6: .standard(proto: "one_time_pre_key_id"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.oneTimePreKeyID) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.senderLogInfo) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.senderClientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 5)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.oneTimePreKeyID, fieldNumber: 6)
    }
    if !self.senderLogInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.senderLogInfo, fieldNumber: 16)
    }
    if !self.senderClientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderClientVersion, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedHistory, rhs: Server_GroupFeedHistory) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.senderLogInfo != rhs.senderLogInfo {return false}
    if lhs.senderClientVersion != rhs.senderClientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMember"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
    3: .same(proto: "type"),
    4: .same(proto: "name"),
    5: .standard(proto: "avatar_id"),
    6: .same(proto: "result"),
    7: .same(proto: "reason"),
    8: .standard(proto: "identity_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    if self.type != .member {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 6)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 7)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupMember, rhs: Server_GroupMember) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupMember.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "REMOVE"),
    2: .same(proto: "PROMOTE"),
    3: .same(proto: "DEMOTE"),
    4: .same(proto: "LEAVE"),
    5: .same(proto: "JOIN"),
  ]
}

extension Server_GroupMember.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER"),
    1: .same(proto: "ADMIN"),
  ]
}

extension Server_GroupStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .standard(proto: "sender_uid"),
    6: .standard(proto: "sender_name"),
    7: .same(proto: "members"),
    8: .same(proto: "background"),
    9: .standard(proto: "audience_hash"),
    10: .same(proto: "description"),
    11: .standard(proto: "history_resend"),
  ]

  fileprivate class _StorageClass {
    var _action: Server_GroupStanza.Action = .set
    var _gid: String = String()
    var _name: String = String()
    var _avatarID: String = String()
    var _senderUid: Int64 = 0
    var _senderName: String = String()
    var _members: [Server_GroupMember] = []
    var _background: String = String()
    var _audienceHash: Data = Data()
    var _description_p: String = String()
    var _historyResend: Server_HistoryResend? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _gid = source._gid
      _name = source._name
      _avatarID = source._avatarID
      _senderUid = source._senderUid
      _senderName = source._senderName
      _members = source._members
      _background = source._background
      _audienceHash = source._audienceHash
      _description_p = source._description_p
      _historyResend = source._historyResend
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._gid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._senderUid) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._senderName) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._members) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._background) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._audienceHash) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._historyResend) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._action != .set {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 1)
      }
      if !_storage._gid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gid, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._avatarID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarID, fieldNumber: 4)
      }
      if _storage._senderUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._senderUid, fieldNumber: 5)
      }
      if !_storage._senderName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderName, fieldNumber: 6)
      }
      if !_storage._members.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._members, fieldNumber: 7)
      }
      if !_storage._background.isEmpty {
        try visitor.visitSingularStringField(value: _storage._background, fieldNumber: 8)
      }
      if !_storage._audienceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._audienceHash, fieldNumber: 9)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 10)
      }
      try { if let v = _storage._historyResend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupStanza, rhs: Server_GroupStanza) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._gid != rhs_storage._gid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatarID != rhs_storage._avatarID {return false}
        if _storage._senderUid != rhs_storage._senderUid {return false}
        if _storage._senderName != rhs_storage._senderName {return false}
        if _storage._members != rhs_storage._members {return false}
        if _storage._background != rhs_storage._background {return false}
        if _storage._audienceHash != rhs_storage._audienceHash {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._historyResend != rhs_storage._historyResend {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupStanza.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET"),
    1: .same(proto: "GET"),
    2: .same(proto: "CREATE"),
    3: .same(proto: "DELETE"),
    4: .same(proto: "LEAVE"),
    5: .same(proto: "CHANGE_AVATAR"),
    6: .same(proto: "CHANGE_NAME"),
    7: .same(proto: "MODIFY_ADMINS"),
    8: .same(proto: "MODIFY_MEMBERS"),
    9: .same(proto: "AUTO_PROMOTE_ADMINS"),
    10: .same(proto: "SET_NAME"),
    11: .same(proto: "JOIN"),
    12: .same(proto: "PREVIEW"),
    13: .same(proto: "SET_BACKGROUND"),
    14: .same(proto: "GET_MEMBER_IDENTITY_KEYS"),
    15: .same(proto: "CHANGE_DESCRIPTION"),
    16: .same(proto: "SHARE_HISTORY"),
  ]
}

extension Server_GroupChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "name"),
    3: .standard(proto: "avatar_id"),
    4: .standard(proto: "sender_uid"),
    5: .standard(proto: "sender_name"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.senderUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.senderName) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 3)
    }
    if self.senderUid != 0 {
      try visitor.visitSingularInt64Field(value: self.senderUid, fieldNumber: 4)
    }
    if !self.senderName.isEmpty {
      try visitor.visitSingularStringField(value: self.senderName, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupChat, rhs: Server_GroupChat) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.senderUid != rhs.senderUid {return false}
    if lhs.senderName != rhs.senderName {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupsStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupsStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "group_stanzas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groupStanzas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .get {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.groupStanzas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupStanzas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupsStanza, rhs: Server_GroupsStanza) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.groupStanzas != rhs.groupStanzas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupsStanza.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
  ]
}

extension Server_GroupInviteLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInviteLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "link"),
    4: .same(proto: "result"),
    5: .same(proto: "reason"),
    6: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.link) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 2)
    }
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 3)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 4)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 5)
    }
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupInviteLink, rhs: Server_GroupInviteLink) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.link != rhs.link {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupInviteLink.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GET"),
    2: .same(proto: "RESET"),
    3: .same(proto: "JOIN"),
    4: .same(proto: "PREVIEW"),
  ]
}

extension Server_AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "pwd"),
    3: .standard(proto: "client_mode"),
    4: .standard(proto: "client_version"),
    5: .same(proto: "resource"),
    6: .standard(proto: "device_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pwd) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientMode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deviceInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.pwd.isEmpty {
      try visitor.visitSingularStringField(value: self.pwd, fieldNumber: 2)
    }
    try { if let v = self._clientMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._clientVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 5)
    }
    try { if let v = self._deviceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AuthRequest, rhs: Server_AuthRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.pwd != rhs.pwd {return false}
    if lhs._clientMode != rhs._clientMode {return false}
    if lhs._clientVersion != rhs._clientVersion {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs._deviceInfo != rhs._deviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AuthResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_string"),
    2: .standard(proto: "reason_string"),
    3: .standard(proto: "props_hash"),
    4: .standard(proto: "version_ttl"),
    5: .same(proto: "result"),
    6: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reasonString) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.propsHash) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.versionTtl) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 1)
    }
    if !self.reasonString.isEmpty {
      try visitor.visitSingularStringField(value: self.reasonString, fieldNumber: 2)
    }
    if !self.propsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.propsHash, fieldNumber: 3)
    }
    if self.versionTtl != 0 {
      try visitor.visitSingularInt64Field(value: self.versionTtl, fieldNumber: 4)
    }
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 5)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AuthResult, rhs: Server_AuthResult) -> Bool {
    if lhs.resultString != rhs.resultString {return false}
    if lhs.reasonString != rhs.reasonString {return false}
    if lhs.propsHash != rhs.propsHash {return false}
    if lhs.versionTtl != rhs.versionTtl {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AuthResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_AuthResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "OK"),
    2: .same(proto: "SPUB_MISMATCH"),
    3: .same(proto: "INVALID_CLIENT_VERSION"),
    4: .same(proto: "INVALID_RESOURCE"),
    5: .same(proto: "ACCOUNT_DELETED"),
    6: .same(proto: "INVALID_UID_OR_PASSWORD"),
  ]
}

extension Server_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Invite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "result"),
    3: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Invite, rhs: Server_Invite) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InvitesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InvitesRequest, rhs: Server_InvitesRequest) -> Bool {
    if lhs.invites != rhs.invites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InvitesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invites_left"),
    2: .standard(proto: "time_until_refresh"),
    3: .same(proto: "invites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.invitesLeft) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeUntilRefresh) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.invites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invitesLeft != 0 {
      try visitor.visitSingularInt32Field(value: self.invitesLeft, fieldNumber: 1)
    }
    if self.timeUntilRefresh != 0 {
      try visitor.visitSingularInt64Field(value: self.timeUntilRefresh, fieldNumber: 2)
    }
    if !self.invites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invites, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InvitesResponse, rhs: Server_InvitesResponse) -> Bool {
    if lhs.invitesLeft != rhs.invitesLeft {return false}
    if lhs.timeUntilRefresh != rhs.timeUntilRefresh {return false}
    if lhs.invites != rhs.invites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaUrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "get"),
    2: .same(proto: "put"),
    3: .same(proto: "patch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.get) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.put) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.patch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.get.isEmpty {
      try visitor.visitSingularStringField(value: self.get, fieldNumber: 1)
    }
    if !self.put.isEmpty {
      try visitor.visitSingularStringField(value: self.put, fieldNumber: 2)
    }
    if !self.patch.isEmpty {
      try visitor.visitSingularStringField(value: self.patch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaUrl, rhs: Server_MediaUrl) -> Bool {
    if lhs.get != rhs.get {return false}
    if lhs.put != rhs.put {return false}
    if lhs.patch != rhs.patch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "url"),
    3: .standard(proto: "download_url"),
    4: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 1)
    }
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 3)
    }
    if self.type != .default {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadMedia, rhs: Server_UploadMedia) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs._url != rhs._url {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadMedia.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "RESUMABLE"),
    2: .same(proto: "DIRECT"),
  ]
}

extension Server_ChatStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "payload"),
    3: .standard(proto: "enc_payload"),
    4: .standard(proto: "public_key"),
    5: .standard(proto: "one_time_pre_key_id"),
    6: .standard(proto: "sender_name"),
    7: .standard(proto: "sender_phone"),
    8: .standard(proto: "media_counters"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.senderName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.senderPhone) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._mediaCounters) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.senderLogInfo) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.senderClientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 3)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 4)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 5)
    }
    if !self.senderName.isEmpty {
      try visitor.visitSingularStringField(value: self.senderName, fieldNumber: 6)
    }
    if !self.senderPhone.isEmpty {
      try visitor.visitSingularStringField(value: self.senderPhone, fieldNumber: 7)
    }
    try { if let v = self._mediaCounters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.senderLogInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.senderLogInfo, fieldNumber: 16)
    }
    if !self.senderClientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderClientVersion, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatStanza, rhs: Server_ChatStanza) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.senderName != rhs.senderName {return false}
    if lhs.senderPhone != rhs.senderPhone {return false}
    if lhs._mediaCounters != rhs._mediaCounters {return false}
    if lhs.senderLogInfo != rhs.senderLogInfo {return false}
    if lhs.senderClientVersion != rhs.senderClientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SilentChatStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SilentChatStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_stanza"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatStanza) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatStanza {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SilentChatStanza, rhs: Server_SilentChatStanza) -> Bool {
    if lhs._chatStanza != rhs._chatStanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Ping, rhs: Server_Ping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ErrorStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ErrorStanza, rhs: Server_ErrorStanza) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Name, rhs: Server_Name) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_EndOfQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndOfQueue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trimmed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.trimmed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.trimmed != false {
      try visitor.visitSingularBoolField(value: self.trimmed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EndOfQueue, rhs: Server_EndOfQueue) -> Bool {
    if lhs.trimmed != rhs.trimmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HistoryResend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryResend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "id"),
    4: .same(proto: "payload"),
    5: .standard(proto: "enc_payload"),
    6: .standard(proto: "sender_state_bundles"),
    7: .standard(proto: "sender_state"),
    8: .standard(proto: "audience_hash"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.senderStateBundles) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._senderState) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.audienceHash) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.senderLogInfo) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.senderClientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 4)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 5)
    }
    if !self.senderStateBundles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.senderStateBundles, fieldNumber: 6)
    }
    try { if let v = self._senderState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.audienceHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.audienceHash, fieldNumber: 8)
    }
    if !self.senderLogInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.senderLogInfo, fieldNumber: 16)
    }
    if !self.senderClientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderClientVersion, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HistoryResend, rhs: Server_HistoryResend) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.senderStateBundles != rhs.senderStateBundles {return false}
    if lhs._senderState != rhs._senderState {return false}
    if lhs.audienceHash != rhs.audienceHash {return false}
    if lhs.senderLogInfo != rhs.senderLogInfo {return false}
    if lhs.senderClientVersion != rhs.senderClientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StunServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StunServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_StunServer, rhs: Server_StunServer) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_TurnServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "port"),
    3: .same(proto: "username"),
    4: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TurnServer, rhs: Server_TurnServer) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCallServers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCallServers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "peer_uid"),
    3: .standard(proto: "call_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.peerUid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.callType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.peerUid != 0 {
      try visitor.visitSingularInt64Field(value: self.peerUid, fieldNumber: 2)
    }
    if self.callType != .unknownType {
      try visitor.visitSingularEnumField(value: self.callType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetCallServers, rhs: Server_GetCallServers) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.peerUid != rhs.peerUid {return false}
    if lhs.callType != rhs.callType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCallServersResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCallServersResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "stun_servers"),
    3: .standard(proto: "turn_servers"),
    4: .standard(proto: "call_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stunServers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.turnServers) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._callConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.stunServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stunServers, fieldNumber: 2)
    }
    if !self.turnServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.turnServers, fieldNumber: 3)
    }
    try { if let v = self._callConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetCallServersResult, rhs: Server_GetCallServersResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.stunServers != rhs.stunServers {return false}
    if lhs.turnServers != rhs.turnServers {return false}
    if lhs._callConfig != rhs._callConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCallServersResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_CallCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_answer"),
    2: .standard(proto: "sdp_restart"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.preAnswer) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.sdpRestart) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.preAnswer != false {
      try visitor.visitSingularBoolField(value: self.preAnswer, fieldNumber: 1)
    }
    if self.sdpRestart != false {
      try visitor.visitSingularBoolField(value: self.sdpRestart, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallCapabilities, rhs: Server_CallCapabilities) -> Bool {
    if lhs.preAnswer != rhs.preAnswer {return false}
    if lhs.sdpRestart != rhs.sdpRestart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StartCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "peer_uid"),
    3: .standard(proto: "call_type"),
    4: .standard(proto: "webrtc_offer"),
    5: .standard(proto: "rerequest_count"),
    6: .standard(proto: "call_capabilities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.peerUid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.callType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._webrtcOffer) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.rerequestCount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._callCapabilities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.peerUid != 0 {
      try visitor.visitSingularInt64Field(value: self.peerUid, fieldNumber: 2)
    }
    if self.callType != .unknownType {
      try visitor.visitSingularEnumField(value: self.callType, fieldNumber: 3)
    }
    try { if let v = self._webrtcOffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.rerequestCount != 0 {
      try visitor.visitSingularInt32Field(value: self.rerequestCount, fieldNumber: 5)
    }
    try { if let v = self._callCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_StartCall, rhs: Server_StartCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.peerUid != rhs.peerUid {return false}
    if lhs.callType != rhs.callType {return false}
    if lhs._webrtcOffer != rhs._webrtcOffer {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs._callCapabilities != rhs._callCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StartCallResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartCallResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "stun_servers"),
    3: .standard(proto: "turn_servers"),
    4: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stunServers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.turnServers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.stunServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stunServers, fieldNumber: 2)
    }
    if !self.turnServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.turnServers, fieldNumber: 3)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_StartCallResult, rhs: Server_StartCallResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.stunServers != rhs.stunServers {return false}
    if lhs.turnServers != rhs.turnServers {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StartCallResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_WebRtcSessionDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebRtcSessionDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enc_payload"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "one_time_pre_key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.oneTimePreKeyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.oneTimePreKeyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WebRtcSessionDescription, rhs: Server_WebRtcSessionDescription) -> Bool {
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IncomingCallPush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingCallPush"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "call_type"),
    3: .standard(proto: "stun_servers"),
    4: .standard(proto: "turn_servers"),
    5: .standard(proto: "timestamp_ms"),
    6: .standard(proto: "call_config"),
    7: .standard(proto: "call_capabilities"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _callType: Server_CallType = .unknownType
    var _stunServers: [Server_StunServer] = []
    var _turnServers: [Server_TurnServer] = []
    var _timestampMs: Int64 = 0
    var _callConfig: Server_CallConfig? = nil
    var _callCapabilities: Server_CallCapabilities? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _callType = source._callType
      _stunServers = source._stunServers
      _turnServers = source._turnServers
      _timestampMs = source._timestampMs
      _callConfig = source._callConfig
      _callCapabilities = source._callCapabilities
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._callID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._callType) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._stunServers) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._turnServers) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._timestampMs) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._callConfig) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._callCapabilities) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if _storage._callType != .unknownType {
        try visitor.visitSingularEnumField(value: _storage._callType, fieldNumber: 2)
      }
      if !_storage._stunServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stunServers, fieldNumber: 3)
      }
      if !_storage._turnServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._turnServers, fieldNumber: 4)
      }
      if _storage._timestampMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestampMs, fieldNumber: 5)
      }
      try { if let v = _storage._callConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._callCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IncomingCallPush, rhs: Server_IncomingCallPush) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._callType != rhs_storage._callType {return false}
        if _storage._stunServers != rhs_storage._stunServers {return false}
        if _storage._turnServers != rhs_storage._turnServers {return false}
        if _storage._timestampMs != rhs_storage._timestampMs {return false}
        if _storage._callConfig != rhs_storage._callConfig {return false}
        if _storage._callCapabilities != rhs_storage._callCapabilities {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IncomingCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "call_type"),
    3: .standard(proto: "webrtc_offer"),
    4: .standard(proto: "stun_servers"),
    5: .standard(proto: "turn_servers"),
    6: .standard(proto: "timestamp_ms"),
    7: .standard(proto: "server_sent_ts_ms"),
    8: .standard(proto: "call_config"),
    9: .standard(proto: "call_capabilities"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _callType: Server_CallType = .unknownType
    var _webrtcOffer: Server_WebRtcSessionDescription? = nil
    var _stunServers: [Server_StunServer] = []
    var _turnServers: [Server_TurnServer] = []
    var _timestampMs: Int64 = 0
    var _serverSentTsMs: Int64 = 0
    var _callConfig: Server_CallConfig? = nil
    var _callCapabilities: Server_CallCapabilities? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _callType = source._callType
      _webrtcOffer = source._webrtcOffer
      _stunServers = source._stunServers
      _turnServers = source._turnServers
      _timestampMs = source._timestampMs
      _serverSentTsMs = source._serverSentTsMs
      _callConfig = source._callConfig
      _callCapabilities = source._callCapabilities
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._callID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._callType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._webrtcOffer) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._stunServers) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._turnServers) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._timestampMs) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._serverSentTsMs) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._callConfig) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._callCapabilities) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if _storage._callType != .unknownType {
        try visitor.visitSingularEnumField(value: _storage._callType, fieldNumber: 2)
      }
      try { if let v = _storage._webrtcOffer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stunServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stunServers, fieldNumber: 4)
      }
      if !_storage._turnServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._turnServers, fieldNumber: 5)
      }
      if _storage._timestampMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestampMs, fieldNumber: 6)
      }
      if _storage._serverSentTsMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._serverSentTsMs, fieldNumber: 7)
      }
      try { if let v = _storage._callConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._callCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IncomingCall, rhs: Server_IncomingCall) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._callType != rhs_storage._callType {return false}
        if _storage._webrtcOffer != rhs_storage._webrtcOffer {return false}
        if _storage._stunServers != rhs_storage._stunServers {return false}
        if _storage._turnServers != rhs_storage._turnServers {return false}
        if _storage._timestampMs != rhs_storage._timestampMs {return false}
        if _storage._serverSentTsMs != rhs_storage._serverSentTsMs {return false}
        if _storage._callConfig != rhs_storage._callConfig {return false}
        if _storage._callCapabilities != rhs_storage._callCapabilities {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IceCandidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceCandidate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "sdp_media_id"),
    3: .standard(proto: "sdp_media_line_index"),
    4: .same(proto: "sdp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sdpMediaID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sdpMediaLineIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if !self.sdpMediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.sdpMediaID, fieldNumber: 2)
    }
    if self.sdpMediaLineIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.sdpMediaLineIndex, fieldNumber: 3)
    }
    if !self.sdp.isEmpty {
      try visitor.visitSingularStringField(value: self.sdp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IceCandidate, rhs: Server_IceCandidate) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.sdpMediaID != rhs.sdpMediaID {return false}
    if lhs.sdpMediaLineIndex != rhs.sdpMediaLineIndex {return false}
    if lhs.sdp != rhs.sdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CallRinging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallRinging"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "timestamp_ms"),
    3: .standard(proto: "webrtc_answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 2)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallRinging, rhs: Server_CallRinging) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PreAnswerCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreAnswerCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "webrtc_answer"),
    3: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PreAnswerCall, rhs: Server_PreAnswerCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AnswerCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnswerCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "webrtc_answer"),
    3: .standard(proto: "timestamp_ms"),
    4: .standard(proto: "webrtc_offer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._webrtcOffer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try { if let v = self._webrtcOffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AnswerCall, rhs: Server_AnswerCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs._webrtcOffer != rhs._webrtcOffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CallSdp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallSdp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "webrtc_offer"),
    3: .standard(proto: "webrtc_answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try {
        var v: Server_WebRtcSessionDescription?
        var hadOneofValue = false
        if let current = self.sdp {
          hadOneofValue = true
          if case .webrtcOffer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sdp = .webrtcOffer(v)
        }
      }()
      case 3: try {
        var v: Server_WebRtcSessionDescription?
        var hadOneofValue = false
        if let current = self.sdp {
          hadOneofValue = true
          if case .webrtcAnswer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sdp = .webrtcAnswer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    switch self.sdp {
    case .webrtcOffer?: try {
      guard case .webrtcOffer(let v)? = self.sdp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .webrtcAnswer?: try {
      guard case .webrtcAnswer(let v)? = self.sdp else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallSdp, rhs: Server_CallSdp) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.sdp != rhs.sdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_EndCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "reason"),
    3: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EndCall, rhs: Server_EndCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_EndCall.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REJECT"),
    2: .same(proto: "BUSY"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "CALL_END"),
    5: .same(proto: "CANCEL"),
    6: .same(proto: "DECRYPTION_FAILED"),
    7: .same(proto: "ENCRYPTION_FAILED"),
    8: .same(proto: "SYSTEM_ERROR"),
    9: .same(proto: "VIDEO_UNSUPPORTED"),
    10: .same(proto: "CONNECTION_ERROR"),
  ]
}

extension Server_IceRestartOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceRestartOffer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "idx"),
    3: .standard(proto: "webrtc_offer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.idx) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._webrtcOffer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.idx != 0 {
      try visitor.visitSingularInt32Field(value: self.idx, fieldNumber: 2)
    }
    try { if let v = self._webrtcOffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IceRestartOffer, rhs: Server_IceRestartOffer) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.idx != rhs.idx {return false}
    if lhs._webrtcOffer != rhs._webrtcOffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IceRestartAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceRestartAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "idx"),
    3: .standard(proto: "webrtc_answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.idx) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.idx != 0 {
      try visitor.visitSingularInt32Field(value: self.idx, fieldNumber: 2)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IceRestartAnswer, rhs: Server_IceRestartAnswer) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.idx != rhs.idx {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HoldCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoldCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "hold"),
    3: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hold) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.hold != false {
      try visitor.visitSingularBoolField(value: self.hold, fieldNumber: 2)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HoldCall, rhs: Server_HoldCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.hold != rhs.hold {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MuteCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MuteCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "media_type"),
    3: .same(proto: "muted"),
    4: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mediaType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.muted) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.mediaType != .audio {
      try visitor.visitSingularEnumField(value: self.mediaType, fieldNumber: 2)
    }
    if self.muted != false {
      try visitor.visitSingularBoolField(value: self.muted, fieldNumber: 3)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MuteCall, rhs: Server_MuteCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.muted != rhs.muted {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MuteCall.MediaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO"),
    1: .same(proto: "VIDEO"),
  ]
}

extension Server_CallConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_bitrate_max"),
    2: .standard(proto: "video_bitrate_max"),
    3: .standard(proto: "audio_codec"),
    4: .standard(proto: "video_codec"),
    5: .standard(proto: "video_width"),
    6: .standard(proto: "video_height"),
    7: .standard(proto: "video_fps"),
    8: .standard(proto: "audio_jitter_buffer_max_packets"),
    9: .standard(proto: "audio_jitter_buffer_fast_accelerate"),
    10: .standard(proto: "ice_transport_policy"),
    11: .standard(proto: "ice_restart_delay_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.audioBitrateMax) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.videoBitrateMax) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.audioCodec) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.videoCodec) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.videoWidth) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.videoHeight) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.videoFps) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.audioJitterBufferMaxPackets) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.audioJitterBufferFastAccelerate) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.iceTransportPolicy) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.iceRestartDelayMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audioBitrateMax != 0 {
      try visitor.visitSingularInt32Field(value: self.audioBitrateMax, fieldNumber: 1)
    }
    if self.videoBitrateMax != 0 {
      try visitor.visitSingularInt32Field(value: self.videoBitrateMax, fieldNumber: 2)
    }
    if self.audioCodec != 0 {
      try visitor.visitSingularInt32Field(value: self.audioCodec, fieldNumber: 3)
    }
    if self.videoCodec != 0 {
      try visitor.visitSingularInt32Field(value: self.videoCodec, fieldNumber: 4)
    }
    if self.videoWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.videoWidth, fieldNumber: 5)
    }
    if self.videoHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.videoHeight, fieldNumber: 6)
    }
    if self.videoFps != 0 {
      try visitor.visitSingularInt32Field(value: self.videoFps, fieldNumber: 7)
    }
    if self.audioJitterBufferMaxPackets != 0 {
      try visitor.visitSingularInt32Field(value: self.audioJitterBufferMaxPackets, fieldNumber: 8)
    }
    if self.audioJitterBufferFastAccelerate != false {
      try visitor.visitSingularBoolField(value: self.audioJitterBufferFastAccelerate, fieldNumber: 9)
    }
    if self.iceTransportPolicy != .all {
      try visitor.visitSingularEnumField(value: self.iceTransportPolicy, fieldNumber: 10)
    }
    if self.iceRestartDelayMs != 0 {
      try visitor.visitSingularInt32Field(value: self.iceRestartDelayMs, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallConfig, rhs: Server_CallConfig) -> Bool {
    if lhs.audioBitrateMax != rhs.audioBitrateMax {return false}
    if lhs.videoBitrateMax != rhs.videoBitrateMax {return false}
    if lhs.audioCodec != rhs.audioCodec {return false}
    if lhs.videoCodec != rhs.videoCodec {return false}
    if lhs.videoWidth != rhs.videoWidth {return false}
    if lhs.videoHeight != rhs.videoHeight {return false}
    if lhs.videoFps != rhs.videoFps {return false}
    if lhs.audioJitterBufferMaxPackets != rhs.audioJitterBufferMaxPackets {return false}
    if lhs.audioJitterBufferFastAccelerate != rhs.audioJitterBufferFastAccelerate {return false}
    if lhs.iceTransportPolicy != rhs.iceTransportPolicy {return false}
    if lhs.iceRestartDelayMs != rhs.iceRestartDelayMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CallConfig.IceTransportPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "RELAY"),
  ]
}

extension Server_OgTagInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OgTagInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "thumbnail_url"),
    4: .standard(proto: "thumbnail_width"),
    5: .standard(proto: "thumbnail_height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailURL) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.thumbnailWidth) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.thumbnailHeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.thumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailURL, fieldNumber: 3)
    }
    if self.thumbnailWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.thumbnailWidth, fieldNumber: 4)
    }
    if self.thumbnailHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.thumbnailHeight, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_OgTagInfo, rhs: Server_OgTagInfo) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.thumbnailURL != rhs.thumbnailURL {return false}
    if lhs.thumbnailWidth != rhs.thumbnailWidth {return false}
    if lhs.thumbnailHeight != rhs.thumbnailHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ExternalSharePost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalSharePost"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "blob_id"),
    3: .same(proto: "blob"),
    4: .standard(proto: "expires_in_seconds"),
    5: .standard(proto: "og_tag_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blobID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blob) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expiresInSeconds) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ogTagInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .store {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.blobID.isEmpty {
      try visitor.visitSingularStringField(value: self.blobID, fieldNumber: 2)
    }
    if !self.blob.isEmpty {
      try visitor.visitSingularBytesField(value: self.blob, fieldNumber: 3)
    }
    if self.expiresInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresInSeconds, fieldNumber: 4)
    }
    try { if let v = self._ogTagInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ExternalSharePost, rhs: Server_ExternalSharePost) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.blobID != rhs.blobID {return false}
    if lhs.blob != rhs.blob {return false}
    if lhs.expiresInSeconds != rhs.expiresInSeconds {return false}
    if lhs._ogTagInfo != rhs._ogTagInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ExternalSharePost.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE"),
    1: .same(proto: "DELETE"),
    2: .same(proto: "GET"),
  ]
}

extension Server_ExternalSharePostContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalSharePostContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "blob"),
    3: .standard(proto: "og_tag_info"),
    4: .same(proto: "name"),
    5: .standard(proto: "avatar_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blob) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ogTagInfo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.blob.isEmpty {
      try visitor.visitSingularBytesField(value: self.blob, fieldNumber: 2)
    }
    try { if let v = self._ogTagInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ExternalSharePostContainer, rhs: Server_ExternalSharePostContainer) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.blob != rhs.blob {return false}
    if lhs._ogTagInfo != rhs._ogTagInfo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WebClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebClientInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "static_key"),
    3: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.staticKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .unknownAction {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.staticKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.staticKey, fieldNumber: 2)
    }
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WebClientInfo, rhs: Server_WebClientInfo) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.staticKey != rhs.staticKey {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WebClientInfo.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTION"),
    1: .same(proto: "ADD_KEY"),
    2: .same(proto: "IS_KEY_AUTHENTICATED"),
    3: .same(proto: "AUTHENTICATE_KEY"),
    4: .same(proto: "REMOVE_KEY"),
  ]
}

extension Server_WebClientInfo.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "AUTHENTICATED"),
    3: .same(proto: "NOT_AUTHENTICATED"),
  ]
}

extension Server_WebStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "static_key"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.staticKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.staticKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.staticKey, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WebStanza, rhs: Server_WebStanza) -> Bool {
    if lhs.staticKey != rhs.staticKey {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Iq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Iq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "upload_media"),
    4: .standard(proto: "contact_list"),
    5: .standard(proto: "upload_avatar"),
    6: .same(proto: "avatar"),
    7: .same(proto: "avatars"),
    8: .standard(proto: "client_mode"),
    9: .standard(proto: "client_version"),
    10: .standard(proto: "push_register"),
    11: .standard(proto: "whisper_keys"),
    12: .same(proto: "ping"),
    13: .standard(proto: "feed_item"),
    14: .standard(proto: "privacy_list"),
    16: .standard(proto: "privacy_lists"),
    17: .standard(proto: "group_stanza"),
    18: .standard(proto: "groups_stanza"),
    19: .standard(proto: "client_log"),
    20: .same(proto: "name"),
    21: .standard(proto: "error_stanza"),
    22: .same(proto: "props"),
    23: .standard(proto: "invites_request"),
    24: .standard(proto: "invites_response"),
    25: .standard(proto: "notification_prefs"),
    26: .standard(proto: "group_feed_item"),
    27: .standard(proto: "group_avatar"),
    28: .standard(proto: "delete_account"),
    31: .standard(proto: "group_invite_link"),
    32: .standard(proto: "history_resend"),
    33: .standard(proto: "export_data"),
    34: .standard(proto: "contact_sync_error"),
    35: .standard(proto: "client_otp_request"),
    36: .standard(proto: "client_otp_response"),
    37: .standard(proto: "whisper_keys_collection"),
    38: .standard(proto: "get_call_servers"),
    39: .standard(proto: "get_call_servers_result"),
    40: .standard(proto: "start_call"),
    41: .standard(proto: "start_call_result"),
    42: .standard(proto: "trunc_whisper_keys_collection"),
    43: .standard(proto: "external_share_post"),
    44: .standard(proto: "external_share_post_container"),
    45: .standard(proto: "web_client_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try {
        var v: Server_UploadMedia?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .uploadMedia(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .uploadMedia(v)
        }
      }()
      case 4: try {
        var v: Server_ContactList?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .contactList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .contactList(v)
        }
      }()
      case 5: try {
        var v: Server_UploadAvatar?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .uploadAvatar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .uploadAvatar(v)
        }
      }()
      case 6: try {
        var v: Server_Avatar?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .avatar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .avatar(v)
        }
      }()
      case 7: try {
        var v: Server_Avatars?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .avatars(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .avatars(v)
        }
      }()
      case 8: try {
        var v: Server_ClientMode?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clientMode(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clientMode(v)
        }
      }()
      case 9: try {
        var v: Server_ClientVersion?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clientVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clientVersion(v)
        }
      }()
      case 10: try {
        var v: Server_PushRegister?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .pushRegister(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .pushRegister(v)
        }
      }()
      case 11: try {
        var v: Server_WhisperKeys?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .whisperKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .whisperKeys(v)
        }
      }()
      case 12: try {
        var v: Server_Ping?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .ping(v)
        }
      }()
      case 13: try {
        var v: Server_FeedItem?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .feedItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .feedItem(v)
        }
      }()
      case 14: try {
        var v: Server_PrivacyList?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .privacyList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .privacyList(v)
        }
      }()
      case 16: try {
        var v: Server_PrivacyLists?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .privacyLists(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .privacyLists(v)
        }
      }()
      case 17: try {
        var v: Server_GroupStanza?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupStanza(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupStanza(v)
        }
      }()
      case 18: try {
        var v: Server_GroupsStanza?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupsStanza(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupsStanza(v)
        }
      }()
      case 19: try {
        var v: Server_ClientLog?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clientLog(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clientLog(v)
        }
      }()
      case 20: try {
        var v: Server_Name?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .name(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .name(v)
        }
      }()
      case 21: try {
        var v: Server_ErrorStanza?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .errorStanza(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .errorStanza(v)
        }
      }()
      case 22: try {
        var v: Server_Props?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .props(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .props(v)
        }
      }()
      case 23: try {
        var v: Server_InvitesRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .invitesRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .invitesRequest(v)
        }
      }()
      case 24: try {
        var v: Server_InvitesResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .invitesResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .invitesResponse(v)
        }
      }()
      case 25: try {
        var v: Server_NotificationPrefs?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .notificationPrefs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .notificationPrefs(v)
        }
      }()
      case 26: try {
        var v: Server_GroupFeedItem?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupFeedItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupFeedItem(v)
        }
      }()
      case 27: try {
        var v: Server_UploadGroupAvatar?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupAvatar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupAvatar(v)
        }
      }()
      case 28: try {
        var v: Server_DeleteAccount?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deleteAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deleteAccount(v)
        }
      }()
      case 31: try {
        var v: Server_GroupInviteLink?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .groupInviteLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .groupInviteLink(v)
        }
      }()
      case 32: try {
        var v: Server_HistoryResend?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .historyResend(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .historyResend(v)
        }
      }()
      case 33: try {
        var v: Server_ExportData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .exportData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .exportData(v)
        }
      }()
      case 34: try {
        var v: Server_ContactSyncError?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .contactSyncError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .contactSyncError(v)
        }
      }()
      case 35: try {
        var v: Server_ClientOtpRequest?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clientOtpRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clientOtpRequest(v)
        }
      }()
      case 36: try {
        var v: Server_ClientOtpResponse?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .clientOtpResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .clientOtpResponse(v)
        }
      }()
      case 37: try {
        var v: Server_WhisperKeysCollection?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .whisperKeysCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .whisperKeysCollection(v)
        }
      }()
      case 38: try {
        var v: Server_GetCallServers?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getCallServers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getCallServers(v)
        }
      }()
      case 39: try {
        var v: Server_GetCallServersResult?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .getCallServersResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .getCallServersResult(v)
        }
      }()
      case 40: try {
        var v: Server_StartCall?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .startCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .startCall(v)
        }
      }()
      case 41: try {
        var v: Server_StartCallResult?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .startCallResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .startCallResult(v)
        }
      }()
      case 42: try {
        var v: Server_TruncWhisperKeysCollection?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .truncWhisperKeysCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .truncWhisperKeysCollection(v)
        }
      }()
      case 43: try {
        var v: Server_ExternalSharePost?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .externalSharePost(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .externalSharePost(v)
        }
      }()
      case 44: try {
        var v: Server_ExternalSharePostContainer?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .externalSharePostContainer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .externalSharePostContainer(v)
        }
      }()
      case 45: try {
        var v: Server_WebClientInfo?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .webClientInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .webClientInfo(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .get {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    switch self.payload {
    case .uploadMedia?: try {
      guard case .uploadMedia(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .contactList?: try {
      guard case .contactList(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .uploadAvatar?: try {
      guard case .uploadAvatar(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .avatar?: try {
      guard case .avatar(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .avatars?: try {
      guard case .avatars(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .clientMode?: try {
      guard case .clientMode(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .clientVersion?: try {
      guard case .clientVersion(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .pushRegister?: try {
      guard case .pushRegister(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .whisperKeys?: try {
      guard case .whisperKeys(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .ping?: try {
      guard case .ping(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .feedItem?: try {
      guard case .feedItem(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .privacyList?: try {
      guard case .privacyList(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .privacyLists?: try {
      guard case .privacyLists(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .groupStanza?: try {
      guard case .groupStanza(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .groupsStanza?: try {
      guard case .groupsStanza(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .clientLog?: try {
      guard case .clientLog(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .name?: try {
      guard case .name(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .errorStanza?: try {
      guard case .errorStanza(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .props?: try {
      guard case .props(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .invitesRequest?: try {
      guard case .invitesRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .invitesResponse?: try {
      guard case .invitesResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .notificationPrefs?: try {
      guard case .notificationPrefs(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .groupFeedItem?: try {
      guard case .groupFeedItem(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .groupAvatar?: try {
      guard case .groupAvatar(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .deleteAccount?: try {
      guard case .deleteAccount(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .groupInviteLink?: try {
      guard case .groupInviteLink(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .historyResend?: try {
      guard case .historyResend(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case .exportData?: try {
      guard case .exportData(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
    }()
    case .contactSyncError?: try {
      guard case .contactSyncError(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
    }()
    case .clientOtpRequest?: try {
      guard case .clientOtpRequest(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
    }()
    case .clientOtpResponse?: try {
      guard case .clientOtpResponse(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    }()
    case .whisperKeysCollection?: try {
      guard case .whisperKeysCollection(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
    }()
    case .getCallServers?: try {
      guard case .getCallServers(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
    }()
    case .getCallServersResult?: try {
      guard case .getCallServersResult(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
    }()
    case .startCall?: try {
      guard case .startCall(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
    }()
    case .startCallResult?: try {
      guard case .startCallResult(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
    }()
    case .truncWhisperKeysCollection?: try {
      guard case .truncWhisperKeysCollection(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
    }()
    case .externalSharePost?: try {
      guard case .externalSharePost(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
    }()
    case .externalSharePostContainer?: try {
      guard case .externalSharePostContainer(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
    }()
    case .webClientInfo?: try {
      guard case .webClientInfo(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Iq, rhs: Server_Iq) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Iq.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "SET"),
    2: .same(proto: "RESULT"),
    3: .same(proto: "ERROR"),
  ]
}

extension Server_Msg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Msg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "to_uid"),
    4: .standard(proto: "from_uid"),
    5: .standard(proto: "contact_list"),
    6: .same(proto: "avatar"),
    7: .standard(proto: "whisper_keys"),
    8: .standard(proto: "seen_receipt"),
    9: .standard(proto: "delivery_receipt"),
    10: .standard(proto: "chat_stanza"),
    11: .standard(proto: "feed_item"),
    12: .standard(proto: "feed_items"),
    13: .standard(proto: "contact_hash"),
    14: .standard(proto: "group_stanza"),
    15: .standard(proto: "group_chat"),
    16: .same(proto: "name"),
    17: .standard(proto: "error_stanza"),
    18: .standard(proto: "groupchat_retract"),
    19: .standard(proto: "chat_retract"),
    20: .standard(proto: "group_feed_item"),
    22: .same(proto: "rerequest"),
    23: .standard(proto: "silent_chat_stanza"),
    24: .standard(proto: "group_feed_items"),
    26: .standard(proto: "end_of_queue"),
    27: .standard(proto: "invitee_notice"),
    28: .standard(proto: "group_feed_rerequest"),
    29: .standard(proto: "history_resend"),
    30: .standard(proto: "played_receipt"),
    31: .standard(proto: "request_logs"),
    32: .same(proto: "wakeup"),
    33: .standard(proto: "home_feed_rerequest"),
    34: .standard(proto: "incoming_call"),
    35: .standard(proto: "call_ringing"),
    36: .standard(proto: "answer_call"),
    37: .standard(proto: "end_call"),
    38: .standard(proto: "ice_candidate"),
    39: .standard(proto: "marketing_alert"),
    40: .standard(proto: "ice_restart_offer"),
    41: .standard(proto: "ice_restart_answer"),
    42: .standard(proto: "group_feed_history"),
    43: .standard(proto: "pre_answer_call"),
    44: .standard(proto: "hold_call"),
    45: .standard(proto: "mute_call"),
    46: .standard(proto: "incoming_call_push"),
    47: .standard(proto: "call_sdp"),
    48: .standard(proto: "web_stanza"),
    21: .standard(proto: "retry_count"),
    25: .standard(proto: "rerequest_count"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: Server_Msg.TypeEnum = .normal
    var _toUid: Int64 = 0
    var _fromUid: Int64 = 0
    var _payload: Server_Msg.OneOf_Payload?
    var _retryCount: Int32 = 0
    var _rerequestCount: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _toUid = source._toUid
      _fromUid = source._fromUid
      _payload = source._payload
      _retryCount = source._retryCount
      _rerequestCount = source._rerequestCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._toUid) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._fromUid) }()
        case 5: try {
          var v: Server_ContactList?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .contactList(v)
          }
        }()
        case 6: try {
          var v: Server_Avatar?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .avatar(v)
          }
        }()
        case 7: try {
          var v: Server_WhisperKeys?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .whisperKeys(v)
          }
        }()
        case 8: try {
          var v: Server_SeenReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .seenReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .seenReceipt(v)
          }
        }()
        case 9: try {
          var v: Server_DeliveryReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .deliveryReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .deliveryReceipt(v)
          }
        }()
        case 10: try {
          var v: Server_ChatStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .chatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .chatStanza(v)
          }
        }()
        case 11: try {
          var v: Server_FeedItem?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .feedItem(v)
          }
        }()
        case 12: try {
          var v: Server_FeedItems?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .feedItems(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .feedItems(v)
          }
        }()
        case 13: try {
          var v: Server_ContactHash?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .contactHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .contactHash(v)
          }
        }()
        case 14: try {
          var v: Server_GroupStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupStanza(v)
          }
        }()
        case 15: try {
          var v: Server_GroupChat?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupChat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupChat(v)
          }
        }()
        case 16: try {
          var v: Server_Name?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .name(v)
          }
        }()
        case 17: try {
          var v: Server_ErrorStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .errorStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .errorStanza(v)
          }
        }()
        case 18: try {
          var v: Server_GroupChatRetract?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupchatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupchatRetract(v)
          }
        }()
        case 19: try {
          var v: Server_ChatRetract?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .chatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .chatRetract(v)
          }
        }()
        case 20: try {
          var v: Server_GroupFeedItem?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedItem(v)
          }
        }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._retryCount) }()
        case 22: try {
          var v: Server_Rerequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .rerequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .rerequest(v)
          }
        }()
        case 23: try {
          var v: Server_SilentChatStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .silentChatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .silentChatStanza(v)
          }
        }()
        case 24: try {
          var v: Server_GroupFeedItems?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedItems(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedItems(v)
          }
        }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._rerequestCount) }()
        case 26: try {
          var v: Server_EndOfQueue?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .endOfQueue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .endOfQueue(v)
          }
        }()
        case 27: try {
          var v: Server_InviteeNotice?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .inviteeNotice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .inviteeNotice(v)
          }
        }()
        case 28: try {
          var v: Server_GroupFeedRerequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedRerequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedRerequest(v)
          }
        }()
        case 29: try {
          var v: Server_HistoryResend?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .historyResend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .historyResend(v)
          }
        }()
        case 30: try {
          var v: Server_PlayedReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .playedReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .playedReceipt(v)
          }
        }()
        case 31: try {
          var v: Server_RequestLogs?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .requestLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .requestLogs(v)
          }
        }()
        case 32: try {
          var v: Server_WakeUp?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .wakeup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .wakeup(v)
          }
        }()
        case 33: try {
          var v: Server_HomeFeedRerequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .homeFeedRerequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .homeFeedRerequest(v)
          }
        }()
        case 34: try {
          var v: Server_IncomingCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .incomingCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .incomingCall(v)
          }
        }()
        case 35: try {
          var v: Server_CallRinging?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .callRinging(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .callRinging(v)
          }
        }()
        case 36: try {
          var v: Server_AnswerCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .answerCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .answerCall(v)
          }
        }()
        case 37: try {
          var v: Server_EndCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .endCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .endCall(v)
          }
        }()
        case 38: try {
          var v: Server_IceCandidate?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .iceCandidate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .iceCandidate(v)
          }
        }()
        case 39: try {
          var v: Server_MarketingAlert?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .marketingAlert(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .marketingAlert(v)
          }
        }()
        case 40: try {
          var v: Server_IceRestartOffer?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .iceRestartOffer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .iceRestartOffer(v)
          }
        }()
        case 41: try {
          var v: Server_IceRestartAnswer?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .iceRestartAnswer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .iceRestartAnswer(v)
          }
        }()
        case 42: try {
          var v: Server_GroupFeedHistory?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedHistory(v)
          }
        }()
        case 43: try {
          var v: Server_PreAnswerCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .preAnswerCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .preAnswerCall(v)
          }
        }()
        case 44: try {
          var v: Server_HoldCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .holdCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .holdCall(v)
          }
        }()
        case 45: try {
          var v: Server_MuteCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .muteCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .muteCall(v)
          }
        }()
        case 46: try {
          var v: Server_IncomingCallPush?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .incomingCallPush(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .incomingCallPush(v)
          }
        }()
        case 47: try {
          var v: Server_CallSdp?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .callSdp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .callSdp(v)
          }
        }()
        case 48: try {
          var v: Server_WebStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .webStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .webStanza(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._toUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._toUid, fieldNumber: 3)
      }
      if _storage._fromUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fromUid, fieldNumber: 4)
      }
      switch _storage._payload {
      case .contactList?: try {
        guard case .contactList(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .avatar?: try {
        guard case .avatar(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .whisperKeys?: try {
        guard case .whisperKeys(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .seenReceipt?: try {
        guard case .seenReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .deliveryReceipt?: try {
        guard case .deliveryReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .chatStanza?: try {
        guard case .chatStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .feedItem?: try {
        guard case .feedItem(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .feedItems?: try {
        guard case .feedItems(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .contactHash?: try {
        guard case .contactHash(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .groupStanza?: try {
        guard case .groupStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .groupChat?: try {
        guard case .groupChat(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .name?: try {
        guard case .name(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .errorStanza?: try {
        guard case .errorStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .groupchatRetract?: try {
        guard case .groupchatRetract(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .chatRetract?: try {
        guard case .chatRetract(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .groupFeedItem?: try {
        guard case .groupFeedItem(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      default: break
      }
      if _storage._retryCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._retryCount, fieldNumber: 21)
      }
      switch _storage._payload {
      case .rerequest?: try {
        guard case .rerequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .silentChatStanza?: try {
        guard case .silentChatStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .groupFeedItems?: try {
        guard case .groupFeedItems(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      default: break
      }
      if _storage._rerequestCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rerequestCount, fieldNumber: 25)
      }
      switch _storage._payload {
      case .endOfQueue?: try {
        guard case .endOfQueue(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .inviteeNotice?: try {
        guard case .inviteeNotice(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .groupFeedRerequest?: try {
        guard case .groupFeedRerequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .historyResend?: try {
        guard case .historyResend(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .playedReceipt?: try {
        guard case .playedReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .requestLogs?: try {
        guard case .requestLogs(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .wakeup?: try {
        guard case .wakeup(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .homeFeedRerequest?: try {
        guard case .homeFeedRerequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .incomingCall?: try {
        guard case .incomingCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .callRinging?: try {
        guard case .callRinging(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .answerCall?: try {
        guard case .answerCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .endCall?: try {
        guard case .endCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .iceCandidate?: try {
        guard case .iceCandidate(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .marketingAlert?: try {
        guard case .marketingAlert(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .iceRestartOffer?: try {
        guard case .iceRestartOffer(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .iceRestartAnswer?: try {
        guard case .iceRestartAnswer(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .groupFeedHistory?: try {
        guard case .groupFeedHistory(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .preAnswerCall?: try {
        guard case .preAnswerCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .holdCall?: try {
        guard case .holdCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .muteCall?: try {
        guard case .muteCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .incomingCallPush?: try {
        guard case .incomingCallPush(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .callSdp?: try {
        guard case .callSdp(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .webStanza?: try {
        guard case .webStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Msg, rhs: Server_Msg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._toUid != rhs_storage._toUid {return false}
        if _storage._fromUid != rhs_storage._fromUid {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._retryCount != rhs_storage._retryCount {return false}
        if _storage._rerequestCount != rhs_storage._rerequestCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Msg.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "GROUPCHAT"),
    3: .same(proto: "HEADLINE"),
    4: .same(proto: "CHAT"),
    5: .same(proto: "CALL"),
  ]
}

extension Server_Presence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Presence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "uid"),
    4: .standard(proto: "last_seen"),
    5: .standard(proto: "to_uid"),
    6: .standard(proto: "from_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastSeen) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.toUid) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.fromUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 3)
    }
    if self.lastSeen != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeen, fieldNumber: 4)
    }
    if self.toUid != 0 {
      try visitor.visitSingularInt64Field(value: self.toUid, fieldNumber: 5)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Presence, rhs: Server_Presence) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.lastSeen != rhs.lastSeen {return false}
    if lhs.toUid != rhs.toUid {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Presence.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AVAILABLE"),
    1: .same(proto: "AWAY"),
    2: .same(proto: "SUBSCRIBE"),
    3: .same(proto: "UNSUBSCRIBE"),
  ]
}

extension Server_ChatState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "thread_id"),
    3: .standard(proto: "thread_type"),
    4: .standard(proto: "from_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.threadType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.fromUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.threadType != .chat {
      try visitor.visitSingularEnumField(value: self.threadType, fieldNumber: 3)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatState, rhs: Server_ChatState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.threadType != rhs.threadType {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatState.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AVAILABLE"),
    1: .same(proto: "TYPING"),
  ]
}

extension Server_ChatState.ThreadType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "GROUP_CHAT"),
  ]
}

extension Server_Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Ack, rhs: Server_Ack) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HaError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HaError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HaError, rhs: Server_HaError) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Packet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "iq"),
    3: .same(proto: "ack"),
    4: .same(proto: "presence"),
    5: .standard(proto: "ha_error"),
    6: .standard(proto: "chat_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Server_Msg?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .msg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .msg(v)
        }
      }()
      case 2: try {
        var v: Server_Iq?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .iq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .iq(v)
        }
      }()
      case 3: try {
        var v: Server_Ack?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .ack(v)
        }
      }()
      case 4: try {
        var v: Server_Presence?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .presence(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .presence(v)
        }
      }()
      case 5: try {
        var v: Server_HaError?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .haError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .haError(v)
        }
      }()
      case 6: try {
        var v: Server_ChatState?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .chatState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .chatState(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.stanza {
    case .msg?: try {
      guard case .msg(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .iq?: try {
      guard case .iq(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .presence?: try {
      guard case .presence(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .haError?: try {
      guard case .haError(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .chatState?: try {
      guard case .chatState(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Packet, rhs: Server_Packet) -> Bool {
    if lhs.stanza != rhs.stanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UidElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UidElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UidElement, rhs: Server_UidElement) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UidElement.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_PhoneElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhoneElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "phone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PhoneElement, rhs: Server_PhoneElement) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PhoneElement.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_PrivacyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "uid_elements"),
    3: .same(proto: "hash"),
    4: .standard(proto: "phone_elements"),
    5: .standard(proto: "using_phones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uidElements) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.phoneElements) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.usingPhones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.uidElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uidElements, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 3)
    }
    if !self.phoneElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phoneElements, fieldNumber: 4)
    }
    if self.usingPhones != false {
      try visitor.visitSingularBoolField(value: self.usingPhones, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PrivacyList, rhs: Server_PrivacyList) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.uidElements != rhs.uidElements {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.phoneElements != rhs.phoneElements {return false}
    if lhs.usingPhones != rhs.usingPhones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PrivacyList.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "EXCEPT"),
    3: .same(proto: "MUTE"),
    4: .same(proto: "ONLY"),
  ]
}

extension Server_PrivacyLists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyLists"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_type"),
    2: .same(proto: "lists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.activeType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lists) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeType != .all {
      try visitor.visitSingularEnumField(value: self.activeType, fieldNumber: 1)
    }
    if !self.lists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lists, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PrivacyLists, rhs: Server_PrivacyLists) -> Bool {
    if lhs.activeType != rhs.activeType {return false}
    if lhs.lists != rhs.lists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PrivacyLists.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "EXCEPT"),
    3: .same(proto: "ONLY"),
  ]
}

extension Server_PushToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_type"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tokenType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tokenType != .android {
      try visitor.visitSingularEnumField(value: self.tokenType, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushToken, rhs: Server_PushToken) -> Bool {
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushToken.TokenType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANDROID"),
    1: .same(proto: "IOS"),
    2: .same(proto: "IOS_DEV"),
    3: .same(proto: "IOS_APPCLIP"),
    4: .same(proto: "IOS_VOIP"),
  ]
}

extension Server_PushRegister: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushRegister"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_token"),
    2: .standard(proto: "lang_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pushToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.langID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pushToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.langID.isEmpty {
      try visitor.visitSingularStringField(value: self.langID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushRegister, rhs: Server_PushRegister) -> Bool {
    if lhs._pushToken != rhs._pushToken {return false}
    if lhs.langID != rhs.langID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushPref: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushPref"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.name != .post {
      try visitor.visitSingularEnumField(value: self.name, fieldNumber: 1)
    }
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushPref, rhs: Server_PushPref) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushPref.Name: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "COMMENT"),
  ]
}

extension Server_NotificationPrefs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationPrefs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_prefs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pushPrefs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pushPrefs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pushPrefs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_NotificationPrefs, rhs: Server_NotificationPrefs) -> Bool {
    if lhs.pushPrefs != rhs.pushPrefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Rerequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rerequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "identity_key"),
    3: .standard(proto: "signed_pre_key_id"),
    4: .standard(proto: "one_time_pre_key_id"),
    5: .standard(proto: "session_setup_ephemeral_key"),
    6: .standard(proto: "message_ephemeral_key"),
    7: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.signedPreKeyID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.sessionSetupEphemeralKey) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.messageEphemeralKey) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 2)
    }
    if self.signedPreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.signedPreKeyID, fieldNumber: 3)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 4)
    }
    if !self.sessionSetupEphemeralKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionSetupEphemeralKey, fieldNumber: 5)
    }
    if !self.messageEphemeralKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageEphemeralKey, fieldNumber: 6)
    }
    if self.contentType != .chat {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Rerequest, rhs: Server_Rerequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.signedPreKeyID != rhs.signedPreKeyID {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.sessionSetupEphemeralKey != rhs.sessionSetupEphemeralKey {return false}
    if lhs.messageEphemeralKey != rhs.messageEphemeralKey {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Rerequest.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "CALL"),
    2: .same(proto: "GROUP_HISTORY"),
  ]
}

extension Server_GroupFeedRerequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedRerequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "id"),
    3: .standard(proto: "rerequest_type"),
    4: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rerequestType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if self.rerequestType != .payload {
      try visitor.visitSingularEnumField(value: self.rerequestType, fieldNumber: 3)
    }
    if self.contentType != .unknown {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedRerequest, rhs: Server_GroupFeedRerequest) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.rerequestType != rhs.rerequestType {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedRerequest.RerequestType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAYLOAD"),
    1: .same(proto: "SENDER_STATE"),
  ]
}

extension Server_GroupFeedRerequest.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "POST"),
    2: .same(proto: "COMMENT"),
    3: .same(proto: "HISTORY_RESEND"),
  ]
}

extension Server_HomeFeedRerequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HomeFeedRerequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "rerequest_type"),
    4: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.rerequestType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.rerequestType != .unknownType {
      try visitor.visitSingularEnumField(value: self.rerequestType, fieldNumber: 2)
    }
    if self.contentType != .unknown {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HomeFeedRerequest, rhs: Server_HomeFeedRerequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rerequestType != rhs.rerequestType {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HomeFeedRerequest.RerequestType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "PAYLOAD"),
    2: .same(proto: "SENDER_STATE"),
  ]
}

extension Server_HomeFeedRerequest.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "POST"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_SeenReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeenReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SeenReceipt, rhs: Server_SeenReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DeliveryReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeliveryReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DeliveryReceipt, rhs: Server_DeliveryReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PlayedReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayedReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PlayedReceipt, rhs: Server_PlayedReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupChatRetract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChatRetract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "gid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupChatRetract, rhs: Server_GroupChatRetract) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatRetract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatRetract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatRetract, rhs: Server_ChatRetract) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Prop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Prop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Prop, rhs: Server_Prop) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Props: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Props"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "props"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.props) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.props.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.props, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Props, rhs: Server_Props) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.props != rhs.props {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhisperKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "action"),
    3: .standard(proto: "identity_key"),
    4: .standard(proto: "signed_key"),
    5: .standard(proto: "otp_key_count"),
    6: .standard(proto: "one_time_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signedKey) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.otpKeyCount) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.oneTimeKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if self.action != .normal {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 3)
    }
    if !self.signedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedKey, fieldNumber: 4)
    }
    if self.otpKeyCount != 0 {
      try visitor.visitSingularInt32Field(value: self.otpKeyCount, fieldNumber: 5)
    }
    if !self.oneTimeKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.oneTimeKeys, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WhisperKeys, rhs: Server_WhisperKeys) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.action != rhs.action {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.signedKey != rhs.signedKey {return false}
    if lhs.otpKeyCount != rhs.otpKeyCount {return false}
    if lhs.oneTimeKeys != rhs.oneTimeKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeys.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ADD"),
    2: .same(proto: "COUNT"),
    3: .same(proto: "GET"),
    4: .same(proto: "SET"),
    5: .same(proto: "UPDATE"),
  ]
}

extension Server_TruncWhisperKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TruncWhisperKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "trunc_public_identity_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.truncPublicIdentityKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.truncPublicIdentityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.truncPublicIdentityKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TruncWhisperKeys, rhs: Server_TruncWhisperKeys) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.truncPublicIdentityKey != rhs.truncPublicIdentityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeysCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhisperKeysCollection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WhisperKeysCollection, rhs: Server_WhisperKeysCollection) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_TruncWhisperKeysCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TruncWhisperKeysCollection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TruncWhisperKeysCollection, rhs: Server_TruncWhisperKeysCollection) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_NoiseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoiseMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_type"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.messageType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageType != .xxA {
      try visitor.visitSingularEnumField(value: self.messageType, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_NoiseMessage, rhs: Server_NoiseMessage) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_NoiseMessage.MessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "XX_A"),
    1: .same(proto: "XX_B"),
    2: .same(proto: "XX_C"),
    3: .same(proto: "IK_A"),
    4: .same(proto: "IK_B"),
    5: .same(proto: "XX_FALLBACK_A"),
    6: .same(proto: "XX_FALLBACK_B"),
  ]
}

extension Server_DeleteAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "reason"),
    3: .same(proto: "feedback"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.feedback) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.reason != .unknownDeleteReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.feedback.isEmpty {
      try visitor.visitSingularStringField(value: self.feedback, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DeleteAccount, rhs: Server_DeleteAccount) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.feedback != rhs.feedback {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DeleteAccount.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DELETE_REASON"),
  ]
}

extension Server_ExportData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_ready_ts"),
    2: .same(proto: "status"),
    3: .standard(proto: "data_url"),
    4: .standard(proto: "available_until_ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.dataReadyTs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dataURL) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.availableUntilTs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dataReadyTs != 0 {
      try visitor.visitSingularInt64Field(value: self.dataReadyTs, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.dataURL.isEmpty {
      try visitor.visitSingularStringField(value: self.dataURL, fieldNumber: 3)
    }
    if self.availableUntilTs != 0 {
      try visitor.visitSingularInt64Field(value: self.availableUntilTs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ExportData, rhs: Server_ExportData) -> Bool {
    if lhs.dataReadyTs != rhs.dataReadyTs {return false}
    if lhs.status != rhs.status {return false}
    if lhs.dataURL != rhs.dataURL {return false}
    if lhs.availableUntilTs != rhs.availableUntilTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ExportData.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "READY"),
    3: .same(proto: "NOT_STARTED"),
  ]
}

extension Server_PushContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certificate"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.certificate) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificate, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushContent, rhs: Server_PushContent) -> Bool {
    if lhs.certificate != rhs.certificate {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InviteeNotice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InviteeNotice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inviters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inviters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inviters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InviteeNotice, rhs: Server_InviteeNotice) -> Bool {
    if lhs.inviters != rhs.inviters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Inviter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Inviter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
    3: .same(proto: "phone"),
    4: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Inviter, rhs: Server_Inviter) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IdentityKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IdentityKey, rhs: Server_IdentityKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RequestLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RequestLogs, rhs: Server_RequestLogs) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RegisterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otp_request"),
    2: .standard(proto: "verify_request"),
    3: .standard(proto: "hashcash_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Server_OtpRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .otpRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .otpRequest(v)
        }
      }()
      case 2: try {
        var v: Server_VerifyOtpRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .verifyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .verifyRequest(v)
        }
      }()
      case 3: try {
        var v: Server_HashcashRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .hashcashRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .hashcashRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .otpRequest?: try {
      guard case .otpRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .verifyRequest?: try {
      guard case .verifyRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hashcashRequest?: try {
      guard case .hashcashRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RegisterRequest, rhs: Server_RegisterRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otp_response"),
    2: .standard(proto: "verify_response"),
    3: .standard(proto: "hashcash_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Server_OtpResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .otpResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .otpResponse(v)
        }
      }()
      case 2: try {
        var v: Server_VerifyOtpResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .verifyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .verifyResponse(v)
        }
      }()
      case 3: try {
        var v: Server_HashcashResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .hashcashResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .hashcashResponse(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .otpResponse?: try {
      guard case .otpResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .verifyResponse?: try {
      guard case .verifyResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hashcashResponse?: try {
      guard case .hashcashResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RegisterResponse, rhs: Server_RegisterResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HashcashRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashcashRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HashcashRequest, rhs: Server_HashcashRequest) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HashcashResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashcashResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hashcash_challenge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hashcashChallenge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashcashChallenge.isEmpty {
      try visitor.visitSingularStringField(value: self.hashcashChallenge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HashcashResponse, rhs: Server_HashcashResponse) -> Bool {
    if lhs.hashcashChallenge != rhs.hashcashChallenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_OtpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OtpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "method"),
    3: .standard(proto: "lang_id"),
    4: .standard(proto: "group_invite_token"),
    5: .standard(proto: "user_agent"),
    6: .standard(proto: "hashcash_solution"),
    7: .standard(proto: "hashcash_solution_time_taken_ms"),
    8: .standard(proto: "campaign_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.langID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.groupInviteToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hashcashSolution) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.hashcashSolutionTimeTakenMs) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.campaignID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.method != .sms {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 2)
    }
    if !self.langID.isEmpty {
      try visitor.visitSingularStringField(value: self.langID, fieldNumber: 3)
    }
    if !self.groupInviteToken.isEmpty {
      try visitor.visitSingularStringField(value: self.groupInviteToken, fieldNumber: 4)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 5)
    }
    if !self.hashcashSolution.isEmpty {
      try visitor.visitSingularStringField(value: self.hashcashSolution, fieldNumber: 6)
    }
    if self.hashcashSolutionTimeTakenMs != 0 {
      try visitor.visitSingularInt64Field(value: self.hashcashSolutionTimeTakenMs, fieldNumber: 7)
    }
    if !self.campaignID.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_OtpRequest, rhs: Server_OtpRequest) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.method != rhs.method {return false}
    if lhs.langID != rhs.langID {return false}
    if lhs.groupInviteToken != rhs.groupInviteToken {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.hashcashSolution != rhs.hashcashSolution {return false}
    if lhs.hashcashSolutionTimeTakenMs != rhs.hashcashSolutionTimeTakenMs {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_OtpRequest.Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SMS"),
    1: .same(proto: "VOICE_CALL"),
  ]
}

extension Server_OtpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OtpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "result"),
    3: .same(proto: "reason"),
    4: .standard(proto: "retry_after_secs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.retryAfterSecs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 3)
    }
    if self.retryAfterSecs != 0 {
      try visitor.visitSingularInt64Field(value: self.retryAfterSecs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_OtpResponse, rhs: Server_OtpResponse) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.retryAfterSecs != rhs.retryAfterSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_OtpResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_OtpResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "INVALID_PHONE_NUMBER"),
    2: .same(proto: "INVALID_CLIENT_VERSION"),
    3: .same(proto: "BAD_METHOD"),
    4: .same(proto: "OTP_FAIL"),
    5: .same(proto: "NOT_INVITED"),
    6: .same(proto: "INVALID_GROUP_INVITE_TOKEN"),
    7: .same(proto: "RETRIED_TOO_SOON"),
    8: .same(proto: "BAD_REQUEST"),
    9: .same(proto: "INTERNAL_SERVER_ERROR"),
    10: .same(proto: "INVALID_HASHCASH_NONCE"),
    11: .same(proto: "WRONG_HASHCASH_SOLUTION"),
  ]
}

extension Server_VerifyOtpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyOtpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "code"),
    3: .same(proto: "name"),
    4: .standard(proto: "static_key"),
    5: .standard(proto: "signed_phrase"),
    6: .standard(proto: "identity_key"),
    7: .standard(proto: "signed_key"),
    8: .standard(proto: "one_time_keys"),
    9: .standard(proto: "group_invite_token"),
    10: .standard(proto: "push_register"),
    11: .standard(proto: "user_agent"),
    12: .standard(proto: "campaign_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.staticKey) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.signedPhrase) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.signedKey) }()
      case 8: try { try decoder.decodeRepeatedBytesField(value: &self.oneTimeKeys) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.groupInviteToken) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._pushRegister) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.campaignID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.staticKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.staticKey, fieldNumber: 4)
    }
    if !self.signedPhrase.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPhrase, fieldNumber: 5)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 6)
    }
    if !self.signedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedKey, fieldNumber: 7)
    }
    if !self.oneTimeKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.oneTimeKeys, fieldNumber: 8)
    }
    if !self.groupInviteToken.isEmpty {
      try visitor.visitSingularStringField(value: self.groupInviteToken, fieldNumber: 9)
    }
    try { if let v = self._pushRegister {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 11)
    }
    if !self.campaignID.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignID, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_VerifyOtpRequest, rhs: Server_VerifyOtpRequest) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.code != rhs.code {return false}
    if lhs.name != rhs.name {return false}
    if lhs.staticKey != rhs.staticKey {return false}
    if lhs.signedPhrase != rhs.signedPhrase {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.signedKey != rhs.signedKey {return false}
    if lhs.oneTimeKeys != rhs.oneTimeKeys {return false}
    if lhs.groupInviteToken != rhs.groupInviteToken {return false}
    if lhs._pushRegister != rhs._pushRegister {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_VerifyOtpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyOtpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "uid"),
    3: .same(proto: "name"),
    4: .same(proto: "result"),
    5: .same(proto: "reason"),
    6: .standard(proto: "group_invite_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.groupInviteResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 4)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 5)
    }
    if !self.groupInviteResult.isEmpty {
      try visitor.visitSingularStringField(value: self.groupInviteResult, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_VerifyOtpResponse, rhs: Server_VerifyOtpResponse) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.groupInviteResult != rhs.groupInviteResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_VerifyOtpResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_VerifyOtpResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "INVALID_PHONE_NUMBER"),
    2: .same(proto: "INVALID_CLIENT_VERSION"),
    3: .same(proto: "WRONG_SMS_CODE"),
    4: .same(proto: "MISSING_PHONE"),
    5: .same(proto: "MISSING_CODE"),
    6: .same(proto: "MISSING_NAME"),
    7: .same(proto: "INVALID_NAME"),
    8: .same(proto: "MISSING_IDENTITY_KEY"),
    9: .same(proto: "MISSING_SIGNED_KEY"),
    10: .same(proto: "MISSING_ONE_TIME_KEYS"),
    11: .same(proto: "BAD_BASE64_KEY"),
    12: .same(proto: "INVALID_ONE_TIME_KEYS"),
    13: .same(proto: "TOO_FEW_ONE_TIME_KEYS"),
    14: .same(proto: "TOO_MANY_ONE_TIME_KEYS"),
    15: .same(proto: "TOO_BIG_IDENTITY_KEY"),
    16: .same(proto: "TOO_BIG_SIGNED_KEY"),
    17: .same(proto: "TOO_BIG_ONE_TIME_KEYS"),
    18: .same(proto: "INVALID_S_ED_PUB"),
    19: .same(proto: "INVALID_SIGNED_PHRASE"),
    20: .same(proto: "UNABLE_TO_OPEN_SIGNED_PHRASE"),
    21: .same(proto: "BAD_REQUEST"),
    22: .same(proto: "INTERNAL_SERVER_ERROR"),
  ]
}

extension Server_ClientOtpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientOtpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "phone"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.method != .sms {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientOtpRequest, rhs: Server_ClientOtpRequest) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientOtpRequest.Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SMS"),
    1: .same(proto: "VOICE_CALL"),
  ]
}

extension Server_ClientOtpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientOtpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientOtpResponse, rhs: Server_ClientOtpResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientOtpResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_ClientOtpResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "SETUP_ISSUE"),
    2: .same(proto: "PERMISSION_ISSUE"),
    3: .same(proto: "FORMATTING_ISSUE"),
    4: .same(proto: "NETWORKING_ISSUE"),
  ]
}

extension Server_WakeUp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WakeUp"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WakeUp, rhs: Server_WakeUp) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MarketingAlert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketingAlert"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MarketingAlert, rhs: Server_MarketingAlert) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MarketingAlert.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVITE_FRIENDS"),
    2: .same(proto: "SHARE_POST"),
  ]
}
