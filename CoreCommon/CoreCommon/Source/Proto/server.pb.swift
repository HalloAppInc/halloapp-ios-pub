// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Server_PublicFeedContentType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case moments // = 0
  case posts // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .moments
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .moments
    case 1: self = .posts
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .moments: return 0
    case .posts: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_PublicFeedContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PublicFeedContentType] = [
    .moments,
    .posts,
  ]
}

#endif  // swift(>=4.2)

/// Calls
public enum Server_CallType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownType // = 0
  case audio // = 1
  case video // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownType
    case 1: self = .audio
    case 2: self = .video
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownType: return 0
    case .audio: return 1
    case .video: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_CallType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_CallType] = [
    .unknownType,
    .audio,
    .video,
  ]
}

#endif  // swift(>=4.2)

public enum Server_FollowStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case none // = 0
  case pending // = 1
  case following // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .pending
    case 2: self = .following
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .pending: return 1
    case .following: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_FollowStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FollowStatus] = [
    .none,
    .pending,
    .following,
  ]
}

#endif  // swift(>=4.2)

public enum Server_AlbumAccess: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// uids have to be explicitly added
  case inviteOnly // = 0

  /// all HalloApp contacts and anyone with a link to the album
  case everyone // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .inviteOnly
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inviteOnly
    case 1: self = .everyone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .inviteOnly: return 0
    case .everyone: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_AlbumAccess: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AlbumAccess] = [
    .inviteOnly,
    .everyone,
  ]
}

#endif  // swift(>=4.2)

public enum Server_FriendshipStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noneStatus // = 0
  case incomingPending // = 1
  case outgoingPending // = 2
  case friends // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .noneStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noneStatus
    case 1: self = .incomingPending
    case 2: self = .outgoingPending
    case 3: self = .friends
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noneStatus: return 0
    case .incomingPending: return 1
    case .outgoingPending: return 2
    case .friends: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_FriendshipStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FriendshipStatus] = [
    .noneStatus,
    .incomingPending,
    .outgoingPending,
    .friends,
  ]
}

#endif  // swift(>=4.2)

public struct Server_UploadAvatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  /// scaled-down binary jpeg data.
  public var data: Data = Data()

  /// full binary jpeg data.
  public var fullData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Avatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Avatars {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var avatars: [Server_Avatar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UploadGroupAvatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  /// scaled-down binary jpeg data.
  public var data: Data = Data()

  /// full binary jpeg data.
  public var fullData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_CertMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var serverKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ClientMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Server_ClientMode.Mode = .active

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Mode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case active // = 0
    case passive // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .active
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .active
      case 1: self = .passive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .active: return 0
      case .passive: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ClientMode.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientMode.Mode] = [
    .active,
    .passive,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ClientVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var expiresInSeconds: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Brand + ":" + Model Ex: "Iphone:12 Pro" / "OnePlus:KB2005".
  public var device: String = String()

  /// "14.8" for iOS / "29" for API level in Android.
  public var osVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ClientLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var counts: [Server_Count] = []

  public var events: [Server_EventData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Count {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var namespace: String = String()

  public var metric: String = String()

  public var count: Int64 = 0

  public var dims: [Server_Dim] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Dim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_Contact.Action = .add

  public var raw: String = String()

  public var normalized: String = String()

  public var uid: Int64 = 0

  public var avatarID: String = String()

  public var name: String = String()

  public var numPotentialFriends: Int64 = 0

  public var numPotentialCloseFriends: Int64 = 0

  public var invitationRank: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Contact.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Contact.Action] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ContactList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ContactList.TypeEnum = .full

  public var syncID: String = String()

  public var batchIndex: Int32 = 0

  public var isLast: Bool = false

  public var contacts: [Server_Contact] = []

  public var hasPermissions_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case full // = 0
    case delta // = 1
    case normal // = 2
    case friendNotice // = 3
    case inviterNotice // = 4
    case deleteNotice // = 5
    case contactNotice // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .full
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .full
      case 1: self = .delta
      case 2: self = .normal
      case 3: self = .friendNotice
      case 4: self = .inviterNotice
      case 5: self = .deleteNotice
      case 6: self = .contactNotice
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .full: return 0
      case .delta: return 1
      case .normal: return 2
      case .friendNotice: return 3
      case .inviterNotice: return 4
      case .deleteNotice: return 5
      case .contactNotice: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ContactList.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ContactList.TypeEnum] = [
    .full,
    .delta,
    .normal,
    .friendNotice,
    .inviterNotice,
    .deleteNotice,
    .contactNotice,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ContactHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ContactSyncError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var retryAfterSecs: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MomentInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// timestamp received from the server in the notification.
  public var notificationTimestamp: Int64 = 0

  /// Time taken on the moment camera to capture the moment.
  public var timeTaken: Int64 = 0

  /// Number of times a moment has been captured.
  public var numTakes: Int64 = 0

  /// Number of times the selfie view has been captured.
  public var numSelfieTakes: Int64 = 0

  /// Id of the notification that resulted in the user posting this moment.
  public var notificationID: Int64 = 0

  /// Actual content type based on moment notification info.
  public var contentType: Server_MomentInfo.ContentType = .image

  /// Date received with the notification in the format: DD/MM/YYYY.
  public var date: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case image // = 0
    case video // = 1
    case text // = 2
    case albumImage // = 3
    case albumDump // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .image
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .image
      case 1: self = .video
      case 2: self = .text
      case 3: self = .albumImage
      case 4: self = .albumDump
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .image: return 0
      case .video: return 1
      case .text: return 2
      case .albumImage: return 3
      case .albumDump: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MomentInfo.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MomentInfo.ContentType] = [
    .image,
    .video,
    .text,
    .albumImage,
    .albumDump,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaCounters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numImages: Int32 = 0

  public var numVideos: Int32 = 0

  public var numAudio: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Audience {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_Audience.TypeEnum = .all

  public var uids: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case except // = 1
    case only // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .except
      case 2: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .except: return 1
      case .only: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Audience.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Audience.TypeEnum] = [
    .all,
    .except,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Post {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var publisherUid: Int64 {
    get {return _storage._publisherUid}
    set {_uniqueStorage()._publisherUid = newValue}
  }

  public var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var audience: Server_Audience {
    get {return _storage._audience ?? Server_Audience()}
    set {_uniqueStorage()._audience = newValue}
  }
  /// Returns true if `audience` has been explicitly set.
  public var hasAudience: Bool {return _storage._audience != nil}
  /// Clears the value of `audience`. Subsequent reads from it will return its default value.
  public mutating func clearAudience() {_uniqueStorage()._audience = nil}

  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var publisherName: String {
    get {return _storage._publisherName}
    set {_uniqueStorage()._publisherName = newValue}
  }

  /// Serialized EncryptedPayload (from client.proto).
  public var encPayload: Data {
    get {return _storage._encPayload}
    set {_uniqueStorage()._encPayload = newValue}
  }

  public var mediaCounters: Server_MediaCounters {
    get {return _storage._mediaCounters ?? Server_MediaCounters()}
    set {_uniqueStorage()._mediaCounters = newValue}
  }
  /// Returns true if `mediaCounters` has been explicitly set.
  public var hasMediaCounters: Bool {return _storage._mediaCounters != nil}
  /// Clears the value of `mediaCounters`. Subsequent reads from it will return its default value.
  public mutating func clearMediaCounters() {_uniqueStorage()._mediaCounters = nil}

  public var tag: Server_Post.Tag {
    get {return _storage._tag}
    set {_uniqueStorage()._tag = newValue}
  }

  public var psaTag: String {
    get {return _storage._psaTag}
    set {_uniqueStorage()._psaTag = newValue}
  }

  public var momentUnlockUid: Int64 {
    get {return _storage._momentUnlockUid}
    set {_uniqueStorage()._momentUnlockUid = newValue}
  }

  /// If set to true, the client will try and show ui design to
  /// share the recently composed post externally.
  public var showPostShareScreen: Bool {
    get {return _storage._showPostShareScreen}
    set {_uniqueStorage()._showPostShareScreen = newValue}
  }

  /// Must be set only for moments.
  public var momentInfo: Server_MomentInfo {
    get {return _storage._momentInfo ?? Server_MomentInfo()}
    set {_uniqueStorage()._momentInfo = newValue}
  }
  /// Returns true if `momentInfo` has been explicitly set.
  public var hasMomentInfo: Bool {return _storage._momentInfo != nil}
  /// Clears the value of `momentInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMomentInfo() {_uniqueStorage()._momentInfo = nil}

  /// Set by the server.
  public var isExpired: Bool {
    get {return _storage._isExpired}
    set {_uniqueStorage()._isExpired = newValue}
  }

  public var publisherUsername: String {
    get {return _storage._publisherUsername}
    set {_uniqueStorage()._publisherUsername = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Tag: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case empty // = 0
    case moment // = 1
    case publicMoment // = 2
    case publicPost // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .empty
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .empty
      case 1: self = .moment
      case 2: self = .publicMoment
      case 3: self = .publicPost
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .empty: return 0
      case .moment: return 1
      case .publicMoment: return 2
      case .publicPost: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_Post.Tag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Post.Tag] = [
    .empty,
    .moment,
    .publicMoment,
    .publicPost,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Comment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var postID: String = String()

  public var parentCommentID: String = String()

  public var publisherUid: Int64 = 0

  public var publisherName: String = String()

  public var payload: Data = Data()

  public var timestamp: Int64 = 0

  /// Serialized EncryptedPayload (from client.proto).
  public var encPayload: Data = Data()

  public var mediaCounters: Server_MediaCounters {
    get {return _mediaCounters ?? Server_MediaCounters()}
    set {_mediaCounters = newValue}
  }
  /// Returns true if `mediaCounters` has been explicitly set.
  public var hasMediaCounters: Bool {return self._mediaCounters != nil}
  /// Clears the value of `mediaCounters`. Subsequent reads from it will return its default value.
  public mutating func clearMediaCounters() {self._mediaCounters = nil}

  public var commentType: Server_Comment.CommentType = .comment

  public var publisherUsername: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CommentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case comment // = 0
    case commentReaction // = 1
    case postReaction // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .comment
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .comment
      case 1: self = .commentReaction
      case 2: self = .postReaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .comment: return 0
      case .commentReaction: return 1
      case .postReaction: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _mediaCounters: Server_MediaCounters? = nil
}

#if swift(>=4.2)

extension Server_Comment.CommentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Comment.CommentType] = [
    .comment,
    .commentReaction,
    .postReaction,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ShareStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var postIds: [String] = []

  public var result: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_FeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_FeedItem.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var item: OneOf_Item? {
    get {return _storage._item}
    set {_uniqueStorage()._item = newValue}
  }

  public var post: Server_Post {
    get {
      if case .post(let v)? = _storage._item {return v}
      return Server_Post()
    }
    set {_uniqueStorage()._item = .post(newValue)}
  }

  public var comment: Server_Comment {
    get {
      if case .comment(let v)? = _storage._item {return v}
      return Server_Comment()
    }
    set {_uniqueStorage()._item = .comment(newValue)}
  }

  public var shareStanzas: [Server_ShareStanza] {
    get {return _storage._shareStanzas}
    set {_uniqueStorage()._shareStanzas = newValue}
  }

  /// Sent by the publisher.
  public var senderStateBundles: [Server_SenderStateBundle] {
    get {return _storage._senderStateBundles}
    set {_uniqueStorage()._senderStateBundles = newValue}
  }

  /// Meant for the receiver, computed by the server using `sender_state_bundles`.
  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _storage._senderState ?? Server_SenderStateWithKeyInfo()}
    set {_uniqueStorage()._senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return _storage._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {_uniqueStorage()._senderState = nil}

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String {
    get {return _storage._senderClientVersion}
    set {_uniqueStorage()._senderClientVersion = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Item: Equatable {
    case post(Server_Post)
    case comment(Server_Comment)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_FeedItem.OneOf_Item, rhs: Server_FeedItem.OneOf_Item) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.post, .post): return {
        guard case .post(let l) = lhs, case .post(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.comment, .comment): return {
        guard case .comment(let l) = lhs, case .comment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case publish // = 0
    case retract // = 1
    case share // = 2
    case publicUpdatePublish // = 3
    case expire // = 4
    case publicUpdateRetract // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .publish
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .publish
      case 1: self = .retract
      case 2: self = .share
      case 3: self = .publicUpdatePublish
      case 4: self = .expire
      case 5: self = .publicUpdateRetract
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .publish: return 0
      case .retract: return 1
      case .share: return 2
      case .publicUpdatePublish: return 3
      case .expire: return 4
      case .publicUpdateRetract: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_FeedItem.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FeedItem.Action] = [
    .publish,
    .retract,
    .share,
    .publicUpdatePublish,
    .expire,
    .publicUpdateRetract,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FeedItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var items: [Server_FeedItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PublicFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cursor: String = String()

  public var publicFeedContentType: Server_PublicFeedContentType = .moments

  public var gpsLocation: Server_GpsLocation {
    get {return _gpsLocation ?? Server_GpsLocation()}
    set {_gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return self._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {self._gpsLocation = nil}

  public var showDevContent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gpsLocation: Server_GpsLocation? = nil
}

public struct Server_PublicFeedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_PublicFeedResponse.Result = .unknown

  public var reason: Server_PublicFeedResponse.Reason = .unknownReason

  public var cursor: String = String()

  public var publicFeedContentType: Server_PublicFeedContentType = .moments

  public var cursorRestarted: Bool = false

  /// items are ordered and should be presented in that order.
  public var items: [Server_PublicFeedItem] = []

  /// Server will include the updated geo-tags here for client.
  public var geoTags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case ok // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .ok
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .ok: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PublicFeedResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PublicFeedResponse.Result] = [
    .unknown,
    .success,
    .failure,
  ]
}

extension Server_PublicFeedResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PublicFeedResponse.Reason] = [
    .unknownReason,
    .ok,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PublicFeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userProfile: Server_BasicUserProfile {
    get {return _userProfile ?? Server_BasicUserProfile()}
    set {_userProfile = newValue}
  }
  /// Returns true if `userProfile` has been explicitly set.
  public var hasUserProfile: Bool {return self._userProfile != nil}
  /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
  public mutating func clearUserProfile() {self._userProfile = nil}

  public var post: Server_Post {
    get {return _post ?? Server_Post()}
    set {_post = newValue}
  }
  /// Returns true if `post` has been explicitly set.
  public var hasPost: Bool {return self._post != nil}
  /// Clears the value of `post`. Subsequent reads from it will return its default value.
  public mutating func clearPost() {self._post = nil}

  /// Comments will be capped - 20 per post for now.
  public var comments: [Server_Comment] = []

  public var reason: Server_PublicFeedItem.Reason = .unknownReason

  /// will not be returned for non-devs
  public var score: Server_ServerScore {
    get {return _score ?? Server_ServerScore()}
    set {_score = newValue}
  }
  /// Returns true if `score` has been explicitly set.
  public var hasScore: Bool {return self._score != nil}
  /// Clears the value of `score`. Subsequent reads from it will return its default value.
  public mutating func clearScore() {self._score = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case campus // = 1
    case fof // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .campus
      case 2: self = .fof
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .campus: return 1
      case .fof: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _userProfile: Server_BasicUserProfile? = nil
  fileprivate var _post: Server_Post? = nil
  fileprivate var _score: Server_ServerScore? = nil
}

#if swift(>=4.2)

extension Server_PublicFeedItem.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PublicFeedItem.Reason] = [
    .unknownReason,
    .campus,
    .fof,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ServerScore {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// for backwards compatability; the double version of score should be used instead
  public var score: Int64 = 0

  public var explanation: String = String()

  public var dscore: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PublicFeedUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cursor: String = String()

  public var publicFeedContentType: Server_PublicFeedContentType = .moments

  public var items: [Server_PublicFeedItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GpsLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var latitude: Double = 0

  public var longitude: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PostSubscriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_PostSubscriptionRequest.Action = .unknownAction

  public var postID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownAction // = 0
    case subscribe // = 1
    case unsubscribe // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownAction
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownAction
      case 1: self = .subscribe
      case 2: self = .unsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownAction: return 0
      case .subscribe: return 1
      case .unsubscribe: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PostSubscriptionRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PostSubscriptionRequest.Action] = [
    .unknownAction,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PostSubscriptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_PostSubscriptionResponse.Result = .unknownResult

  public var reason: Server_PostSubscriptionResponse.Reason = .unknownReason

  public var items: [Server_FeedItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case invalidPostID // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .invalidPostID
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .invalidPostID: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PostSubscriptionResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PostSubscriptionResponse.Result] = [
    .unknownResult,
    .success,
    .failure,
  ]
}

extension Server_PostSubscriptionResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PostSubscriptionResponse.Reason] = [
    .unknownReason,
    .invalidPostID,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SenderStateWithKeyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int64 = 0

  public var encSenderState: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_SenderStateBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _senderState ?? Server_SenderStateWithKeyInfo()}
    set {_senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return self._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {self._senderState = nil}

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _senderState: Server_SenderStateWithKeyInfo? = nil
}

public struct Server_GroupFeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupFeedItem.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var gid: String {
    get {return _storage._gid}
    set {_uniqueStorage()._gid = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatarID: String {
    get {return _storage._avatarID}
    set {_uniqueStorage()._avatarID = newValue}
  }

  public var item: OneOf_Item? {
    get {return _storage._item}
    set {_uniqueStorage()._item = newValue}
  }

  public var post: Server_Post {
    get {
      if case .post(let v)? = _storage._item {return v}
      return Server_Post()
    }
    set {_uniqueStorage()._item = .post(newValue)}
  }

  public var comment: Server_Comment {
    get {
      if case .comment(let v)? = _storage._item {return v}
      return Server_Comment()
    }
    set {_uniqueStorage()._item = .comment(newValue)}
  }

  /// Sent by the publisher.
  public var senderStateBundles: [Server_SenderStateBundle] {
    get {return _storage._senderStateBundles}
    set {_uniqueStorage()._senderStateBundles = newValue}
  }

  /// Meant for the receiver, computed by the server using `sender_state_bundles`.
  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _storage._senderState ?? Server_SenderStateWithKeyInfo()}
    set {_uniqueStorage()._senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return _storage._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {_uniqueStorage()._senderState = nil}

  public var audienceHash: Data {
    get {return _storage._audienceHash}
    set {_uniqueStorage()._audienceHash = newValue}
  }

  public var isResentHistory: Bool {
    get {return _storage._isResentHistory}
    set {_uniqueStorage()._isResentHistory = newValue}
  }

  /// Set only for post items. `-1` if item should never expire.
  public var expiryTimestamp: Int64 {
    get {return _storage._expiryTimestamp}
    set {_uniqueStorage()._expiryTimestamp = newValue}
  }

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String {
    get {return _storage._senderLogInfo}
    set {_uniqueStorage()._senderLogInfo = newValue}
  }

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String {
    get {return _storage._senderClientVersion}
    set {_uniqueStorage()._senderClientVersion = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Item: Equatable {
    case post(Server_Post)
    case comment(Server_Comment)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_GroupFeedItem.OneOf_Item, rhs: Server_GroupFeedItem.OneOf_Item) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.post, .post): return {
        guard case .post(let l) = lhs, case .post(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.comment, .comment): return {
        guard case .comment(let l) = lhs, case .comment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case publish // = 0
    case retract // = 1
    case share // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .publish
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .publish
      case 1: self = .retract
      case 2: self = .share
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .publish: return 0
      case .retract: return 1
      case .share: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_GroupFeedItem.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupFeedItem.Action] = [
    .publish,
    .retract,
    .share,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupFeedItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var items: [Server_GroupFeedItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupFeedHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var id: String = String()

  public var payload: Data = Data()

  /// Serialized GroupFeedItems stanza and then encrypted using 1-1 channel.
  public var encPayload: Data = Data()

  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int32 = 0

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String = String()

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupMember.Action = .add

  public var uid: Int64 = 0

  public var type: Server_GroupMember.TypeEnum = .member

  public var name: String = String()

  public var avatarID: String = String()

  public var result: String = String()

  public var reason: String = String()

  /// Identity key to be returned on `GET_MEMBER_IDENTITY_KEYS` IQ.
  public var identityKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case remove // = 1
    case promote // = 2
    case demote // = 3
    case leave // = 4
    case join // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .remove
      case 2: self = .promote
      case 3: self = .demote
      case 4: self = .leave
      case 5: self = .join
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .remove: return 1
      case .promote: return 2
      case .demote: return 3
      case .leave: return 4
      case .join: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case member // = 0
    case admin // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .member
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .member
      case 1: self = .admin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .member: return 0
      case .admin: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupMember.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupMember.Action] = [
    .add,
    .remove,
    .promote,
    .demote,
    .leave,
    .join,
  ]
}

extension Server_GroupMember.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupMember.TypeEnum] = [
    .member,
    .admin,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupStanza.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var gid: String {
    get {return _storage._gid}
    set {_uniqueStorage()._gid = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatarID: String {
    get {return _storage._avatarID}
    set {_uniqueStorage()._avatarID = newValue}
  }

  public var senderUid: Int64 {
    get {return _storage._senderUid}
    set {_uniqueStorage()._senderUid = newValue}
  }

  public var senderName: String {
    get {return _storage._senderName}
    set {_uniqueStorage()._senderName = newValue}
  }

  public var members: [Server_GroupMember] {
    get {return _storage._members}
    set {_uniqueStorage()._members = newValue}
  }

  public var background: String {
    get {return _storage._background}
    set {_uniqueStorage()._background = newValue}
  }

  /// Audience hash to be returned on `GET_MEMBER_IDENTITY_KEYS` IQ.
  public var audienceHash: Data {
    get {return _storage._audienceHash}
    set {_uniqueStorage()._audienceHash = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// HistoryResend to be sent or received only on adding-members iq or share-history iq.
  public var historyResend: Server_HistoryResend {
    get {return _storage._historyResend ?? Server_HistoryResend()}
    set {_uniqueStorage()._historyResend = newValue}
  }
  /// Returns true if `historyResend` has been explicitly set.
  public var hasHistoryResend: Bool {return _storage._historyResend != nil}
  /// Clears the value of `historyResend`. Subsequent reads from it will return its default value.
  public mutating func clearHistoryResend() {_uniqueStorage()._historyResend = nil}

  /// Expiry timer information
  public var expiryInfo: Server_ExpiryInfo {
    get {return _storage._expiryInfo ?? Server_ExpiryInfo()}
    set {_uniqueStorage()._expiryInfo = newValue}
  }
  /// Returns true if `expiryInfo` has been explicitly set.
  public var hasExpiryInfo: Bool {return _storage._expiryInfo != nil}
  /// Clears the value of `expiryInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExpiryInfo() {_uniqueStorage()._expiryInfo = nil}

  public var groupType: Server_GroupStanza.GroupType {
    get {return _storage._groupType}
    set {_uniqueStorage()._groupType = newValue}
  }

  /// If set, override the max_group_size prop value.
  public var maxGroupSize: Int64 {
    get {return _storage._maxGroupSize}
    set {_uniqueStorage()._maxGroupSize = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case set // = 0
    case get // = 1
    case create // = 2
    case delete // = 3
    case leave // = 4
    case changeAvatar // = 5
    case changeName // = 6
    case modifyAdmins // = 7
    case modifyMembers // = 8
    case autoPromoteAdmins // = 9
    case setName // = 10
    case join // = 11
    case preview // = 12
    case setBackground // = 13
    case getMemberIdentityKeys // = 14
    case changeDescription // = 15
    case shareHistory // = 16
    case changeExpiry // = 17
    case UNRECOGNIZED(Int)

    public init() {
      self = .set
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .set
      case 1: self = .get
      case 2: self = .create
      case 3: self = .delete
      case 4: self = .leave
      case 5: self = .changeAvatar
      case 6: self = .changeName
      case 7: self = .modifyAdmins
      case 8: self = .modifyMembers
      case 9: self = .autoPromoteAdmins
      case 10: self = .setName
      case 11: self = .join
      case 12: self = .preview
      case 13: self = .setBackground
      case 14: self = .getMemberIdentityKeys
      case 15: self = .changeDescription
      case 16: self = .shareHistory
      case 17: self = .changeExpiry
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .set: return 0
      case .get: return 1
      case .create: return 2
      case .delete: return 3
      case .leave: return 4
      case .changeAvatar: return 5
      case .changeName: return 6
      case .modifyAdmins: return 7
      case .modifyMembers: return 8
      case .autoPromoteAdmins: return 9
      case .setName: return 10
      case .join: return 11
      case .preview: return 12
      case .setBackground: return 13
      case .getMemberIdentityKeys: return 14
      case .changeDescription: return 15
      case .shareHistory: return 16
      case .changeExpiry: return 17
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum GroupType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case feed // = 0
    case chat // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .feed
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .feed
      case 1: self = .chat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .feed: return 0
      case .chat: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_GroupStanza.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupStanza.Action] = [
    .set,
    .get,
    .create,
    .delete,
    .leave,
    .changeAvatar,
    .changeName,
    .modifyAdmins,
    .modifyMembers,
    .autoPromoteAdmins,
    .setName,
    .join,
    .preview,
    .setBackground,
    .getMemberIdentityKeys,
    .changeDescription,
    .shareHistory,
    .changeExpiry,
  ]
}

extension Server_GroupStanza.GroupType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupStanza.GroupType] = [
    .feed,
    .chat,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ExpiryInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var expiryType: Server_ExpiryInfo.ExpiryType = .expiresInSeconds

  /// This is set when expiry_type is expires_in_sec.
  public var expiresInSeconds: Int64 = 0

  /// This is set when expiry_type is custom_date.
  public var expiryTimestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ExpiryType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case expiresInSeconds // = 0
    case never // = 1
    case customDate // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .expiresInSeconds
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .expiresInSeconds
      case 1: self = .never
      case 2: self = .customDate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .expiresInSeconds: return 0
      case .never: return 1
      case .customDate: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ExpiryInfo.ExpiryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ExpiryInfo.ExpiryType] = [
    .expiresInSeconds,
    .never,
    .customDate,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupChat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var senderUid: Int64 = 0

  public var senderName: String = String()

  public var timestamp: Int64 = 0

  public var payload: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupChatStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String {
    get {return _storage._gid}
    set {_uniqueStorage()._gid = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var avatarID: String {
    get {return _storage._avatarID}
    set {_uniqueStorage()._avatarID = newValue}
  }

  public var senderPhone: String {
    get {return _storage._senderPhone}
    set {_uniqueStorage()._senderPhone = newValue}
  }

  public var senderName: String {
    get {return _storage._senderName}
    set {_uniqueStorage()._senderName = newValue}
  }

  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var payload: Data {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var encPayload: Data {
    get {return _storage._encPayload}
    set {_uniqueStorage()._encPayload = newValue}
  }

  public var senderStateBundles: [Server_SenderStateBundle] {
    get {return _storage._senderStateBundles}
    set {_uniqueStorage()._senderStateBundles = newValue}
  }

  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _storage._senderState ?? Server_SenderStateWithKeyInfo()}
    set {_uniqueStorage()._senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return _storage._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {_uniqueStorage()._senderState = nil}

  public var audienceHash: Data {
    get {return _storage._audienceHash}
    set {_uniqueStorage()._audienceHash = newValue}
  }

  public var mediaCounters: Server_MediaCounters {
    get {return _storage._mediaCounters ?? Server_MediaCounters()}
    set {_uniqueStorage()._mediaCounters = newValue}
  }
  /// Returns true if `mediaCounters` has been explicitly set.
  public var hasMediaCounters: Bool {return _storage._mediaCounters != nil}
  /// Clears the value of `mediaCounters`. Subsequent reads from it will return its default value.
  public mutating func clearMediaCounters() {_uniqueStorage()._mediaCounters = nil}

  public var chatType: Server_GroupChatStanza.ChatType {
    get {return _storage._chatType}
    set {_uniqueStorage()._chatType = newValue}
  }

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String {
    get {return _storage._senderLogInfo}
    set {_uniqueStorage()._senderLogInfo = newValue}
  }

  public var senderClientVersion: String {
    get {return _storage._senderClientVersion}
    set {_uniqueStorage()._senderClientVersion = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ChatType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case chatReaction // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .chatReaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .chatReaction: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_GroupChatStanza.ChatType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupChatStanza.ChatType] = [
    .chat,
    .chatReaction,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupsStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupsStanza.Action = .get

  public var groupStanzas: [Server_GroupStanza] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupsStanza.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupsStanza.Action] = [
    .get,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupInviteLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupInviteLink.Action = .unknown

  public var gid: String = String()

  public var link: String = String()

  public var result: String = String()

  public var reason: String = String()

  ///only present for action=JOIN
  public var group: Server_GroupStanza {
    get {return _group ?? Server_GroupStanza()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case get // = 1
    case reset // = 2
    case join // = 3
    case preview // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .get
      case 2: self = .reset
      case 3: self = .join
      case 4: self = .preview
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .get: return 1
      case .reset: return 2
      case .join: return 3
      case .preview: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _group: Server_GroupStanza? = nil
}

#if swift(>=4.2)

extension Server_GroupInviteLink.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupInviteLink.Action] = [
    .unknown,
    .get,
    .reset,
    .join,
    .preview,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var pwd: String = String()

  public var clientMode: Server_ClientMode {
    get {return _clientMode ?? Server_ClientMode()}
    set {_clientMode = newValue}
  }
  /// Returns true if `clientMode` has been explicitly set.
  public var hasClientMode: Bool {return self._clientMode != nil}
  /// Clears the value of `clientMode`. Subsequent reads from it will return its default value.
  public mutating func clearClientMode() {self._clientMode = nil}

  public var clientVersion: Server_ClientVersion {
    get {return _clientVersion ?? Server_ClientVersion()}
    set {_clientVersion = newValue}
  }
  /// Returns true if `clientVersion` has been explicitly set.
  public var hasClientVersion: Bool {return self._clientVersion != nil}
  /// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
  public mutating func clearClientVersion() {self._clientVersion = nil}

  public var resource: String = String()

  public var deviceInfo: Server_DeviceInfo {
    get {return _deviceInfo ?? Server_DeviceInfo()}
    set {_deviceInfo = newValue}
  }
  /// Returns true if `deviceInfo` has been explicitly set.
  public var hasDeviceInfo: Bool {return self._deviceInfo != nil}
  /// Clears the value of `deviceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceInfo() {self._deviceInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientMode: Server_ClientMode? = nil
  fileprivate var _clientVersion: Server_ClientVersion? = nil
  fileprivate var _deviceInfo: Server_DeviceInfo? = nil
}

/// Left them to be string for now, will update these later as necessary.
public struct Server_AuthResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resultString: String = String()

  public var reasonString: String = String()

  public var propsHash: Data = Data()

  public var versionTtl: Int64 = 0

  public var result: Server_AuthResult.Result = .unknown

  public var reason: Server_AuthResult.Reason = .unknownReason

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case ok // = 1
    case spubMismatch // = 2
    case invalidClientVersion // = 3
    case invalidResource // = 4
    case accountDeleted // = 5
    case invalidUidOrPassword // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .ok
      case 2: self = .spubMismatch
      case 3: self = .invalidClientVersion
      case 4: self = .invalidResource
      case 5: self = .accountDeleted
      case 6: self = .invalidUidOrPassword
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .ok: return 1
      case .spubMismatch: return 2
      case .invalidClientVersion: return 3
      case .invalidResource: return 4
      case .accountDeleted: return 5
      case .invalidUidOrPassword: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_AuthResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AuthResult.Result] = [
    .unknown,
    .success,
    .failure,
  ]
}

extension Server_AuthResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AuthResult.Reason] = [
    .unknownReason,
    .ok,
    .spubMismatch,
    .invalidClientVersion,
    .invalidResource,
    .accountDeleted,
    .invalidUidOrPassword,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Invite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var result: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_InvitesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invites: [Server_Invite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_InvitesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invitesLeft: Int32 = 0

  public var timeUntilRefresh: Int64 = 0

  public var invites: [Server_Invite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MediaUrl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var get: String = String()

  public var put: String = String()

  public var patch: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UploadMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Int64 = 0

  public var url: Server_MediaUrl {
    get {return _url ?? Server_MediaUrl()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  public var downloadURL: String = String()

  public var type: Server_UploadMedia.TypeEnum = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case `default` // = 0
    case resumable // = 1
    case direct // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .resumable
      case 2: self = .direct
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .resumable: return 1
      case .direct: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _url: Server_MediaUrl? = nil
}

#if swift(>=4.2)

extension Server_UploadMedia.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UploadMedia.TypeEnum] = [
    .default,
    .resumable,
    .direct,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ChatStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var payload: Data = Data()

  public var encPayload: Data = Data()

  /// Temporarily added two payloads: one is for unencrypted and the other is encrypted.
  /// Clients currently send both of them at times.
  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int64 = 0

  public var senderName: String = String()

  public var senderPhone: String = String()

  public var mediaCounters: Server_MediaCounters {
    get {return _mediaCounters ?? Server_MediaCounters()}
    set {_mediaCounters = newValue}
  }
  /// Returns true if `mediaCounters` has been explicitly set.
  public var hasMediaCounters: Bool {return self._mediaCounters != nil}
  /// Clears the value of `mediaCounters`. Subsequent reads from it will return its default value.
  public mutating func clearMediaCounters() {self._mediaCounters = nil}

  public var chatType: Server_ChatStanza.ChatType = .chat

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String = String()

  public var senderClientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ChatType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case chatReaction // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .chatReaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .chatReaction: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _mediaCounters: Server_MediaCounters? = nil
}

#if swift(>=4.2)

extension Server_ChatStanza.ChatType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ChatStanza.ChatType] = [
    .chat,
    .chatReaction,
  ]
}

#endif  // swift(>=4.2)

/// clients should decrypt, report stats, and then drop this message
public struct Server_SilentChatStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatStanza: Server_ChatStanza {
    get {return _chatStanza ?? Server_ChatStanza()}
    set {_chatStanza = newValue}
  }
  /// Returns true if `chatStanza` has been explicitly set.
  public var hasChatStanza: Bool {return self._chatStanza != nil}
  /// Clears the value of `chatStanza`. Subsequent reads from it will return its default value.
  public mutating func clearChatStanza() {self._chatStanza = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatStanza: Server_ChatStanza? = nil
}

public struct Server_Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ErrorStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Name {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_EndOfQueue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var trimmed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HistoryResend {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var id: String = String()

  public var payload: Data = Data()

  /// Encrypted payload using the group feed channel.
  public var encPayload: Data = Data()

  /// Sent by the sender.
  public var senderStateBundles: [Server_SenderStateBundle] = []

  /// Meant for the receiver, selected by the server from `sender_state_bundles`.
  public var senderState: Server_SenderStateWithKeyInfo {
    get {return _senderState ?? Server_SenderStateWithKeyInfo()}
    set {_senderState = newValue}
  }
  /// Returns true if `senderState` has been explicitly set.
  public var hasSenderState: Bool {return self._senderState != nil}
  /// Clears the value of `senderState`. Subsequent reads from it will return its default value.
  public mutating func clearSenderState() {self._senderState = nil}

  public var audienceHash: Data = Data()

  /// Use >=16 for temporary elements since 1-15 encode smaller
  public var senderLogInfo: String = String()

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _senderState: Server_SenderStateWithKeyInfo? = nil
}

public struct Server_StunServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var port: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_TurnServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var host: String = String()

  public var port: UInt32 = 0

  public var username: String = String()

  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetCallServers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var peerUid: Int64 = 0

  public var callType: Server_CallType = .unknownType

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GetCallServersResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_GetCallServersResult.Result {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var stunServers: [Server_StunServer] {
    get {return _storage._stunServers}
    set {_uniqueStorage()._stunServers = newValue}
  }

  public var turnServers: [Server_TurnServer] {
    get {return _storage._turnServers}
    set {_uniqueStorage()._turnServers = newValue}
  }

  public var callConfig: Server_CallConfig {
    get {return _storage._callConfig ?? Server_CallConfig()}
    set {_uniqueStorage()._callConfig = newValue}
  }
  /// Returns true if `callConfig` has been explicitly set.
  public var hasCallConfig: Bool {return _storage._callConfig != nil}
  /// Clears the value of `callConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCallConfig() {_uniqueStorage()._callConfig = nil}

  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_GetCallServersResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GetCallServersResult.Result] = [
    .unknown,
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_CallCapabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// true if the initiator supports pre-answering the call
  public var preAnswer: Bool = false

  /// true if the initiator supports CallSdp ice restart
  public var sdpRestart: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_StartCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var peerUid: Int64 = 0

  public var callType: Server_CallType = .unknownType

  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return self._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {self._webrtcOffer = nil}

  public var rerequestCount: Int32 = 0

  public var callCapabilities: Server_CallCapabilities {
    get {return _callCapabilities ?? Server_CallCapabilities()}
    set {_callCapabilities = newValue}
  }
  /// Returns true if `callCapabilities` has been explicitly set.
  public var hasCallCapabilities: Bool {return self._callCapabilities != nil}
  /// Clears the value of `callCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCallCapabilities() {self._callCapabilities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcOffer: Server_WebRtcSessionDescription? = nil
  fileprivate var _callCapabilities: Server_CallCapabilities? = nil
}

public struct Server_StartCallResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_StartCallResult.Result = .unknown

  public var stunServers: [Server_StunServer] = []

  public var turnServers: [Server_TurnServer] = []

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1

    /// TODO:(nikola) we will likely have to add some sort of reasons here
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_StartCallResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_StartCallResult.Result] = [
    .unknown,
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_WebRtcSessionDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var encPayload: Data = Data()

  public var publicKey: Data = Data()

  public var oneTimePreKeyID: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_IncomingCallPush {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  public var callType: Server_CallType {
    get {return _storage._callType}
    set {_uniqueStorage()._callType = newValue}
  }

  public var stunServers: [Server_StunServer] {
    get {return _storage._stunServers}
    set {_uniqueStorage()._stunServers = newValue}
  }

  public var turnServers: [Server_TurnServer] {
    get {return _storage._turnServers}
    set {_uniqueStorage()._turnServers = newValue}
  }

  /// ts when message is generated by the server
  public var timestampMs: Int64 {
    get {return _storage._timestampMs}
    set {_uniqueStorage()._timestampMs = newValue}
  }

  public var callConfig: Server_CallConfig {
    get {return _storage._callConfig ?? Server_CallConfig()}
    set {_uniqueStorage()._callConfig = newValue}
  }
  /// Returns true if `callConfig` has been explicitly set.
  public var hasCallConfig: Bool {return _storage._callConfig != nil}
  /// Clears the value of `callConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCallConfig() {_uniqueStorage()._callConfig = nil}

  public var callCapabilities: Server_CallCapabilities {
    get {return _storage._callCapabilities ?? Server_CallCapabilities()}
    set {_uniqueStorage()._callCapabilities = newValue}
  }
  /// Returns true if `callCapabilities` has been explicitly set.
  public var hasCallCapabilities: Bool {return _storage._callCapabilities != nil}
  /// Clears the value of `callCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCallCapabilities() {_uniqueStorage()._callCapabilities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Server_IncomingCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String {
    get {return _storage._callID}
    set {_uniqueStorage()._callID = newValue}
  }

  public var callType: Server_CallType {
    get {return _storage._callType}
    set {_uniqueStorage()._callType = newValue}
  }

  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _storage._webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_uniqueStorage()._webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return _storage._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {_uniqueStorage()._webrtcOffer = nil}

  public var stunServers: [Server_StunServer] {
    get {return _storage._stunServers}
    set {_uniqueStorage()._stunServers = newValue}
  }

  public var turnServers: [Server_TurnServer] {
    get {return _storage._turnServers}
    set {_uniqueStorage()._turnServers = newValue}
  }

  /// ts when message is generated by the server
  public var timestampMs: Int64 {
    get {return _storage._timestampMs}
    set {_uniqueStorage()._timestampMs = newValue}
  }

  /// ts when the message is send to receiver
  public var serverSentTsMs: Int64 {
    get {return _storage._serverSentTsMs}
    set {_uniqueStorage()._serverSentTsMs = newValue}
  }

  public var callConfig: Server_CallConfig {
    get {return _storage._callConfig ?? Server_CallConfig()}
    set {_uniqueStorage()._callConfig = newValue}
  }
  /// Returns true if `callConfig` has been explicitly set.
  public var hasCallConfig: Bool {return _storage._callConfig != nil}
  /// Clears the value of `callConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCallConfig() {_uniqueStorage()._callConfig = nil}

  public var callCapabilities: Server_CallCapabilities {
    get {return _storage._callCapabilities ?? Server_CallCapabilities()}
    set {_uniqueStorage()._callCapabilities = newValue}
  }
  /// Returns true if `callCapabilities` has been explicitly set.
  public var hasCallCapabilities: Bool {return _storage._callCapabilities != nil}
  /// Clears the value of `callCapabilities`. Subsequent reads from it will return its default value.
  public mutating func clearCallCapabilities() {_uniqueStorage()._callCapabilities = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///RFC 4566 https://datatracker.ietf.org/doc/html/rfc4566#section-5.14
public struct Server_IceCandidate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var sdpMediaID: String = String()

  public var sdpMediaLineIndex: Int32 = 0

  public var sdp: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// send when the receiver of the calls starts ringing.
public struct Server_CallRinging {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var timestampMs: Int64 = 0

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
}

/// send before the AnswerCall so we can connect the PeerConnection
/// DEPRECATED send the answer with the pre-answer with the ringing message.
public struct Server_PreAnswerCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
}

public struct Server_AnswerCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var timestampMs: Int64 = 0

  /// used when both sides have pre-answer capabilites
  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return self._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {self._webrtcOffer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
  fileprivate var _webrtcOffer: Server_WebRtcSessionDescription? = nil
}

public struct Server_CallSdp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var sdpType: Server_CallSdp.SdpType = .unknown

  public var info: Server_WebRtcSessionDescription {
    get {return _info ?? Server_WebRtcSessionDescription()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SdpType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case offer // = 1
    case answer // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .offer
      case 2: self = .answer
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .offer: return 1
      case .answer: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _info: Server_WebRtcSessionDescription? = nil
}

#if swift(>=4.2)

extension Server_CallSdp.SdpType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_CallSdp.SdpType] = [
    .unknown,
    .offer,
    .answer,
  ]
}

#endif  // swift(>=4.2)

public struct Server_EndCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var reason: Server_EndCall.Reason = .unknown

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// receiver rejects the incoming call
    case reject // = 1

    /// receiver is in another call
    case busy // = 2

    /// sender or receiver times out the call after ringing for some time.
    case timeout // = 3

    /// initiator or receiver end the call.
    case callEnd // = 4

    /// initiator hangups before the call connects.
    case cancel // = 5

    /// receiver could not decrypt the content.
    case decryptionFailed // = 6

    /// receiver could not encrypt the answer.
    case encryptionFailed // = 7

    /// system errors or crashes.
    case systemError // = 8

    /// unsupported video calls.
    case videoUnsupported // = 9

    /// ice connection state error.
    case connectionError // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .reject
      case 2: self = .busy
      case 3: self = .timeout
      case 4: self = .callEnd
      case 5: self = .cancel
      case 6: self = .decryptionFailed
      case 7: self = .encryptionFailed
      case 8: self = .systemError
      case 9: self = .videoUnsupported
      case 10: self = .connectionError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .reject: return 1
      case .busy: return 2
      case .timeout: return 3
      case .callEnd: return 4
      case .cancel: return 5
      case .decryptionFailed: return 6
      case .encryptionFailed: return 7
      case .systemError: return 8
      case .videoUnsupported: return 9
      case .connectionError: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_EndCall.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_EndCall.Reason] = [
    .unknown,
    .reject,
    .busy,
    .timeout,
    .callEnd,
    .cancel,
    .decryptionFailed,
    .encryptionFailed,
    .systemError,
    .videoUnsupported,
    .connectionError,
  ]
}

#endif  // swift(>=4.2)

/// DEPRECATED
public struct Server_IceRestartOffer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var idx: Int32 = 0

  public var webrtcOffer: Server_WebRtcSessionDescription {
    get {return _webrtcOffer ?? Server_WebRtcSessionDescription()}
    set {_webrtcOffer = newValue}
  }
  /// Returns true if `webrtcOffer` has been explicitly set.
  public var hasWebrtcOffer: Bool {return self._webrtcOffer != nil}
  /// Clears the value of `webrtcOffer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcOffer() {self._webrtcOffer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcOffer: Server_WebRtcSessionDescription? = nil
}

/// DEPRECATED
public struct Server_IceRestartAnswer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var idx: Int32 = 0

  public var webrtcAnswer: Server_WebRtcSessionDescription {
    get {return _webrtcAnswer ?? Server_WebRtcSessionDescription()}
    set {_webrtcAnswer = newValue}
  }
  /// Returns true if `webrtcAnswer` has been explicitly set.
  public var hasWebrtcAnswer: Bool {return self._webrtcAnswer != nil}
  /// Clears the value of `webrtcAnswer`. Subsequent reads from it will return its default value.
  public mutating func clearWebrtcAnswer() {self._webrtcAnswer = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _webrtcAnswer: Server_WebRtcSessionDescription? = nil
}

public struct Server_HoldCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var hold: Bool = false

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MuteCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var mediaType: Server_MuteCall.MediaType = .audio

  public var muted: Bool = false

  public var timestampMs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MediaType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case audio // = 0
    case video // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .audio
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .audio
      case 1: self = .video
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .audio: return 0
      case .video: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MuteCall.MediaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MuteCall.MediaType] = [
    .audio,
    .video,
  ]
}

#endif  // swift(>=4.2)

public struct Server_CallConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var audioBitrateMax: Int32 = 0

  public var videoBitrateMax: Int32 = 0

  public var audioCodec: Int32 = 0

  public var videoCodec: Int32 = 0

  public var videoWidth: Int32 = 0

  public var videoHeight: Int32 = 0

  public var videoFps: Int32 = 0

  public var audioJitterBufferMaxPackets: Int32 = 0

  public var audioJitterBufferFastAccelerate: Bool = false

  public var iceTransportPolicy: Server_CallConfig.IceTransportPolicy = .all

  public var iceRestartDelayMs: Int32 = 0

  public var pruneTurnPorts: Bool = false

  public var iceCandidatePoolSize: Int32 = 0

  public var iceBackupPingIntervalMs: Int32 = 0

  public var iceConnectionTimeoutMs: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum IceTransportPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case relay // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .relay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .relay: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_CallConfig.IceTransportPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_CallConfig.IceTransportPolicy] = [
    .all,
    .relay,
  ]
}

#endif  // swift(>=4.2)

/// External Sharing
public struct Server_OgTagInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var description_p: String = String()

  public var thumbnailURL: String = String()

  public var thumbnailWidth: Int32 = 0

  public var thumbnailHeight: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ExternalSharePost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_ExternalSharePost.Action = .store

  public var blobID: String = String()

  public var blob: Data = Data()

  public var expiresInSeconds: Int64 = 0

  public var ogTagInfo: Server_OgTagInfo {
    get {return _ogTagInfo ?? Server_OgTagInfo()}
    set {_ogTagInfo = newValue}
  }
  /// Returns true if `ogTagInfo` has been explicitly set.
  public var hasOgTagInfo: Bool {return self._ogTagInfo != nil}
  /// Clears the value of `ogTagInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOgTagInfo() {self._ogTagInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case store // = 0
    case delete // = 1
    case get // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .store
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .store
      case 1: self = .delete
      case 2: self = .get
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .store: return 0
      case .delete: return 1
      case .get: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _ogTagInfo: Server_OgTagInfo? = nil
}

#if swift(>=4.2)

extension Server_ExternalSharePost.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ExternalSharePost.Action] = [
    .store,
    .delete,
    .get,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ExternalSharePostContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var blob: Data = Data()

  public var ogTagInfo: Server_OgTagInfo {
    get {return _ogTagInfo ?? Server_OgTagInfo()}
    set {_ogTagInfo = newValue}
  }
  /// Returns true if `ogTagInfo` has been explicitly set.
  public var hasOgTagInfo: Bool {return self._ogTagInfo != nil}
  /// Clears the value of `ogTagInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOgTagInfo() {self._ogTagInfo = nil}

  public var name: String = String()

  public var avatarID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ogTagInfo: Server_OgTagInfo? = nil
}

public struct Server_WebClientInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_WebClientInfo.Action = .unknownAction

  public var staticKey: Data = Data()

  public var result: Server_WebClientInfo.Result = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownAction // = 0

    /// Used by web client
    case addKey // = 1

    /// Used by web client
    case isKeyAuthenticated // = 2

    /// Used by mobile client
    case authenticateKey // = 3

    /// Used by web client and mobile client
    case removeKey // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownAction
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownAction
      case 1: self = .addKey
      case 2: self = .isKeyAuthenticated
      case 3: self = .authenticateKey
      case 4: self = .removeKey
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownAction: return 0
      case .addKey: return 1
      case .isKeyAuthenticated: return 2
      case .authenticateKey: return 3
      case .removeKey: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case ok // = 1
    case authenticated // = 2
    case notAuthenticated // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .authenticated
      case 3: self = .notAuthenticated
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .authenticated: return 2
      case .notAuthenticated: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_WebClientInfo.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WebClientInfo.Action] = [
    .unknownAction,
    .addKey,
    .isKeyAuthenticated,
    .authenticateKey,
    .removeKey,
  ]
}

extension Server_WebClientInfo.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WebClientInfo.Result] = [
    .unknown,
    .ok,
    .authenticated,
    .notAuthenticated,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ReportUserContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ReportUserContent.TypeEnum = .unknownType

  public var uid: Int64 = 0

  public var contentID: String = String()

  public var reason: Server_ReportUserContent.Reason = .unknownReason

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case user // = 1
    case post // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .user
      case 2: self = .post
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .user: return 1
      case .post: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case dontLike // = 1
    case spam // = 2
    case violatesRules // = 3
    case other // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .dontLike
      case 2: self = .spam
      case 3: self = .violatesRules
      case 4: self = .other
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .dontLike: return 1
      case .spam: return 2
      case .violatesRules: return 3
      case .other: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ReportUserContent.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ReportUserContent.TypeEnum] = [
    .unknownType,
    .user,
    .post,
  ]
}

extension Server_ReportUserContent.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ReportUserContent.Reason] = [
    .unknownReason,
    .dontLike,
    .spam,
    .violatesRules,
    .other,
  ]
}

#endif  // swift(>=4.2)

public struct Server_WebStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Used to identify the user. Must be set on every packet exchanged
  public var staticKey: Data = Data()

  /// between mobile and web client.
  public var payload: Server_WebStanza.OneOf_Payload? = nil

  /// Noise encrypted content
  public var content: Data {
    get {
      if case .content(let v)? = payload {return v}
      return Data()
    }
    set {payload = .content(newValue)}
  }

  public var noiseMessage: Server_NoiseMessage {
    get {
      if case .noiseMessage(let v)? = payload {return v}
      return Server_NoiseMessage()
    }
    set {payload = .noiseMessage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// between mobile and web client.
  public enum OneOf_Payload: Equatable {
    /// Noise encrypted content
    case content(Data)
    case noiseMessage(Server_NoiseMessage)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_WebStanza.OneOf_Payload, rhs: Server_WebStanza.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.content, .content): return {
        guard case .content(let l) = lhs, case .content(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.noiseMessage, .noiseMessage): return {
        guard case .noiseMessage(let l) = lhs, case .noiseMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_ContentMissing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contentID: String = String()

  public var contentType: Server_ContentMissing.ContentType = .unknown

  /// ex: "HalloApp/Android0.127"
  public var senderClientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case chat // = 1

    /// For calls - WebRtcOffer and WebRtcAnswer packets include encrypted payloads.
    /// Clients will respond back with content-missing and end-call packet if the call is not active.
    case call // = 2
    case groupFeedPost // = 3
    case groupFeedComment // = 4
    case homeFeedPost // = 5
    case homeFeedComment // = 6
    case historyResend // = 7
    case groupHistory // = 8
    case chatReaction // = 9
    case groupCommentReaction // = 10
    case groupPostReaction // = 11
    case homeCommentReaction // = 12
    case homePostReaction // = 13
    case groupChat // = 14
    case groupChatReaction // = 15
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .chat
      case 2: self = .call
      case 3: self = .groupFeedPost
      case 4: self = .groupFeedComment
      case 5: self = .homeFeedPost
      case 6: self = .homeFeedComment
      case 7: self = .historyResend
      case 8: self = .groupHistory
      case 9: self = .chatReaction
      case 10: self = .groupCommentReaction
      case 11: self = .groupPostReaction
      case 12: self = .homeCommentReaction
      case 13: self = .homePostReaction
      case 14: self = .groupChat
      case 15: self = .groupChatReaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .chat: return 1
      case .call: return 2
      case .groupFeedPost: return 3
      case .groupFeedComment: return 4
      case .homeFeedPost: return 5
      case .homeFeedComment: return 6
      case .historyResend: return 7
      case .groupHistory: return 8
      case .chatReaction: return 9
      case .groupCommentReaction: return 10
      case .groupPostReaction: return 11
      case .homeCommentReaction: return 12
      case .homePostReaction: return 13
      case .groupChat: return 14
      case .groupChatReaction: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ContentMissing.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ContentMissing.ContentType] = [
    .unknown,
    .chat,
    .call,
    .groupFeedPost,
    .groupFeedComment,
    .homeFeedPost,
    .homeFeedComment,
    .historyResend,
    .groupHistory,
    .chatReaction,
    .groupCommentReaction,
    .groupPostReaction,
    .homeCommentReaction,
    .homePostReaction,
    .groupChat,
    .groupChatReaction,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MomentNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  /// Monotonically increasing id assigned to the notification by the server. This id is same
  /// for all users in one local time 24 hour period, e.g. local date Dec 3rd will have the
  /// same notification id for all the users.
  public var notificationID: Int64 = 0

  public var type: Server_MomentNotification.TypeEnum = .liveCamera

  public var prompt: String = String()

  /// default value will be false.
  public var hideBanner: Bool = false

  public var promptImage: Data = Data()

  /// Local date of the notification in the format: DD/MM/YYYY.
  public var date: String = String()

  /// reminder of the daily moment notification.
  public var reminder: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case liveCamera // = 0
    case textPost // = 1
    case promptPost // = 2
    case albumPost // = 3
    case albumDump // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .liveCamera
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .liveCamera
      case 1: self = .textPost
      case 2: self = .promptPost
      case 3: self = .albumPost
      case 4: self = .albumDump
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .liveCamera: return 0
      case .textPost: return 1
      case .promptPost: return 2
      case .albumPost: return 3
      case .albumDump: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MomentNotification.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MomentNotification.TypeEnum] = [
    .liveCamera,
    .textPost,
    .promptPost,
    .albumPost,
    .albumDump,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ArchiveRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ArchiveResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_ArchiveResult.Result = .unknownResult

  public var reason: Server_ArchiveResult.Reason = .unknownReason

  public var uid: Int64 = 0

  public var posts: [Server_Post] = []

  /// Starting date of archive (may be earlier than any posts) in DD/MM/YYYY format
  public var startDate: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case ok // = 1
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case invalidUser // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .invalidUser
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .invalidUser: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ArchiveResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ArchiveResult.Result] = [
    .unknownResult,
    .ok,
    .fail,
  ]
}

extension Server_ArchiveResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ArchiveResult.Reason] = [
    .unknownReason,
    .invalidUser,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Iq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: Server_Iq.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var uploadMedia: Server_UploadMedia {
    get {
      if case .uploadMedia(let v)? = _storage._payload {return v}
      return Server_UploadMedia()
    }
    set {_uniqueStorage()._payload = .uploadMedia(newValue)}
  }

  public var contactList: Server_ContactList {
    get {
      if case .contactList(let v)? = _storage._payload {return v}
      return Server_ContactList()
    }
    set {_uniqueStorage()._payload = .contactList(newValue)}
  }

  public var uploadAvatar: Server_UploadAvatar {
    get {
      if case .uploadAvatar(let v)? = _storage._payload {return v}
      return Server_UploadAvatar()
    }
    set {_uniqueStorage()._payload = .uploadAvatar(newValue)}
  }

  public var avatar: Server_Avatar {
    get {
      if case .avatar(let v)? = _storage._payload {return v}
      return Server_Avatar()
    }
    set {_uniqueStorage()._payload = .avatar(newValue)}
  }

  public var avatars: Server_Avatars {
    get {
      if case .avatars(let v)? = _storage._payload {return v}
      return Server_Avatars()
    }
    set {_uniqueStorage()._payload = .avatars(newValue)}
  }

  public var clientMode: Server_ClientMode {
    get {
      if case .clientMode(let v)? = _storage._payload {return v}
      return Server_ClientMode()
    }
    set {_uniqueStorage()._payload = .clientMode(newValue)}
  }

  public var clientVersion: Server_ClientVersion {
    get {
      if case .clientVersion(let v)? = _storage._payload {return v}
      return Server_ClientVersion()
    }
    set {_uniqueStorage()._payload = .clientVersion(newValue)}
  }

  public var pushRegister: Server_PushRegister {
    get {
      if case .pushRegister(let v)? = _storage._payload {return v}
      return Server_PushRegister()
    }
    set {_uniqueStorage()._payload = .pushRegister(newValue)}
  }

  public var whisperKeys: Server_WhisperKeys {
    get {
      if case .whisperKeys(let v)? = _storage._payload {return v}
      return Server_WhisperKeys()
    }
    set {_uniqueStorage()._payload = .whisperKeys(newValue)}
  }

  public var ping: Server_Ping {
    get {
      if case .ping(let v)? = _storage._payload {return v}
      return Server_Ping()
    }
    set {_uniqueStorage()._payload = .ping(newValue)}
  }

  public var feedItem: Server_FeedItem {
    get {
      if case .feedItem(let v)? = _storage._payload {return v}
      return Server_FeedItem()
    }
    set {_uniqueStorage()._payload = .feedItem(newValue)}
  }

  public var privacyList: Server_PrivacyList {
    get {
      if case .privacyList(let v)? = _storage._payload {return v}
      return Server_PrivacyList()
    }
    set {_uniqueStorage()._payload = .privacyList(newValue)}
  }

  public var privacyLists: Server_PrivacyLists {
    get {
      if case .privacyLists(let v)? = _storage._payload {return v}
      return Server_PrivacyLists()
    }
    set {_uniqueStorage()._payload = .privacyLists(newValue)}
  }

  public var groupStanza: Server_GroupStanza {
    get {
      if case .groupStanza(let v)? = _storage._payload {return v}
      return Server_GroupStanza()
    }
    set {_uniqueStorage()._payload = .groupStanza(newValue)}
  }

  public var groupsStanza: Server_GroupsStanza {
    get {
      if case .groupsStanza(let v)? = _storage._payload {return v}
      return Server_GroupsStanza()
    }
    set {_uniqueStorage()._payload = .groupsStanza(newValue)}
  }

  public var clientLog: Server_ClientLog {
    get {
      if case .clientLog(let v)? = _storage._payload {return v}
      return Server_ClientLog()
    }
    set {_uniqueStorage()._payload = .clientLog(newValue)}
  }

  public var name: Server_Name {
    get {
      if case .name(let v)? = _storage._payload {return v}
      return Server_Name()
    }
    set {_uniqueStorage()._payload = .name(newValue)}
  }

  public var errorStanza: Server_ErrorStanza {
    get {
      if case .errorStanza(let v)? = _storage._payload {return v}
      return Server_ErrorStanza()
    }
    set {_uniqueStorage()._payload = .errorStanza(newValue)}
  }

  public var props: Server_Props {
    get {
      if case .props(let v)? = _storage._payload {return v}
      return Server_Props()
    }
    set {_uniqueStorage()._payload = .props(newValue)}
  }

  public var invitesRequest: Server_InvitesRequest {
    get {
      if case .invitesRequest(let v)? = _storage._payload {return v}
      return Server_InvitesRequest()
    }
    set {_uniqueStorage()._payload = .invitesRequest(newValue)}
  }

  public var invitesResponse: Server_InvitesResponse {
    get {
      if case .invitesResponse(let v)? = _storage._payload {return v}
      return Server_InvitesResponse()
    }
    set {_uniqueStorage()._payload = .invitesResponse(newValue)}
  }

  public var notificationPrefs: Server_NotificationPrefs {
    get {
      if case .notificationPrefs(let v)? = _storage._payload {return v}
      return Server_NotificationPrefs()
    }
    set {_uniqueStorage()._payload = .notificationPrefs(newValue)}
  }

  public var groupFeedItem: Server_GroupFeedItem {
    get {
      if case .groupFeedItem(let v)? = _storage._payload {return v}
      return Server_GroupFeedItem()
    }
    set {_uniqueStorage()._payload = .groupFeedItem(newValue)}
  }

  public var groupAvatar: Server_UploadGroupAvatar {
    get {
      if case .groupAvatar(let v)? = _storage._payload {return v}
      return Server_UploadGroupAvatar()
    }
    set {_uniqueStorage()._payload = .groupAvatar(newValue)}
  }

  public var deleteAccount: Server_DeleteAccount {
    get {
      if case .deleteAccount(let v)? = _storage._payload {return v}
      return Server_DeleteAccount()
    }
    set {_uniqueStorage()._payload = .deleteAccount(newValue)}
  }

  public var groupInviteLink: Server_GroupInviteLink {
    get {
      if case .groupInviteLink(let v)? = _storage._payload {return v}
      return Server_GroupInviteLink()
    }
    set {_uniqueStorage()._payload = .groupInviteLink(newValue)}
  }

  public var historyResend: Server_HistoryResend {
    get {
      if case .historyResend(let v)? = _storage._payload {return v}
      return Server_HistoryResend()
    }
    set {_uniqueStorage()._payload = .historyResend(newValue)}
  }

  public var exportData: Server_ExportData {
    get {
      if case .exportData(let v)? = _storage._payload {return v}
      return Server_ExportData()
    }
    set {_uniqueStorage()._payload = .exportData(newValue)}
  }

  public var contactSyncError: Server_ContactSyncError {
    get {
      if case .contactSyncError(let v)? = _storage._payload {return v}
      return Server_ContactSyncError()
    }
    set {_uniqueStorage()._payload = .contactSyncError(newValue)}
  }

  /// only for sms_app gateway use
  public var clientOtpRequest: Server_ClientOtpRequest {
    get {
      if case .clientOtpRequest(let v)? = _storage._payload {return v}
      return Server_ClientOtpRequest()
    }
    set {_uniqueStorage()._payload = .clientOtpRequest(newValue)}
  }

  /// only for sms_app gateway use
  public var clientOtpResponse: Server_ClientOtpResponse {
    get {
      if case .clientOtpResponse(let v)? = _storage._payload {return v}
      return Server_ClientOtpResponse()
    }
    set {_uniqueStorage()._payload = .clientOtpResponse(newValue)}
  }

  public var whisperKeysCollection: Server_WhisperKeysCollection {
    get {
      if case .whisperKeysCollection(let v)? = _storage._payload {return v}
      return Server_WhisperKeysCollection()
    }
    set {_uniqueStorage()._payload = .whisperKeysCollection(newValue)}
  }

  public var getCallServers: Server_GetCallServers {
    get {
      if case .getCallServers(let v)? = _storage._payload {return v}
      return Server_GetCallServers()
    }
    set {_uniqueStorage()._payload = .getCallServers(newValue)}
  }

  public var getCallServersResult: Server_GetCallServersResult {
    get {
      if case .getCallServersResult(let v)? = _storage._payload {return v}
      return Server_GetCallServersResult()
    }
    set {_uniqueStorage()._payload = .getCallServersResult(newValue)}
  }

  public var startCall: Server_StartCall {
    get {
      if case .startCall(let v)? = _storage._payload {return v}
      return Server_StartCall()
    }
    set {_uniqueStorage()._payload = .startCall(newValue)}
  }

  public var startCallResult: Server_StartCallResult {
    get {
      if case .startCallResult(let v)? = _storage._payload {return v}
      return Server_StartCallResult()
    }
    set {_uniqueStorage()._payload = .startCallResult(newValue)}
  }

  public var truncWhisperKeysCollection: Server_TruncWhisperKeysCollection {
    get {
      if case .truncWhisperKeysCollection(let v)? = _storage._payload {return v}
      return Server_TruncWhisperKeysCollection()
    }
    set {_uniqueStorage()._payload = .truncWhisperKeysCollection(newValue)}
  }

  public var externalSharePost: Server_ExternalSharePost {
    get {
      if case .externalSharePost(let v)? = _storage._payload {return v}
      return Server_ExternalSharePost()
    }
    set {_uniqueStorage()._payload = .externalSharePost(newValue)}
  }

  public var externalSharePostContainer: Server_ExternalSharePostContainer {
    get {
      if case .externalSharePostContainer(let v)? = _storage._payload {return v}
      return Server_ExternalSharePostContainer()
    }
    set {_uniqueStorage()._payload = .externalSharePostContainer(newValue)}
  }

  public var webClientInfo: Server_WebClientInfo {
    get {
      if case .webClientInfo(let v)? = _storage._payload {return v}
      return Server_WebClientInfo()
    }
    set {_uniqueStorage()._payload = .webClientInfo(newValue)}
  }

  public var reportUserContent: Server_ReportUserContent {
    get {
      if case .reportUserContent(let v)? = _storage._payload {return v}
      return Server_ReportUserContent()
    }
    set {_uniqueStorage()._payload = .reportUserContent(newValue)}
  }

  public var publicFeedRequest: Server_PublicFeedRequest {
    get {
      if case .publicFeedRequest(let v)? = _storage._payload {return v}
      return Server_PublicFeedRequest()
    }
    set {_uniqueStorage()._payload = .publicFeedRequest(newValue)}
  }

  public var publicFeedResponse: Server_PublicFeedResponse {
    get {
      if case .publicFeedResponse(let v)? = _storage._payload {return v}
      return Server_PublicFeedResponse()
    }
    set {_uniqueStorage()._payload = .publicFeedResponse(newValue)}
  }

  public var relationshipRequest: Server_RelationshipRequest {
    get {
      if case .relationshipRequest(let v)? = _storage._payload {return v}
      return Server_RelationshipRequest()
    }
    set {_uniqueStorage()._payload = .relationshipRequest(newValue)}
  }

  public var relationshipResponse: Server_RelationshipResponse {
    get {
      if case .relationshipResponse(let v)? = _storage._payload {return v}
      return Server_RelationshipResponse()
    }
    set {_uniqueStorage()._payload = .relationshipResponse(newValue)}
  }

  public var relationshipList: Server_RelationshipList {
    get {
      if case .relationshipList(let v)? = _storage._payload {return v}
      return Server_RelationshipList()
    }
    set {_uniqueStorage()._payload = .relationshipList(newValue)}
  }

  public var usernameRequest: Server_UsernameRequest {
    get {
      if case .usernameRequest(let v)? = _storage._payload {return v}
      return Server_UsernameRequest()
    }
    set {_uniqueStorage()._payload = .usernameRequest(newValue)}
  }

  public var usernameResponse: Server_UsernameResponse {
    get {
      if case .usernameResponse(let v)? = _storage._payload {return v}
      return Server_UsernameResponse()
    }
    set {_uniqueStorage()._payload = .usernameResponse(newValue)}
  }

  public var searchRequest: Server_SearchRequest {
    get {
      if case .searchRequest(let v)? = _storage._payload {return v}
      return Server_SearchRequest()
    }
    set {_uniqueStorage()._payload = .searchRequest(newValue)}
  }

  public var searchResponse: Server_SearchResponse {
    get {
      if case .searchResponse(let v)? = _storage._payload {return v}
      return Server_SearchResponse()
    }
    set {_uniqueStorage()._payload = .searchResponse(newValue)}
  }

  public var followSuggestionsRequest: Server_FollowSuggestionsRequest {
    get {
      if case .followSuggestionsRequest(let v)? = _storage._payload {return v}
      return Server_FollowSuggestionsRequest()
    }
    set {_uniqueStorage()._payload = .followSuggestionsRequest(newValue)}
  }

  public var followSuggestionsResponse: Server_FollowSuggestionsResponse {
    get {
      if case .followSuggestionsResponse(let v)? = _storage._payload {return v}
      return Server_FollowSuggestionsResponse()
    }
    set {_uniqueStorage()._payload = .followSuggestionsResponse(newValue)}
  }

  public var setLinkRequest: Server_SetLinkRequest {
    get {
      if case .setLinkRequest(let v)? = _storage._payload {return v}
      return Server_SetLinkRequest()
    }
    set {_uniqueStorage()._payload = .setLinkRequest(newValue)}
  }

  public var setLinkResult: Server_SetLinkResult {
    get {
      if case .setLinkResult(let v)? = _storage._payload {return v}
      return Server_SetLinkResult()
    }
    set {_uniqueStorage()._payload = .setLinkResult(newValue)}
  }

  public var setBioRequest: Server_SetBioRequest {
    get {
      if case .setBioRequest(let v)? = _storage._payload {return v}
      return Server_SetBioRequest()
    }
    set {_uniqueStorage()._payload = .setBioRequest(newValue)}
  }

  public var setBioResult: Server_SetBioResult {
    get {
      if case .setBioResult(let v)? = _storage._payload {return v}
      return Server_SetBioResult()
    }
    set {_uniqueStorage()._payload = .setBioResult(newValue)}
  }

  public var userProfileRequest: Server_UserProfileRequest {
    get {
      if case .userProfileRequest(let v)? = _storage._payload {return v}
      return Server_UserProfileRequest()
    }
    set {_uniqueStorage()._payload = .userProfileRequest(newValue)}
  }

  public var userProfileResult: Server_UserProfileResult {
    get {
      if case .userProfileResult(let v)? = _storage._payload {return v}
      return Server_UserProfileResult()
    }
    set {_uniqueStorage()._payload = .userProfileResult(newValue)}
  }

  public var postMetricsRequest: Server_PostMetricsRequest {
    get {
      if case .postMetricsRequest(let v)? = _storage._payload {return v}
      return Server_PostMetricsRequest()
    }
    set {_uniqueStorage()._payload = .postMetricsRequest(newValue)}
  }

  public var postMetricsResult: Server_PostMetricsResult {
    get {
      if case .postMetricsResult(let v)? = _storage._payload {return v}
      return Server_PostMetricsResult()
    }
    set {_uniqueStorage()._payload = .postMetricsResult(newValue)}
  }

  public var aiImageRequest: Server_AiImageRequest {
    get {
      if case .aiImageRequest(let v)? = _storage._payload {return v}
      return Server_AiImageRequest()
    }
    set {_uniqueStorage()._payload = .aiImageRequest(newValue)}
  }

  public var aiImageResult: Server_AiImageResult {
    get {
      if case .aiImageResult(let v)? = _storage._payload {return v}
      return Server_AiImageResult()
    }
    set {_uniqueStorage()._payload = .aiImageResult(newValue)}
  }

  public var archiveRequest: Server_ArchiveRequest {
    get {
      if case .archiveRequest(let v)? = _storage._payload {return v}
      return Server_ArchiveRequest()
    }
    set {_uniqueStorage()._payload = .archiveRequest(newValue)}
  }

  public var archiveResult: Server_ArchiveResult {
    get {
      if case .archiveResult(let v)? = _storage._payload {return v}
      return Server_ArchiveResult()
    }
    set {_uniqueStorage()._payload = .archiveResult(newValue)}
  }

  public var postSubscriptionRequest: Server_PostSubscriptionRequest {
    get {
      if case .postSubscriptionRequest(let v)? = _storage._payload {return v}
      return Server_PostSubscriptionRequest()
    }
    set {_uniqueStorage()._payload = .postSubscriptionRequest(newValue)}
  }

  public var postSubscriptionResponse: Server_PostSubscriptionResponse {
    get {
      if case .postSubscriptionResponse(let v)? = _storage._payload {return v}
      return Server_PostSubscriptionResponse()
    }
    set {_uniqueStorage()._payload = .postSubscriptionResponse(newValue)}
  }

  public var geoTagRequest: Server_GeoTagRequest {
    get {
      if case .geoTagRequest(let v)? = _storage._payload {return v}
      return Server_GeoTagRequest()
    }
    set {_uniqueStorage()._payload = .geoTagRequest(newValue)}
  }

  public var geoTagResponse: Server_GeoTagResponse {
    get {
      if case .geoTagResponse(let v)? = _storage._payload {return v}
      return Server_GeoTagResponse()
    }
    set {_uniqueStorage()._payload = .geoTagResponse(newValue)}
  }

  public var registerRequest: Server_RegisterRequest {
    get {
      if case .registerRequest(let v)? = _storage._payload {return v}
      return Server_RegisterRequest()
    }
    set {_uniqueStorage()._payload = .registerRequest(newValue)}
  }

  public var registerResponse: Server_RegisterResponse {
    get {
      if case .registerResponse(let v)? = _storage._payload {return v}
      return Server_RegisterResponse()
    }
    set {_uniqueStorage()._payload = .registerResponse(newValue)}
  }

  public var halloappSearchRequest: Server_HalloappSearchRequest {
    get {
      if case .halloappSearchRequest(let v)? = _storage._payload {return v}
      return Server_HalloappSearchRequest()
    }
    set {_uniqueStorage()._payload = .halloappSearchRequest(newValue)}
  }

  public var halloappSearchResponse: Server_HalloappSearchResponse {
    get {
      if case .halloappSearchResponse(let v)? = _storage._payload {return v}
      return Server_HalloappSearchResponse()
    }
    set {_uniqueStorage()._payload = .halloappSearchResponse(newValue)}
  }

  public var friendshipRequest: Server_FriendshipRequest {
    get {
      if case .friendshipRequest(let v)? = _storage._payload {return v}
      return Server_FriendshipRequest()
    }
    set {_uniqueStorage()._payload = .friendshipRequest(newValue)}
  }

  public var friendshipResponse: Server_FriendshipResponse {
    get {
      if case .friendshipResponse(let v)? = _storage._payload {return v}
      return Server_FriendshipResponse()
    }
    set {_uniqueStorage()._payload = .friendshipResponse(newValue)}
  }

  public var friendListRequest: Server_FriendListRequest {
    get {
      if case .friendListRequest(let v)? = _storage._payload {return v}
      return Server_FriendListRequest()
    }
    set {_uniqueStorage()._payload = .friendListRequest(newValue)}
  }

  public var friendListResponse: Server_FriendListResponse {
    get {
      if case .friendListResponse(let v)? = _storage._payload {return v}
      return Server_FriendListResponse()
    }
    set {_uniqueStorage()._payload = .friendListResponse(newValue)}
  }

  public var album: Server_Album {
    get {
      if case .album(let v)? = _storage._payload {return v}
      return Server_Album()
    }
    set {_uniqueStorage()._payload = .album(newValue)}
  }

  public var albumResult: Server_AlbumResult {
    get {
      if case .albumResult(let v)? = _storage._payload {return v}
      return Server_AlbumResult()
    }
    set {_uniqueStorage()._payload = .albumResult(newValue)}
  }

  public var getAlbums: Server_GetAlbums {
    get {
      if case .getAlbums(let v)? = _storage._payload {return v}
      return Server_GetAlbums()
    }
    set {_uniqueStorage()._payload = .getAlbums(newValue)}
  }

  public var halloappProfileRequest: Server_HalloappProfileRequest {
    get {
      if case .halloappProfileRequest(let v)? = _storage._payload {return v}
      return Server_HalloappProfileRequest()
    }
    set {_uniqueStorage()._payload = .halloappProfileRequest(newValue)}
  }

  public var hallaoppProfileResult: Server_HalloappProfileResult {
    get {
      if case .hallaoppProfileResult(let v)? = _storage._payload {return v}
      return Server_HalloappProfileResult()
    }
    set {_uniqueStorage()._payload = .hallaoppProfileResult(newValue)}
  }

  public var reverseGeocodeRequest: Server_ReverseGeocodeRequest {
    get {
      if case .reverseGeocodeRequest(let v)? = _storage._payload {return v}
      return Server_ReverseGeocodeRequest()
    }
    set {_uniqueStorage()._payload = .reverseGeocodeRequest(newValue)}
  }

  public var reverseGeocodeResult: Server_ReverseGeocodeResult {
    get {
      if case .reverseGeocodeResult(let v)? = _storage._payload {return v}
      return Server_ReverseGeocodeResult()
    }
    set {_uniqueStorage()._payload = .reverseGeocodeResult(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case uploadMedia(Server_UploadMedia)
    case contactList(Server_ContactList)
    case uploadAvatar(Server_UploadAvatar)
    case avatar(Server_Avatar)
    case avatars(Server_Avatars)
    case clientMode(Server_ClientMode)
    case clientVersion(Server_ClientVersion)
    case pushRegister(Server_PushRegister)
    case whisperKeys(Server_WhisperKeys)
    case ping(Server_Ping)
    case feedItem(Server_FeedItem)
    case privacyList(Server_PrivacyList)
    case privacyLists(Server_PrivacyLists)
    case groupStanza(Server_GroupStanza)
    case groupsStanza(Server_GroupsStanza)
    case clientLog(Server_ClientLog)
    case name(Server_Name)
    case errorStanza(Server_ErrorStanza)
    case props(Server_Props)
    case invitesRequest(Server_InvitesRequest)
    case invitesResponse(Server_InvitesResponse)
    case notificationPrefs(Server_NotificationPrefs)
    case groupFeedItem(Server_GroupFeedItem)
    case groupAvatar(Server_UploadGroupAvatar)
    case deleteAccount(Server_DeleteAccount)
    case groupInviteLink(Server_GroupInviteLink)
    case historyResend(Server_HistoryResend)
    case exportData(Server_ExportData)
    case contactSyncError(Server_ContactSyncError)
    /// only for sms_app gateway use
    case clientOtpRequest(Server_ClientOtpRequest)
    /// only for sms_app gateway use
    case clientOtpResponse(Server_ClientOtpResponse)
    case whisperKeysCollection(Server_WhisperKeysCollection)
    case getCallServers(Server_GetCallServers)
    case getCallServersResult(Server_GetCallServersResult)
    case startCall(Server_StartCall)
    case startCallResult(Server_StartCallResult)
    case truncWhisperKeysCollection(Server_TruncWhisperKeysCollection)
    case externalSharePost(Server_ExternalSharePost)
    case externalSharePostContainer(Server_ExternalSharePostContainer)
    case webClientInfo(Server_WebClientInfo)
    case reportUserContent(Server_ReportUserContent)
    case publicFeedRequest(Server_PublicFeedRequest)
    case publicFeedResponse(Server_PublicFeedResponse)
    case relationshipRequest(Server_RelationshipRequest)
    case relationshipResponse(Server_RelationshipResponse)
    case relationshipList(Server_RelationshipList)
    case usernameRequest(Server_UsernameRequest)
    case usernameResponse(Server_UsernameResponse)
    case searchRequest(Server_SearchRequest)
    case searchResponse(Server_SearchResponse)
    case followSuggestionsRequest(Server_FollowSuggestionsRequest)
    case followSuggestionsResponse(Server_FollowSuggestionsResponse)
    case setLinkRequest(Server_SetLinkRequest)
    case setLinkResult(Server_SetLinkResult)
    case setBioRequest(Server_SetBioRequest)
    case setBioResult(Server_SetBioResult)
    case userProfileRequest(Server_UserProfileRequest)
    case userProfileResult(Server_UserProfileResult)
    case postMetricsRequest(Server_PostMetricsRequest)
    case postMetricsResult(Server_PostMetricsResult)
    case aiImageRequest(Server_AiImageRequest)
    case aiImageResult(Server_AiImageResult)
    case archiveRequest(Server_ArchiveRequest)
    case archiveResult(Server_ArchiveResult)
    case postSubscriptionRequest(Server_PostSubscriptionRequest)
    case postSubscriptionResponse(Server_PostSubscriptionResponse)
    case geoTagRequest(Server_GeoTagRequest)
    case geoTagResponse(Server_GeoTagResponse)
    case registerRequest(Server_RegisterRequest)
    case registerResponse(Server_RegisterResponse)
    case halloappSearchRequest(Server_HalloappSearchRequest)
    case halloappSearchResponse(Server_HalloappSearchResponse)
    case friendshipRequest(Server_FriendshipRequest)
    case friendshipResponse(Server_FriendshipResponse)
    case friendListRequest(Server_FriendListRequest)
    case friendListResponse(Server_FriendListResponse)
    case album(Server_Album)
    case albumResult(Server_AlbumResult)
    case getAlbums(Server_GetAlbums)
    case halloappProfileRequest(Server_HalloappProfileRequest)
    case hallaoppProfileResult(Server_HalloappProfileResult)
    case reverseGeocodeRequest(Server_ReverseGeocodeRequest)
    case reverseGeocodeResult(Server_ReverseGeocodeResult)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Iq.OneOf_Payload, rhs: Server_Iq.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uploadMedia, .uploadMedia): return {
        guard case .uploadMedia(let l) = lhs, case .uploadMedia(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactList, .contactList): return {
        guard case .contactList(let l) = lhs, case .contactList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uploadAvatar, .uploadAvatar): return {
        guard case .uploadAvatar(let l) = lhs, case .uploadAvatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avatar, .avatar): return {
        guard case .avatar(let l) = lhs, case .avatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avatars, .avatars): return {
        guard case .avatars(let l) = lhs, case .avatars(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientMode, .clientMode): return {
        guard case .clientMode(let l) = lhs, case .clientMode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientVersion, .clientVersion): return {
        guard case .clientVersion(let l) = lhs, case .clientVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pushRegister, .pushRegister): return {
        guard case .pushRegister(let l) = lhs, case .pushRegister(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whisperKeys, .whisperKeys): return {
        guard case .whisperKeys(let l) = lhs, case .whisperKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feedItem, .feedItem): return {
        guard case .feedItem(let l) = lhs, case .feedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.privacyList, .privacyList): return {
        guard case .privacyList(let l) = lhs, case .privacyList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.privacyLists, .privacyLists): return {
        guard case .privacyLists(let l) = lhs, case .privacyLists(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupStanza, .groupStanza): return {
        guard case .groupStanza(let l) = lhs, case .groupStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupsStanza, .groupsStanza): return {
        guard case .groupsStanza(let l) = lhs, case .groupsStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientLog, .clientLog): return {
        guard case .clientLog(let l) = lhs, case .clientLog(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorStanza, .errorStanza): return {
        guard case .errorStanza(let l) = lhs, case .errorStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.props, .props): return {
        guard case .props(let l) = lhs, case .props(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invitesRequest, .invitesRequest): return {
        guard case .invitesRequest(let l) = lhs, case .invitesRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invitesResponse, .invitesResponse): return {
        guard case .invitesResponse(let l) = lhs, case .invitesResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationPrefs, .notificationPrefs): return {
        guard case .notificationPrefs(let l) = lhs, case .notificationPrefs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedItem, .groupFeedItem): return {
        guard case .groupFeedItem(let l) = lhs, case .groupFeedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupAvatar, .groupAvatar): return {
        guard case .groupAvatar(let l) = lhs, case .groupAvatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteAccount, .deleteAccount): return {
        guard case .deleteAccount(let l) = lhs, case .deleteAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupInviteLink, .groupInviteLink): return {
        guard case .groupInviteLink(let l) = lhs, case .groupInviteLink(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.historyResend, .historyResend): return {
        guard case .historyResend(let l) = lhs, case .historyResend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exportData, .exportData): return {
        guard case .exportData(let l) = lhs, case .exportData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactSyncError, .contactSyncError): return {
        guard case .contactSyncError(let l) = lhs, case .contactSyncError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientOtpRequest, .clientOtpRequest): return {
        guard case .clientOtpRequest(let l) = lhs, case .clientOtpRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientOtpResponse, .clientOtpResponse): return {
        guard case .clientOtpResponse(let l) = lhs, case .clientOtpResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whisperKeysCollection, .whisperKeysCollection): return {
        guard case .whisperKeysCollection(let l) = lhs, case .whisperKeysCollection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCallServers, .getCallServers): return {
        guard case .getCallServers(let l) = lhs, case .getCallServers(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getCallServersResult, .getCallServersResult): return {
        guard case .getCallServersResult(let l) = lhs, case .getCallServersResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startCall, .startCall): return {
        guard case .startCall(let l) = lhs, case .startCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startCallResult, .startCallResult): return {
        guard case .startCallResult(let l) = lhs, case .startCallResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.truncWhisperKeysCollection, .truncWhisperKeysCollection): return {
        guard case .truncWhisperKeysCollection(let l) = lhs, case .truncWhisperKeysCollection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalSharePost, .externalSharePost): return {
        guard case .externalSharePost(let l) = lhs, case .externalSharePost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalSharePostContainer, .externalSharePostContainer): return {
        guard case .externalSharePostContainer(let l) = lhs, case .externalSharePostContainer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webClientInfo, .webClientInfo): return {
        guard case .webClientInfo(let l) = lhs, case .webClientInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reportUserContent, .reportUserContent): return {
        guard case .reportUserContent(let l) = lhs, case .reportUserContent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicFeedRequest, .publicFeedRequest): return {
        guard case .publicFeedRequest(let l) = lhs, case .publicFeedRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicFeedResponse, .publicFeedResponse): return {
        guard case .publicFeedResponse(let l) = lhs, case .publicFeedResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.relationshipRequest, .relationshipRequest): return {
        guard case .relationshipRequest(let l) = lhs, case .relationshipRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.relationshipResponse, .relationshipResponse): return {
        guard case .relationshipResponse(let l) = lhs, case .relationshipResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.relationshipList, .relationshipList): return {
        guard case .relationshipList(let l) = lhs, case .relationshipList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.usernameRequest, .usernameRequest): return {
        guard case .usernameRequest(let l) = lhs, case .usernameRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.usernameResponse, .usernameResponse): return {
        guard case .usernameResponse(let l) = lhs, case .usernameResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.searchRequest, .searchRequest): return {
        guard case .searchRequest(let l) = lhs, case .searchRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.searchResponse, .searchResponse): return {
        guard case .searchResponse(let l) = lhs, case .searchResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.followSuggestionsRequest, .followSuggestionsRequest): return {
        guard case .followSuggestionsRequest(let l) = lhs, case .followSuggestionsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.followSuggestionsResponse, .followSuggestionsResponse): return {
        guard case .followSuggestionsResponse(let l) = lhs, case .followSuggestionsResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setLinkRequest, .setLinkRequest): return {
        guard case .setLinkRequest(let l) = lhs, case .setLinkRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setLinkResult, .setLinkResult): return {
        guard case .setLinkResult(let l) = lhs, case .setLinkResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setBioRequest, .setBioRequest): return {
        guard case .setBioRequest(let l) = lhs, case .setBioRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.setBioResult, .setBioResult): return {
        guard case .setBioResult(let l) = lhs, case .setBioResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userProfileRequest, .userProfileRequest): return {
        guard case .userProfileRequest(let l) = lhs, case .userProfileRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userProfileResult, .userProfileResult): return {
        guard case .userProfileResult(let l) = lhs, case .userProfileResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postMetricsRequest, .postMetricsRequest): return {
        guard case .postMetricsRequest(let l) = lhs, case .postMetricsRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postMetricsResult, .postMetricsResult): return {
        guard case .postMetricsResult(let l) = lhs, case .postMetricsResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aiImageRequest, .aiImageRequest): return {
        guard case .aiImageRequest(let l) = lhs, case .aiImageRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aiImageResult, .aiImageResult): return {
        guard case .aiImageResult(let l) = lhs, case .aiImageResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.archiveRequest, .archiveRequest): return {
        guard case .archiveRequest(let l) = lhs, case .archiveRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.archiveResult, .archiveResult): return {
        guard case .archiveResult(let l) = lhs, case .archiveResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postSubscriptionRequest, .postSubscriptionRequest): return {
        guard case .postSubscriptionRequest(let l) = lhs, case .postSubscriptionRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postSubscriptionResponse, .postSubscriptionResponse): return {
        guard case .postSubscriptionResponse(let l) = lhs, case .postSubscriptionResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.geoTagRequest, .geoTagRequest): return {
        guard case .geoTagRequest(let l) = lhs, case .geoTagRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.geoTagResponse, .geoTagResponse): return {
        guard case .geoTagResponse(let l) = lhs, case .geoTagResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.registerRequest, .registerRequest): return {
        guard case .registerRequest(let l) = lhs, case .registerRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.registerResponse, .registerResponse): return {
        guard case .registerResponse(let l) = lhs, case .registerResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.halloappSearchRequest, .halloappSearchRequest): return {
        guard case .halloappSearchRequest(let l) = lhs, case .halloappSearchRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.halloappSearchResponse, .halloappSearchResponse): return {
        guard case .halloappSearchResponse(let l) = lhs, case .halloappSearchResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.friendshipRequest, .friendshipRequest): return {
        guard case .friendshipRequest(let l) = lhs, case .friendshipRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.friendshipResponse, .friendshipResponse): return {
        guard case .friendshipResponse(let l) = lhs, case .friendshipResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.friendListRequest, .friendListRequest): return {
        guard case .friendListRequest(let l) = lhs, case .friendListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.friendListResponse, .friendListResponse): return {
        guard case .friendListResponse(let l) = lhs, case .friendListResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.album, .album): return {
        guard case .album(let l) = lhs, case .album(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.albumResult, .albumResult): return {
        guard case .albumResult(let l) = lhs, case .albumResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.getAlbums, .getAlbums): return {
        guard case .getAlbums(let l) = lhs, case .getAlbums(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.halloappProfileRequest, .halloappProfileRequest): return {
        guard case .halloappProfileRequest(let l) = lhs, case .halloappProfileRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hallaoppProfileResult, .hallaoppProfileResult): return {
        guard case .hallaoppProfileResult(let l) = lhs, case .hallaoppProfileResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reverseGeocodeRequest, .reverseGeocodeRequest): return {
        guard case .reverseGeocodeRequest(let l) = lhs, case .reverseGeocodeRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reverseGeocodeResult, .reverseGeocodeResult): return {
        guard case .reverseGeocodeResult(let l) = lhs, case .reverseGeocodeResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case set // = 1
    case result // = 2
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .set
      case 2: self = .result
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .set: return 1
      case .result: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_Iq.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Iq.TypeEnum] = [
    .get,
    .set,
    .result,
    .error,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Msg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: Server_Msg.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var toUid: Int64 {
    get {return _storage._toUid}
    set {_uniqueStorage()._toUid = newValue}
  }

  public var fromUid: Int64 {
    get {return _storage._fromUid}
    set {_uniqueStorage()._fromUid = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var contactList: Server_ContactList {
    get {
      if case .contactList(let v)? = _storage._payload {return v}
      return Server_ContactList()
    }
    set {_uniqueStorage()._payload = .contactList(newValue)}
  }

  public var avatar: Server_Avatar {
    get {
      if case .avatar(let v)? = _storage._payload {return v}
      return Server_Avatar()
    }
    set {_uniqueStorage()._payload = .avatar(newValue)}
  }

  public var whisperKeys: Server_WhisperKeys {
    get {
      if case .whisperKeys(let v)? = _storage._payload {return v}
      return Server_WhisperKeys()
    }
    set {_uniqueStorage()._payload = .whisperKeys(newValue)}
  }

  public var seenReceipt: Server_SeenReceipt {
    get {
      if case .seenReceipt(let v)? = _storage._payload {return v}
      return Server_SeenReceipt()
    }
    set {_uniqueStorage()._payload = .seenReceipt(newValue)}
  }

  public var deliveryReceipt: Server_DeliveryReceipt {
    get {
      if case .deliveryReceipt(let v)? = _storage._payload {return v}
      return Server_DeliveryReceipt()
    }
    set {_uniqueStorage()._payload = .deliveryReceipt(newValue)}
  }

  public var chatStanza: Server_ChatStanza {
    get {
      if case .chatStanza(let v)? = _storage._payload {return v}
      return Server_ChatStanza()
    }
    set {_uniqueStorage()._payload = .chatStanza(newValue)}
  }

  public var feedItem: Server_FeedItem {
    get {
      if case .feedItem(let v)? = _storage._payload {return v}
      return Server_FeedItem()
    }
    set {_uniqueStorage()._payload = .feedItem(newValue)}
  }

  public var feedItems: Server_FeedItems {
    get {
      if case .feedItems(let v)? = _storage._payload {return v}
      return Server_FeedItems()
    }
    set {_uniqueStorage()._payload = .feedItems(newValue)}
  }

  public var contactHash: Server_ContactHash {
    get {
      if case .contactHash(let v)? = _storage._payload {return v}
      return Server_ContactHash()
    }
    set {_uniqueStorage()._payload = .contactHash(newValue)}
  }

  public var groupStanza: Server_GroupStanza {
    get {
      if case .groupStanza(let v)? = _storage._payload {return v}
      return Server_GroupStanza()
    }
    set {_uniqueStorage()._payload = .groupStanza(newValue)}
  }

  /// deprecated, use group_chat_stanza
  public var groupChat: Server_GroupChat {
    get {
      if case .groupChat(let v)? = _storage._payload {return v}
      return Server_GroupChat()
    }
    set {_uniqueStorage()._payload = .groupChat(newValue)}
  }

  public var name: Server_Name {
    get {
      if case .name(let v)? = _storage._payload {return v}
      return Server_Name()
    }
    set {_uniqueStorage()._payload = .name(newValue)}
  }

  public var errorStanza: Server_ErrorStanza {
    get {
      if case .errorStanza(let v)? = _storage._payload {return v}
      return Server_ErrorStanza()
    }
    set {_uniqueStorage()._payload = .errorStanza(newValue)}
  }

  public var groupchatRetract: Server_GroupChatRetract {
    get {
      if case .groupchatRetract(let v)? = _storage._payload {return v}
      return Server_GroupChatRetract()
    }
    set {_uniqueStorage()._payload = .groupchatRetract(newValue)}
  }

  public var chatRetract: Server_ChatRetract {
    get {
      if case .chatRetract(let v)? = _storage._payload {return v}
      return Server_ChatRetract()
    }
    set {_uniqueStorage()._payload = .chatRetract(newValue)}
  }

  public var groupFeedItem: Server_GroupFeedItem {
    get {
      if case .groupFeedItem(let v)? = _storage._payload {return v}
      return Server_GroupFeedItem()
    }
    set {_uniqueStorage()._payload = .groupFeedItem(newValue)}
  }

  public var rerequest: Server_Rerequest {
    get {
      if case .rerequest(let v)? = _storage._payload {return v}
      return Server_Rerequest()
    }
    set {_uniqueStorage()._payload = .rerequest(newValue)}
  }

  public var silentChatStanza: Server_SilentChatStanza {
    get {
      if case .silentChatStanza(let v)? = _storage._payload {return v}
      return Server_SilentChatStanza()
    }
    set {_uniqueStorage()._payload = .silentChatStanza(newValue)}
  }

  public var groupFeedItems: Server_GroupFeedItems {
    get {
      if case .groupFeedItems(let v)? = _storage._payload {return v}
      return Server_GroupFeedItems()
    }
    set {_uniqueStorage()._payload = .groupFeedItems(newValue)}
  }

  public var endOfQueue: Server_EndOfQueue {
    get {
      if case .endOfQueue(let v)? = _storage._payload {return v}
      return Server_EndOfQueue()
    }
    set {_uniqueStorage()._payload = .endOfQueue(newValue)}
  }

  public var inviteeNotice: Server_InviteeNotice {
    get {
      if case .inviteeNotice(let v)? = _storage._payload {return v}
      return Server_InviteeNotice()
    }
    set {_uniqueStorage()._payload = .inviteeNotice(newValue)}
  }

  public var groupFeedRerequest: Server_GroupFeedRerequest {
    get {
      if case .groupFeedRerequest(let v)? = _storage._payload {return v}
      return Server_GroupFeedRerequest()
    }
    set {_uniqueStorage()._payload = .groupFeedRerequest(newValue)}
  }

  public var historyResend: Server_HistoryResend {
    get {
      if case .historyResend(let v)? = _storage._payload {return v}
      return Server_HistoryResend()
    }
    set {_uniqueStorage()._payload = .historyResend(newValue)}
  }

  public var playedReceipt: Server_PlayedReceipt {
    get {
      if case .playedReceipt(let v)? = _storage._payload {return v}
      return Server_PlayedReceipt()
    }
    set {_uniqueStorage()._payload = .playedReceipt(newValue)}
  }

  public var requestLogs: Server_RequestLogs {
    get {
      if case .requestLogs(let v)? = _storage._payload {return v}
      return Server_RequestLogs()
    }
    set {_uniqueStorage()._payload = .requestLogs(newValue)}
  }

  /// only for use with SMSApp clients
  public var wakeup: Server_WakeUp {
    get {
      if case .wakeup(let v)? = _storage._payload {return v}
      return Server_WakeUp()
    }
    set {_uniqueStorage()._payload = .wakeup(newValue)}
  }

  public var homeFeedRerequest: Server_HomeFeedRerequest {
    get {
      if case .homeFeedRerequest(let v)? = _storage._payload {return v}
      return Server_HomeFeedRerequest()
    }
    set {_uniqueStorage()._payload = .homeFeedRerequest(newValue)}
  }

  public var incomingCall: Server_IncomingCall {
    get {
      if case .incomingCall(let v)? = _storage._payload {return v}
      return Server_IncomingCall()
    }
    set {_uniqueStorage()._payload = .incomingCall(newValue)}
  }

  public var callRinging: Server_CallRinging {
    get {
      if case .callRinging(let v)? = _storage._payload {return v}
      return Server_CallRinging()
    }
    set {_uniqueStorage()._payload = .callRinging(newValue)}
  }

  public var answerCall: Server_AnswerCall {
    get {
      if case .answerCall(let v)? = _storage._payload {return v}
      return Server_AnswerCall()
    }
    set {_uniqueStorage()._payload = .answerCall(newValue)}
  }

  public var endCall: Server_EndCall {
    get {
      if case .endCall(let v)? = _storage._payload {return v}
      return Server_EndCall()
    }
    set {_uniqueStorage()._payload = .endCall(newValue)}
  }

  public var iceCandidate: Server_IceCandidate {
    get {
      if case .iceCandidate(let v)? = _storage._payload {return v}
      return Server_IceCandidate()
    }
    set {_uniqueStorage()._payload = .iceCandidate(newValue)}
  }

  /// only for server use
  public var marketingAlert: Server_MarketingAlert {
    get {
      if case .marketingAlert(let v)? = _storage._payload {return v}
      return Server_MarketingAlert()
    }
    set {_uniqueStorage()._payload = .marketingAlert(newValue)}
  }

  /// deprecated, use call_sdp
  public var iceRestartOffer: Server_IceRestartOffer {
    get {
      if case .iceRestartOffer(let v)? = _storage._payload {return v}
      return Server_IceRestartOffer()
    }
    set {_uniqueStorage()._payload = .iceRestartOffer(newValue)}
  }

  /// deprecated, use call_sdp
  public var iceRestartAnswer: Server_IceRestartAnswer {
    get {
      if case .iceRestartAnswer(let v)? = _storage._payload {return v}
      return Server_IceRestartAnswer()
    }
    set {_uniqueStorage()._payload = .iceRestartAnswer(newValue)}
  }

  public var groupFeedHistory: Server_GroupFeedHistory {
    get {
      if case .groupFeedHistory(let v)? = _storage._payload {return v}
      return Server_GroupFeedHistory()
    }
    set {_uniqueStorage()._payload = .groupFeedHistory(newValue)}
  }

  /// deprecated, set answer in ringing
  public var preAnswerCall: Server_PreAnswerCall {
    get {
      if case .preAnswerCall(let v)? = _storage._payload {return v}
      return Server_PreAnswerCall()
    }
    set {_uniqueStorage()._payload = .preAnswerCall(newValue)}
  }

  public var holdCall: Server_HoldCall {
    get {
      if case .holdCall(let v)? = _storage._payload {return v}
      return Server_HoldCall()
    }
    set {_uniqueStorage()._payload = .holdCall(newValue)}
  }

  public var muteCall: Server_MuteCall {
    get {
      if case .muteCall(let v)? = _storage._payload {return v}
      return Server_MuteCall()
    }
    set {_uniqueStorage()._payload = .muteCall(newValue)}
  }

  public var incomingCallPush: Server_IncomingCallPush {
    get {
      if case .incomingCallPush(let v)? = _storage._payload {return v}
      return Server_IncomingCallPush()
    }
    set {_uniqueStorage()._payload = .incomingCallPush(newValue)}
  }

  public var callSdp: Server_CallSdp {
    get {
      if case .callSdp(let v)? = _storage._payload {return v}
      return Server_CallSdp()
    }
    set {_uniqueStorage()._payload = .callSdp(newValue)}
  }

  public var webStanza: Server_WebStanza {
    get {
      if case .webStanza(let v)? = _storage._payload {return v}
      return Server_WebStanza()
    }
    set {_uniqueStorage()._payload = .webStanza(newValue)}
  }

  public var contentMissing: Server_ContentMissing {
    get {
      if case .contentMissing(let v)? = _storage._payload {return v}
      return Server_ContentMissing()
    }
    set {_uniqueStorage()._payload = .contentMissing(newValue)}
  }

  public var screenshotReceipt: Server_ScreenshotReceipt {
    get {
      if case .screenshotReceipt(let v)? = _storage._payload {return v}
      return Server_ScreenshotReceipt()
    }
    set {_uniqueStorage()._payload = .screenshotReceipt(newValue)}
  }

  public var savedReceipt: Server_SavedReceipt {
    get {
      if case .savedReceipt(let v)? = _storage._payload {return v}
      return Server_SavedReceipt()
    }
    set {_uniqueStorage()._payload = .savedReceipt(newValue)}
  }

  public var groupChatStanza: Server_GroupChatStanza {
    get {
      if case .groupChatStanza(let v)? = _storage._payload {return v}
      return Server_GroupChatStanza()
    }
    set {_uniqueStorage()._payload = .groupChatStanza(newValue)}
  }

  public var momentNotification: Server_MomentNotification {
    get {
      if case .momentNotification(let v)? = _storage._payload {return v}
      return Server_MomentNotification()
    }
    set {_uniqueStorage()._payload = .momentNotification(newValue)}
  }

  public var profileUpdate: Server_ProfileUpdate {
    get {
      if case .profileUpdate(let v)? = _storage._payload {return v}
      return Server_ProfileUpdate()
    }
    set {_uniqueStorage()._payload = .profileUpdate(newValue)}
  }

  public var publicFeedUpdate: Server_PublicFeedUpdate {
    get {
      if case .publicFeedUpdate(let v)? = _storage._payload {return v}
      return Server_PublicFeedUpdate()
    }
    set {_uniqueStorage()._payload = .publicFeedUpdate(newValue)}
  }

  public var aiImage: Server_AiImage {
    get {
      if case .aiImage(let v)? = _storage._payload {return v}
      return Server_AiImage()
    }
    set {_uniqueStorage()._payload = .aiImage(newValue)}
  }

  public var halloappProfileUpdate: Server_HalloappProfileUpdate {
    get {
      if case .halloappProfileUpdate(let v)? = _storage._payload {return v}
      return Server_HalloappProfileUpdate()
    }
    set {_uniqueStorage()._payload = .halloappProfileUpdate(newValue)}
  }

  public var album: Server_Album {
    get {
      if case .album(let v)? = _storage._payload {return v}
      return Server_Album()
    }
    set {_uniqueStorage()._payload = .album(newValue)}
  }

  public var friendListRequest: Server_FriendListRequest {
    get {
      if case .friendListRequest(let v)? = _storage._payload {return v}
      return Server_FriendListRequest()
    }
    set {_uniqueStorage()._payload = .friendListRequest(newValue)}
  }

  public var retryCount: Int32 {
    get {return _storage._retryCount}
    set {_uniqueStorage()._retryCount = newValue}
  }

  public var rerequestCount: Int32 {
    get {return _storage._rerequestCount}
    set {_uniqueStorage()._rerequestCount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case contactList(Server_ContactList)
    case avatar(Server_Avatar)
    case whisperKeys(Server_WhisperKeys)
    case seenReceipt(Server_SeenReceipt)
    case deliveryReceipt(Server_DeliveryReceipt)
    case chatStanza(Server_ChatStanza)
    case feedItem(Server_FeedItem)
    case feedItems(Server_FeedItems)
    case contactHash(Server_ContactHash)
    case groupStanza(Server_GroupStanza)
    /// deprecated, use group_chat_stanza
    case groupChat(Server_GroupChat)
    case name(Server_Name)
    case errorStanza(Server_ErrorStanza)
    case groupchatRetract(Server_GroupChatRetract)
    case chatRetract(Server_ChatRetract)
    case groupFeedItem(Server_GroupFeedItem)
    case rerequest(Server_Rerequest)
    case silentChatStanza(Server_SilentChatStanza)
    case groupFeedItems(Server_GroupFeedItems)
    case endOfQueue(Server_EndOfQueue)
    case inviteeNotice(Server_InviteeNotice)
    case groupFeedRerequest(Server_GroupFeedRerequest)
    case historyResend(Server_HistoryResend)
    case playedReceipt(Server_PlayedReceipt)
    case requestLogs(Server_RequestLogs)
    /// only for use with SMSApp clients
    case wakeup(Server_WakeUp)
    case homeFeedRerequest(Server_HomeFeedRerequest)
    case incomingCall(Server_IncomingCall)
    case callRinging(Server_CallRinging)
    case answerCall(Server_AnswerCall)
    case endCall(Server_EndCall)
    case iceCandidate(Server_IceCandidate)
    /// only for server use
    case marketingAlert(Server_MarketingAlert)
    /// deprecated, use call_sdp
    case iceRestartOffer(Server_IceRestartOffer)
    /// deprecated, use call_sdp
    case iceRestartAnswer(Server_IceRestartAnswer)
    case groupFeedHistory(Server_GroupFeedHistory)
    /// deprecated, set answer in ringing
    case preAnswerCall(Server_PreAnswerCall)
    case holdCall(Server_HoldCall)
    case muteCall(Server_MuteCall)
    case incomingCallPush(Server_IncomingCallPush)
    case callSdp(Server_CallSdp)
    case webStanza(Server_WebStanza)
    case contentMissing(Server_ContentMissing)
    case screenshotReceipt(Server_ScreenshotReceipt)
    case savedReceipt(Server_SavedReceipt)
    case groupChatStanza(Server_GroupChatStanza)
    case momentNotification(Server_MomentNotification)
    case profileUpdate(Server_ProfileUpdate)
    case publicFeedUpdate(Server_PublicFeedUpdate)
    case aiImage(Server_AiImage)
    case halloappProfileUpdate(Server_HalloappProfileUpdate)
    case album(Server_Album)
    case friendListRequest(Server_FriendListRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Msg.OneOf_Payload, rhs: Server_Msg.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contactList, .contactList): return {
        guard case .contactList(let l) = lhs, case .contactList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.avatar, .avatar): return {
        guard case .avatar(let l) = lhs, case .avatar(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.whisperKeys, .whisperKeys): return {
        guard case .whisperKeys(let l) = lhs, case .whisperKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seenReceipt, .seenReceipt): return {
        guard case .seenReceipt(let l) = lhs, case .seenReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deliveryReceipt, .deliveryReceipt): return {
        guard case .deliveryReceipt(let l) = lhs, case .deliveryReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatStanza, .chatStanza): return {
        guard case .chatStanza(let l) = lhs, case .chatStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feedItem, .feedItem): return {
        guard case .feedItem(let l) = lhs, case .feedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.feedItems, .feedItems): return {
        guard case .feedItems(let l) = lhs, case .feedItems(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactHash, .contactHash): return {
        guard case .contactHash(let l) = lhs, case .contactHash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupStanza, .groupStanza): return {
        guard case .groupStanza(let l) = lhs, case .groupStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupChat, .groupChat): return {
        guard case .groupChat(let l) = lhs, case .groupChat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorStanza, .errorStanza): return {
        guard case .errorStanza(let l) = lhs, case .errorStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupchatRetract, .groupchatRetract): return {
        guard case .groupchatRetract(let l) = lhs, case .groupchatRetract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatRetract, .chatRetract): return {
        guard case .chatRetract(let l) = lhs, case .chatRetract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedItem, .groupFeedItem): return {
        guard case .groupFeedItem(let l) = lhs, case .groupFeedItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rerequest, .rerequest): return {
        guard case .rerequest(let l) = lhs, case .rerequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.silentChatStanza, .silentChatStanza): return {
        guard case .silentChatStanza(let l) = lhs, case .silentChatStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedItems, .groupFeedItems): return {
        guard case .groupFeedItems(let l) = lhs, case .groupFeedItems(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endOfQueue, .endOfQueue): return {
        guard case .endOfQueue(let l) = lhs, case .endOfQueue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inviteeNotice, .inviteeNotice): return {
        guard case .inviteeNotice(let l) = lhs, case .inviteeNotice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedRerequest, .groupFeedRerequest): return {
        guard case .groupFeedRerequest(let l) = lhs, case .groupFeedRerequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.historyResend, .historyResend): return {
        guard case .historyResend(let l) = lhs, case .historyResend(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playedReceipt, .playedReceipt): return {
        guard case .playedReceipt(let l) = lhs, case .playedReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestLogs, .requestLogs): return {
        guard case .requestLogs(let l) = lhs, case .requestLogs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.wakeup, .wakeup): return {
        guard case .wakeup(let l) = lhs, case .wakeup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.homeFeedRerequest, .homeFeedRerequest): return {
        guard case .homeFeedRerequest(let l) = lhs, case .homeFeedRerequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.incomingCall, .incomingCall): return {
        guard case .incomingCall(let l) = lhs, case .incomingCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callRinging, .callRinging): return {
        guard case .callRinging(let l) = lhs, case .callRinging(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.answerCall, .answerCall): return {
        guard case .answerCall(let l) = lhs, case .answerCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endCall, .endCall): return {
        guard case .endCall(let l) = lhs, case .endCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceCandidate, .iceCandidate): return {
        guard case .iceCandidate(let l) = lhs, case .iceCandidate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.marketingAlert, .marketingAlert): return {
        guard case .marketingAlert(let l) = lhs, case .marketingAlert(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceRestartOffer, .iceRestartOffer): return {
        guard case .iceRestartOffer(let l) = lhs, case .iceRestartOffer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iceRestartAnswer, .iceRestartAnswer): return {
        guard case .iceRestartAnswer(let l) = lhs, case .iceRestartAnswer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupFeedHistory, .groupFeedHistory): return {
        guard case .groupFeedHistory(let l) = lhs, case .groupFeedHistory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preAnswerCall, .preAnswerCall): return {
        guard case .preAnswerCall(let l) = lhs, case .preAnswerCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.holdCall, .holdCall): return {
        guard case .holdCall(let l) = lhs, case .holdCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.muteCall, .muteCall): return {
        guard case .muteCall(let l) = lhs, case .muteCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.incomingCallPush, .incomingCallPush): return {
        guard case .incomingCallPush(let l) = lhs, case .incomingCallPush(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.callSdp, .callSdp): return {
        guard case .callSdp(let l) = lhs, case .callSdp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webStanza, .webStanza): return {
        guard case .webStanza(let l) = lhs, case .webStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contentMissing, .contentMissing): return {
        guard case .contentMissing(let l) = lhs, case .contentMissing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.screenshotReceipt, .screenshotReceipt): return {
        guard case .screenshotReceipt(let l) = lhs, case .screenshotReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.savedReceipt, .savedReceipt): return {
        guard case .savedReceipt(let l) = lhs, case .savedReceipt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupChatStanza, .groupChatStanza): return {
        guard case .groupChatStanza(let l) = lhs, case .groupChatStanza(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.momentNotification, .momentNotification): return {
        guard case .momentNotification(let l) = lhs, case .momentNotification(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profileUpdate, .profileUpdate): return {
        guard case .profileUpdate(let l) = lhs, case .profileUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.publicFeedUpdate, .publicFeedUpdate): return {
        guard case .publicFeedUpdate(let l) = lhs, case .publicFeedUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aiImage, .aiImage): return {
        guard case .aiImage(let l) = lhs, case .aiImage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.halloappProfileUpdate, .halloappProfileUpdate): return {
        guard case .halloappProfileUpdate(let l) = lhs, case .halloappProfileUpdate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.album, .album): return {
        guard case .album(let l) = lhs, case .album(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.friendListRequest, .friendListRequest): return {
        guard case .friendListRequest(let l) = lhs, case .friendListRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case error // = 1
    case groupchat // = 2
    case headline // = 3

    /// Not used yet.
    case chat // = 4
    case call // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .error
      case 2: self = .groupchat
      case 3: self = .headline
      case 4: self = .chat
      case 5: self = .call
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .error: return 1
      case .groupchat: return 2
      case .headline: return 3
      case .chat: return 4
      case .call: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_Msg.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Msg.TypeEnum] = [
    .normal,
    .error,
    .groupchat,
    .headline,
    .chat,
    .call,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Presence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: Server_Presence.TypeEnum = .available

  /// Clients must stop using this field.
  public var uid: Int64 = 0

  public var lastSeen: Int64 = 0

  public var toUid: Int64 = 0

  public var fromUid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case away // = 1
    case subscribe // = 2
    case unsubscribe // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .away
      case 2: self = .subscribe
      case 3: self = .unsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .away: return 1
      case .subscribe: return 2
      case .unsubscribe: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Presence.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Presence.TypeEnum] = [
    .available,
    .away,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ChatState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ChatState.TypeEnum = .available

  public var threadID: String = String()

  public var threadType: Server_ChatState.ThreadType = .chat

  public var fromUid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case typing // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .typing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .typing: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ThreadType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case groupChat // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .groupChat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .groupChat: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ChatState.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ChatState.TypeEnum] = [
    .available,
    .typing,
  ]
}

extension Server_ChatState.ThreadType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ChatState.ThreadType] = [
    .chat,
    .groupChat,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Ack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HaError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stanza: Server_Packet.OneOf_Stanza? = nil

  public var msg: Server_Msg {
    get {
      if case .msg(let v)? = stanza {return v}
      return Server_Msg()
    }
    set {stanza = .msg(newValue)}
  }

  public var iq: Server_Iq {
    get {
      if case .iq(let v)? = stanza {return v}
      return Server_Iq()
    }
    set {stanza = .iq(newValue)}
  }

  public var ack: Server_Ack {
    get {
      if case .ack(let v)? = stanza {return v}
      return Server_Ack()
    }
    set {stanza = .ack(newValue)}
  }

  public var presence: Server_Presence {
    get {
      if case .presence(let v)? = stanza {return v}
      return Server_Presence()
    }
    set {stanza = .presence(newValue)}
  }

  public var haError: Server_HaError {
    get {
      if case .haError(let v)? = stanza {return v}
      return Server_HaError()
    }
    set {stanza = .haError(newValue)}
  }

  public var chatState: Server_ChatState {
    get {
      if case .chatState(let v)? = stanza {return v}
      return Server_ChatState()
    }
    set {stanza = .chatState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Stanza: Equatable {
    case msg(Server_Msg)
    case iq(Server_Iq)
    case ack(Server_Ack)
    case presence(Server_Presence)
    case haError(Server_HaError)
    case chatState(Server_ChatState)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Packet.OneOf_Stanza, rhs: Server_Packet.OneOf_Stanza) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.msg, .msg): return {
        guard case .msg(let l) = lhs, case .msg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iq, .iq): return {
        guard case .iq(let l) = lhs, case .iq(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ack, .ack): return {
        guard case .ack(let l) = lhs, case .ack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.presence, .presence): return {
        guard case .presence(let l) = lhs, case .presence(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.haError, .haError): return {
        guard case .haError(let l) = lhs, case .haError(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chatState, .chatState): return {
        guard case .chatState(let l) = lhs, case .chatState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_UidElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_UidElement.Action = .add

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_UidElement.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UidElement.Action] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PhoneElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_PhoneElement.Action = .add

  public var phone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PhoneElement.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PhoneElement.Action] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PrivacyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_PrivacyList.TypeEnum = .all

  public var uidElements: [Server_UidElement] = []

  public var hash: Data = Data()

  public var phoneElements: [Server_PhoneElement] = []

  public var usingPhones: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case block // = 1
    case except // = 2
    case mute // = 3
    case only // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .block
      case 2: self = .except
      case 3: self = .mute
      case 4: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .block: return 1
      case .except: return 2
      case .mute: return 3
      case .only: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PrivacyList.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PrivacyList.TypeEnum] = [
    .all,
    .block,
    .except,
    .mute,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PrivacyLists {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeType: Server_PrivacyLists.TypeEnum = .all

  public var lists: [Server_PrivacyList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case block // = 1
    case except // = 2
    case only // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .block
      case 2: self = .except
      case 3: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .block: return 1
      case .except: return 2
      case .only: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PrivacyLists.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PrivacyLists.TypeEnum] = [
    .all,
    .block,
    .except,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PushToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenType: Server_PushToken.TokenType = .android

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TokenType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case android // = 0
    case ios // = 1
    case iosDev // = 2
    case iosAppclip // = 3
    case iosVoip // = 4
    case androidHuawei // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .android
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .android
      case 1: self = .ios
      case 2: self = .iosDev
      case 3: self = .iosAppclip
      case 4: self = .iosVoip
      case 5: self = .androidHuawei
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .android: return 0
      case .ios: return 1
      case .iosDev: return 2
      case .iosAppclip: return 3
      case .iosVoip: return 4
      case .androidHuawei: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PushToken.TokenType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PushToken.TokenType] = [
    .android,
    .ios,
    .iosDev,
    .iosAppclip,
    .iosVoip,
    .androidHuawei,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PushRegister {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pushToken: Server_PushToken {
    get {return _pushToken ?? Server_PushToken()}
    set {_pushToken = newValue}
  }
  /// Returns true if `pushToken` has been explicitly set.
  public var hasPushToken: Bool {return self._pushToken != nil}
  /// Clears the value of `pushToken`. Subsequent reads from it will return its default value.
  public mutating func clearPushToken() {self._pushToken = nil}

  public var langID: String = String()

  /// Time difference in seconds between the timezone and GMT.
  /// Could be positive or negative
  public var zoneOffset: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pushToken: Server_PushToken? = nil
}

public struct Server_PushPref {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Server_PushPref.Name = .post

  public var value: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Name: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case post // = 0

    /// Comments or reactions
    case comment // = 1

    /// Someone mentioned you in a post/comment.
    case mentions // = 2

    /// Popular posts.
    case onFire // = 3

    /// New users/contacts joining katchup.
    case newUsers // = 4

    /// New followers.
    case followers // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .comment
      case 2: self = .mentions
      case 3: self = .onFire
      case 4: self = .newUsers
      case 5: self = .followers
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .comment: return 1
      case .mentions: return 2
      case .onFire: return 3
      case .newUsers: return 4
      case .followers: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PushPref.Name: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PushPref.Name] = [
    .post,
    .comment,
    .mentions,
    .onFire,
    .newUsers,
    .followers,
  ]
}

#endif  // swift(>=4.2)

public struct Server_NotificationPrefs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pushPrefs: [Server_PushPref] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Rerequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var identityKey: Data = Data()

  public var signedPreKeyID: Int64 = 0

  public var oneTimePreKeyID: Int64 = 0

  public var sessionSetupEphemeralKey: Data = Data()

  public var messageEphemeralKey: Data = Data()

  public var contentType: Server_Rerequest.ContentType = .chat

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case call // = 1
    case groupHistory // = 2
    case chatReaction // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .call
      case 2: self = .groupHistory
      case 3: self = .chatReaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .call: return 1
      case .groupHistory: return 2
      case .chatReaction: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Rerequest.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Rerequest.ContentType] = [
    .chat,
    .call,
    .groupHistory,
    .chatReaction,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupFeedRerequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  /// Post id or Comment id or HistoryResend id
  public var id: String = String()

  public var rerequestType: Server_GroupFeedRerequest.RerequestType = .payload

  public var contentType: Server_GroupFeedRerequest.ContentType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// To capture the type of decryption failure.
  public enum RerequestType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unable to decrypt post/comment/history-resend payload
    case payload // = 0

    /// Unable to decrypt sender state.
    case senderState // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .payload
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .payload
      case 1: self = .senderState
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .payload: return 0
      case .senderState: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case post // = 1
    case comment // = 2
    case historyResend // = 3
    case postReaction // = 4
    case commentReaction // = 5
    case message // = 6
    case messageReaction // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .post
      case 2: self = .comment
      case 3: self = .historyResend
      case 4: self = .postReaction
      case 5: self = .commentReaction
      case 6: self = .message
      case 7: self = .messageReaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .post: return 1
      case .comment: return 2
      case .historyResend: return 3
      case .postReaction: return 4
      case .commentReaction: return 5
      case .message: return 6
      case .messageReaction: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupFeedRerequest.RerequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupFeedRerequest.RerequestType] = [
    .payload,
    .senderState,
  ]
}

extension Server_GroupFeedRerequest.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupFeedRerequest.ContentType] = [
    .unknown,
    .post,
    .comment,
    .historyResend,
    .postReaction,
    .commentReaction,
    .message,
    .messageReaction,
  ]
}

#endif  // swift(>=4.2)

public struct Server_HomeFeedRerequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Post id or Comment id.
  public var id: String = String()

  public var rerequestType: Server_HomeFeedRerequest.RerequestType = .unknownType

  public var contentType: Server_HomeFeedRerequest.ContentType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// To capture the type of decryption failure.
  public enum RerequestType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0

    /// Unable to decrypt post/comment's payload
    case payload // = 1

    /// Unable to decrypt sender state.
    case senderState // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .payload
      case 2: self = .senderState
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .payload: return 1
      case .senderState: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ContentType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case post // = 1
    case comment // = 2
    case postReaction // = 3
    case commentReaction // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .post
      case 2: self = .comment
      case 3: self = .postReaction
      case 4: self = .commentReaction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .post: return 1
      case .comment: return 2
      case .postReaction: return 3
      case .commentReaction: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_HomeFeedRerequest.RerequestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeFeedRerequest.RerequestType] = [
    .unknownType,
    .payload,
    .senderState,
  ]
}

extension Server_HomeFeedRerequest.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HomeFeedRerequest.ContentType] = [
    .unknown,
    .post,
    .comment,
    .postReaction,
    .commentReaction,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SeenReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DeliveryReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PlayedReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ScreenshotReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_SavedReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupChatRetract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var gid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ChatRetract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Prop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Props {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = Data()

  public var props: [Server_Prop] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_WhisperKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var action: Server_WhisperKeys.Action = .normal

  public var identityKey: Data = Data()

  public var signedKey: Data = Data()

  public var otpKeyCount: Int32 = 0

  public var oneTimeKeys: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case add // = 1
    case count // = 2
    case get // = 3
    case set // = 4
    case update // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .add
      case 2: self = .count
      case 3: self = .get
      case 4: self = .set
      case 5: self = .update
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .add: return 1
      case .count: return 2
      case .get: return 3
      case .set: return 4
      case .update: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_WhisperKeys.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WhisperKeys.Action] = [
    .normal,
    .add,
    .count,
    .get,
    .set,
    .update,
  ]
}

#endif  // swift(>=4.2)

public struct Server_TruncWhisperKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  /// The following field is first 4 bytes of the public part of the identity key.
  public var truncPublicIdentityKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_WhisperKeysCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Action is always get.
  public var collection: [Server_WhisperKeys] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_TruncWhisperKeysCollection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Action is always get.
  public var collection: [Server_TruncWhisperKeys] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_NoiseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageType: Server_NoiseMessage.MessageType = .xxA

  /// Third party library we use for Noise handshake provides API to read/write Noise messages.
  /// The following content represent the bytes returned by write message and such content is
  /// correctly consumed by the receiving library for matching handshake pattern and handshake
  /// state.
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum MessageType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// -> e
    case xxA // = 0

    /// <- e, ee, s, es
    case xxB // = 1

    /// -> s, se
    case xxC // = 2

    /// (<- s ...) -> e, es, s, ss
    case ikA // = 3

    /// <- e, ee, se
    case ikB // = 4

    /// (-> e ...) <- e, ee, s, es
    case xxFallbackA // = 5

    /// -> s, se
    case xxFallbackB // = 6

    /// (-> s, <- s ...) -> e, es, ss
    case kkA // = 7

    /// <- e, ee, se
    case kkB // = 8
    case UNRECOGNIZED(Int)

    public init() {
      self = .xxA
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .xxA
      case 1: self = .xxB
      case 2: self = .xxC
      case 3: self = .ikA
      case 4: self = .ikB
      case 5: self = .xxFallbackA
      case 6: self = .xxFallbackB
      case 7: self = .kkA
      case 8: self = .kkB
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .xxA: return 0
      case .xxB: return 1
      case .xxC: return 2
      case .ikA: return 3
      case .ikB: return 4
      case .xxFallbackA: return 5
      case .xxFallbackB: return 6
      case .kkA: return 7
      case .kkB: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_NoiseMessage.MessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_NoiseMessage.MessageType] = [
    .xxA,
    .xxB,
    .xxC,
    .ikA,
    .ikB,
    .xxFallbackA,
    .xxFallbackB,
    .kkA,
    .kkB,
  ]
}

#endif  // swift(>=4.2)

public struct Server_DeleteAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var reason: Server_DeleteAccount.Reason = .unknownDeleteReason

  public var feedback: String = String()

  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownDeleteReason // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownDeleteReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownDeleteReason
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownDeleteReason: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_DeleteAccount.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_DeleteAccount.Reason] = [
    .unknownDeleteReason,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ExportData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dataReadyTs: Int64 = 0

  public var status: Server_ExportData.Status = .unknown

  public var dataURL: String = String()

  public var availableUntilTs: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case pending // = 1
    case ready // = 2
    case notStarted // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .pending
      case 2: self = .ready
      case 3: self = .notStarted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .pending: return 1
      case .ready: return 2
      case .notStarted: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ExportData.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ExportData.Status] = [
    .unknown,
    .pending,
    .ready,
    .notStarted,
  ]
}

#endif  // swift(>=4.2)

/// PushContent
public struct Server_PushContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var certificate: Data = Data()

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Invitee Notice
public struct Server_InviteeNotice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var inviters: [Server_Inviter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Inviter details
public struct Server_Inviter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var name: String = String()

  public var phone: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Identity Key
public struct Server_IdentityKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Logs request
public struct Server_RequestLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_RegisterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var request: Server_RegisterRequest.OneOf_Request? = nil

  public var otpRequest: Server_OtpRequest {
    get {
      if case .otpRequest(let v)? = request {return v}
      return Server_OtpRequest()
    }
    set {request = .otpRequest(newValue)}
  }

  public var verifyRequest: Server_VerifyOtpRequest {
    get {
      if case .verifyRequest(let v)? = request {return v}
      return Server_VerifyOtpRequest()
    }
    set {request = .verifyRequest(newValue)}
  }

  public var hashcashRequest: Server_HashcashRequest {
    get {
      if case .hashcashRequest(let v)? = request {return v}
      return Server_HashcashRequest()
    }
    set {request = .hashcashRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Request: Equatable {
    case otpRequest(Server_OtpRequest)
    case verifyRequest(Server_VerifyOtpRequest)
    case hashcashRequest(Server_HashcashRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_RegisterRequest.OneOf_Request, rhs: Server_RegisterRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.otpRequest, .otpRequest): return {
        guard case .otpRequest(let l) = lhs, case .otpRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyRequest, .verifyRequest): return {
        guard case .verifyRequest(let l) = lhs, case .verifyRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcashRequest, .hashcashRequest): return {
        guard case .hashcashRequest(let l) = lhs, case .hashcashRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_RegisterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var response: Server_RegisterResponse.OneOf_Response? = nil

  public var otpResponse: Server_OtpResponse {
    get {
      if case .otpResponse(let v)? = response {return v}
      return Server_OtpResponse()
    }
    set {response = .otpResponse(newValue)}
  }

  public var verifyResponse: Server_VerifyOtpResponse {
    get {
      if case .verifyResponse(let v)? = response {return v}
      return Server_VerifyOtpResponse()
    }
    set {response = .verifyResponse(newValue)}
  }

  public var hashcashResponse: Server_HashcashResponse {
    get {
      if case .hashcashResponse(let v)? = response {return v}
      return Server_HashcashResponse()
    }
    set {response = .hashcashResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Response: Equatable {
    case otpResponse(Server_OtpResponse)
    case verifyResponse(Server_VerifyOtpResponse)
    case hashcashResponse(Server_HashcashResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_RegisterResponse.OneOf_Response, rhs: Server_RegisterResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.otpResponse, .otpResponse): return {
        guard case .otpResponse(let l) = lhs, case .otpResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyResponse, .verifyResponse): return {
        guard case .verifyResponse(let l) = lhs, case .verifyResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hashcashResponse, .hashcashResponse): return {
        guard case .hashcashResponse(let l) = lhs, case .hashcashResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_HashcashRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var countryCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HashcashResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hashcashChallenge: String = String()

  /// default is false
  public var isPhoneNotNeeded: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_OtpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var method: Server_OtpRequest.Method = .sms

  public var langID: String = String()

  public var groupInviteToken: String = String()

  public var userAgent: String = String()

  public var hashcashSolution: String = String()

  public var hashcashSolutionTimeTakenMs: Int64 = 0

  public var campaignID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Method: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sms // = 0
    case voiceCall // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .sms
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sms
      case 1: self = .voiceCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sms: return 0
      case .voiceCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_OtpRequest.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_OtpRequest.Method] = [
    .sms,
    .voiceCall,
  ]
}

#endif  // swift(>=4.2)

public struct Server_OtpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var result: Server_OtpResponse.Result = .unknownResult

  public var reason: Server_OtpResponse.Reason = .unknownReason

  public var retryAfterSecs: Int64 = 0

  public var shouldVerifyNumber: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case invalidPhoneNumber // = 1
    case invalidClientVersion // = 2
    case badMethod // = 3
    case otpFail // = 4
    case notInvited // = 5
    case invalidGroupInviteToken // = 6
    case retriedTooSoon // = 7
    case badRequest // = 8
    case internalServerError // = 9
    case invalidHashcashNonce // = 10
    case wrongHashcashSolution // = 11
    case invalidCountryCode // = 12
    case invalidLength // = 13
    case lineTypeVoip // = 14
    case lineTypeFixed // = 15
    case lineTypeOther // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .invalidPhoneNumber
      case 2: self = .invalidClientVersion
      case 3: self = .badMethod
      case 4: self = .otpFail
      case 5: self = .notInvited
      case 6: self = .invalidGroupInviteToken
      case 7: self = .retriedTooSoon
      case 8: self = .badRequest
      case 9: self = .internalServerError
      case 10: self = .invalidHashcashNonce
      case 11: self = .wrongHashcashSolution
      case 12: self = .invalidCountryCode
      case 13: self = .invalidLength
      case 14: self = .lineTypeVoip
      case 15: self = .lineTypeFixed
      case 16: self = .lineTypeOther
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .invalidPhoneNumber: return 1
      case .invalidClientVersion: return 2
      case .badMethod: return 3
      case .otpFail: return 4
      case .notInvited: return 5
      case .invalidGroupInviteToken: return 6
      case .retriedTooSoon: return 7
      case .badRequest: return 8
      case .internalServerError: return 9
      case .invalidHashcashNonce: return 10
      case .wrongHashcashSolution: return 11
      case .invalidCountryCode: return 12
      case .invalidLength: return 13
      case .lineTypeVoip: return 14
      case .lineTypeFixed: return 15
      case .lineTypeOther: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_OtpResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_OtpResponse.Result] = [
    .unknownResult,
    .success,
    .failure,
  ]
}

extension Server_OtpResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_OtpResponse.Reason] = [
    .unknownReason,
    .invalidPhoneNumber,
    .invalidClientVersion,
    .badMethod,
    .otpFail,
    .notInvited,
    .invalidGroupInviteToken,
    .retriedTooSoon,
    .badRequest,
    .internalServerError,
    .invalidHashcashNonce,
    .wrongHashcashSolution,
    .invalidCountryCode,
    .invalidLength,
    .lineTypeVoip,
    .lineTypeFixed,
    .lineTypeOther,
  ]
}

#endif  // swift(>=4.2)

public struct Server_VerifyOtpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String {
    get {return _storage._phone}
    set {_uniqueStorage()._phone = newValue}
  }

  public var code: String {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var staticKey: Data {
    get {return _storage._staticKey}
    set {_uniqueStorage()._staticKey = newValue}
  }

  public var signedPhrase: Data {
    get {return _storage._signedPhrase}
    set {_uniqueStorage()._signedPhrase = newValue}
  }

  public var identityKey: Data {
    get {return _storage._identityKey}
    set {_uniqueStorage()._identityKey = newValue}
  }

  public var signedKey: Data {
    get {return _storage._signedKey}
    set {_uniqueStorage()._signedKey = newValue}
  }

  public var oneTimeKeys: [Data] {
    get {return _storage._oneTimeKeys}
    set {_uniqueStorage()._oneTimeKeys = newValue}
  }

  public var groupInviteToken: String {
    get {return _storage._groupInviteToken}
    set {_uniqueStorage()._groupInviteToken = newValue}
  }

  /// Only for ios-appclip
  public var pushRegister: Server_PushRegister {
    get {return _storage._pushRegister ?? Server_PushRegister()}
    set {_uniqueStorage()._pushRegister = newValue}
  }
  /// Returns true if `pushRegister` has been explicitly set.
  public var hasPushRegister: Bool {return _storage._pushRegister != nil}
  /// Clears the value of `pushRegister`. Subsequent reads from it will return its default value.
  public mutating func clearPushRegister() {_uniqueStorage()._pushRegister = nil}

  public var userAgent: String {
    get {return _storage._userAgent}
    set {_uniqueStorage()._userAgent = newValue}
  }

  public var campaignID: String {
    get {return _storage._campaignID}
    set {_uniqueStorage()._campaignID = newValue}
  }

  public var hashcashSolution: String {
    get {return _storage._hashcashSolution}
    set {_uniqueStorage()._hashcashSolution = newValue}
  }

  public var hashcashSolutionTimeTakenMs: Int64 {
    get {return _storage._hashcashSolutionTimeTakenMs}
    set {_uniqueStorage()._hashcashSolutionTimeTakenMs = newValue}
  }

  /// If the client already received a uid via phoneless registration.
  public var uid: Int64 {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Server_VerifyOtpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var uid: Int64 = 0

  public var name: String = String()

  public var result: Server_VerifyOtpResponse.Result = .unknownResult

  public var reason: Server_VerifyOtpResponse.Reason = .unknownReason

  public var groupInviteResult: String = String()

  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case invalidPhoneNumber // = 1
    case invalidClientVersion // = 2
    case wrongSmsCode // = 3
    case missingPhone // = 4
    case missingCode // = 5
    case missingName // = 6
    case invalidName // = 7
    case missingIdentityKey // = 8
    case missingSignedKey // = 9
    case missingOneTimeKeys // = 10
    case badBase64Key // = 11
    case invalidOneTimeKeys // = 12
    case tooFewOneTimeKeys // = 13
    case tooManyOneTimeKeys // = 14
    case tooBigIdentityKey // = 15
    case tooBigSignedKey // = 16
    case tooBigOneTimeKeys // = 17
    case invalidSEdPub // = 18
    case invalidSignedPhrase // = 19
    case unableToOpenSignedPhrase // = 20
    case badRequest // = 21
    case internalServerError // = 22
    case invalidCountryCode // = 23
    case invalidLength // = 24
    case lineTypeVoip // = 25
    case lineTypeFixed // = 26
    case lineTypeOther // = 27
    case wrongHashcashSolution // = 28
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .invalidPhoneNumber
      case 2: self = .invalidClientVersion
      case 3: self = .wrongSmsCode
      case 4: self = .missingPhone
      case 5: self = .missingCode
      case 6: self = .missingName
      case 7: self = .invalidName
      case 8: self = .missingIdentityKey
      case 9: self = .missingSignedKey
      case 10: self = .missingOneTimeKeys
      case 11: self = .badBase64Key
      case 12: self = .invalidOneTimeKeys
      case 13: self = .tooFewOneTimeKeys
      case 14: self = .tooManyOneTimeKeys
      case 15: self = .tooBigIdentityKey
      case 16: self = .tooBigSignedKey
      case 17: self = .tooBigOneTimeKeys
      case 18: self = .invalidSEdPub
      case 19: self = .invalidSignedPhrase
      case 20: self = .unableToOpenSignedPhrase
      case 21: self = .badRequest
      case 22: self = .internalServerError
      case 23: self = .invalidCountryCode
      case 24: self = .invalidLength
      case 25: self = .lineTypeVoip
      case 26: self = .lineTypeFixed
      case 27: self = .lineTypeOther
      case 28: self = .wrongHashcashSolution
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .invalidPhoneNumber: return 1
      case .invalidClientVersion: return 2
      case .wrongSmsCode: return 3
      case .missingPhone: return 4
      case .missingCode: return 5
      case .missingName: return 6
      case .invalidName: return 7
      case .missingIdentityKey: return 8
      case .missingSignedKey: return 9
      case .missingOneTimeKeys: return 10
      case .badBase64Key: return 11
      case .invalidOneTimeKeys: return 12
      case .tooFewOneTimeKeys: return 13
      case .tooManyOneTimeKeys: return 14
      case .tooBigIdentityKey: return 15
      case .tooBigSignedKey: return 16
      case .tooBigOneTimeKeys: return 17
      case .invalidSEdPub: return 18
      case .invalidSignedPhrase: return 19
      case .unableToOpenSignedPhrase: return 20
      case .badRequest: return 21
      case .internalServerError: return 22
      case .invalidCountryCode: return 23
      case .invalidLength: return 24
      case .lineTypeVoip: return 25
      case .lineTypeFixed: return 26
      case .lineTypeOther: return 27
      case .wrongHashcashSolution: return 28
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_VerifyOtpResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_VerifyOtpResponse.Result] = [
    .unknownResult,
    .success,
    .failure,
  ]
}

extension Server_VerifyOtpResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_VerifyOtpResponse.Reason] = [
    .unknownReason,
    .invalidPhoneNumber,
    .invalidClientVersion,
    .wrongSmsCode,
    .missingPhone,
    .missingCode,
    .missingName,
    .invalidName,
    .missingIdentityKey,
    .missingSignedKey,
    .missingOneTimeKeys,
    .badBase64Key,
    .invalidOneTimeKeys,
    .tooFewOneTimeKeys,
    .tooManyOneTimeKeys,
    .tooBigIdentityKey,
    .tooBigSignedKey,
    .tooBigOneTimeKeys,
    .invalidSEdPub,
    .invalidSignedPhrase,
    .unableToOpenSignedPhrase,
    .badRequest,
    .internalServerError,
    .invalidCountryCode,
    .invalidLength,
    .lineTypeVoip,
    .lineTypeFixed,
    .lineTypeOther,
    .wrongHashcashSolution,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ClientOtpRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: Server_ClientOtpRequest.Method = .sms

  public var phone: String = String()

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Method: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sms // = 0
    case voiceCall // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .sms
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sms
      case 1: self = .voiceCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sms: return 0
      case .voiceCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ClientOtpRequest.Method: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientOtpRequest.Method] = [
    .sms,
    .voiceCall,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ClientOtpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_ClientOtpResponse.Result = .unknownResult

  public var reason: Server_ClientOtpResponse.Reason = .unknownReason

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownResult // = 0
    case success // = 1
    case failure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownResult
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownResult
      case 1: self = .success
      case 2: self = .failure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownResult: return 0
      case .success: return 1
      case .failure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case setupIssue // = 1
    case permissionIssue // = 2
    case formattingIssue // = 3

    /// Client should retry a few times in this case.
    case networkingIssue // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .setupIssue
      case 2: self = .permissionIssue
      case 3: self = .formattingIssue
      case 4: self = .networkingIssue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .setupIssue: return 1
      case .permissionIssue: return 2
      case .formattingIssue: return 3
      case .networkingIssue: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ClientOtpResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientOtpResponse.Result] = [
    .unknownResult,
    .success,
    .failure,
  ]
}

extension Server_ClientOtpResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientOtpResponse.Reason] = [
    .unknownReason,
    .setupIssue,
    .permissionIssue,
    .formattingIssue,
    .networkingIssue,
  ]
}

#endif  // swift(>=4.2)

public struct Server_WakeUp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alertType: Server_WakeUp.AlertType = .alert

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AlertType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case alert // = 0
    case silent // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .alert
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .alert
      case 1: self = .silent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .alert: return 0
      case .silent: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_WakeUp.AlertType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WakeUp.AlertType] = [
    .alert,
    .silent,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MarketingAlert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_MarketingAlert.TypeEnum = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case inviteFriends // = 1
    case sharePost // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .inviteFriends
      case 2: self = .sharePost
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .inviteFriends: return 1
      case .sharePost: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MarketingAlert.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MarketingAlert.TypeEnum] = [
    .unknown,
    .inviteFriends,
    .sharePost,
  ]
}

#endif  // swift(>=4.2)

public struct Server_BasicUserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var username: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  /// is uid my follower
  public var followerStatus: Server_FollowStatus = .none

  /// am I following uid
  public var followingStatus: Server_FollowStatus = .none

  public var numMutualFollowing: Int32 = 0

  /// true if I blocked this user
  public var blocked: Bool = false

  public var geoTags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var username: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  /// is uid my follower
  public var followerStatus: Server_FollowStatus = .none

  /// am I following uid
  public var followingStatus: Server_FollowStatus = .none

  public var numMutualFollowing: Int32 = 0

  public var bio: String = String()

  public var links: [Server_Link] = []

  /// list of users I am following that follow this user
  public var relevantFollowers: [Server_BasicUserProfile] = []

  /// true if I blocked this user
  public var blocked: Bool = false

  public var totalPostImpressions: Int32 = 0

  public var totalPostReactions: Int32 = 0

  public var totalNumPosts: Int32 = 0

  public var geoTags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PostMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numImpressions: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ProfileUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ProfileUpdate.TypeEnum = .normal

  public var profile: Server_BasicUserProfile {
    get {return _profile ?? Server_BasicUserProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case delete // = 1

    /// When the uid follows me.
    case followerNotice // = 2

    /// When my contact joins katchup.
    case contactNotice // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .delete
      case 2: self = .followerNotice
      case 3: self = .contactNotice
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .delete: return 1
      case .followerNotice: return 2
      case .contactNotice: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _profile: Server_BasicUserProfile? = nil
}

#if swift(>=4.2)

extension Server_ProfileUpdate.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ProfileUpdate.TypeEnum] = [
    .normal,
    .delete,
    .followerNotice,
    .contactNotice,
  ]
}

#endif  // swift(>=4.2)

public struct Server_UserProfileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UserProfileResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_UserProfileResult.Result {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var reason: Server_UserProfileResult.Reason {
    get {return _storage._reason}
    set {_uniqueStorage()._reason = newValue}
  }

  public var profile: Server_UserProfile {
    get {return _storage._profile ?? Server_UserProfile()}
    set {_uniqueStorage()._profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return _storage._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {_uniqueStorage()._profile = nil}

  public var recentPosts: [Server_Post] {
    get {return _storage._recentPosts}
    set {_uniqueStorage()._recentPosts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case noUser // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .noUser
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .noUser: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_UserProfileResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UserProfileResult.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_UserProfileResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UserProfileResult.Reason] = [
    .unknownReason,
    .noUser,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PostMetricsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var postID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PostMetricsResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_PostMetricsResult.Result = .ok

  public var reason: Server_PostMetricsResult.Reason = .unknownReason

  public var postMetrics: Server_PostMetrics {
    get {return _postMetrics ?? Server_PostMetrics()}
    set {_postMetrics = newValue}
  }
  /// Returns true if `postMetrics` has been explicitly set.
  public var hasPostMetrics: Bool {return self._postMetrics != nil}
  /// Clears the value of `postMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearPostMetrics() {self._postMetrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case noPost // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .noPost
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .noPost: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _postMetrics: Server_PostMetrics? = nil
}

#if swift(>=4.2)

extension Server_PostMetricsResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PostMetricsResult.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_PostMetricsResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PostMetricsResult.Reason] = [
    .unknownReason,
    .noPost,
  ]
}

#endif  // swift(>=4.2)

public struct Server_RelationshipRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_RelationshipRequest.Action = .follow

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case follow // = 0
    case unfollow // = 1
    case acceptFollow // = 2
    case ignoreFollow // = 3
    case removeFollower // = 4
    case block // = 5
    case unblock // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .follow
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .follow
      case 1: self = .unfollow
      case 2: self = .acceptFollow
      case 3: self = .ignoreFollow
      case 4: self = .removeFollower
      case 5: self = .block
      case 6: self = .unblock
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .follow: return 0
      case .unfollow: return 1
      case .acceptFollow: return 2
      case .ignoreFollow: return 3
      case .removeFollower: return 4
      case .block: return 5
      case .unblock: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_RelationshipRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_RelationshipRequest.Action] = [
    .follow,
    .unfollow,
    .acceptFollow,
    .ignoreFollow,
    .removeFollower,
    .block,
    .unblock,
  ]
}

#endif  // swift(>=4.2)

public struct Server_RelationshipResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_RelationshipResponse.Result = .ok

  public var profile: Server_BasicUserProfile {
    get {return _profile ?? Server_BasicUserProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _profile: Server_BasicUserProfile? = nil
}

#if swift(>=4.2)

extension Server_RelationshipResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_RelationshipResponse.Result] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_RelationshipList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_RelationshipList.TypeEnum = .follower

  public var cursor: String = String()

  public var users: [Server_BasicUserProfile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case follower // = 0
    case following // = 1
    case incoming // = 2
    case outgoing // = 3
    case blocked // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .follower
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .follower
      case 1: self = .following
      case 2: self = .incoming
      case 3: self = .outgoing
      case 4: self = .blocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .follower: return 0
      case .following: return 1
      case .incoming: return 2
      case .outgoing: return 3
      case .blocked: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_RelationshipList.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_RelationshipList.TypeEnum] = [
    .follower,
    .following,
    .incoming,
    .outgoing,
    .blocked,
  ]
}

#endif  // swift(>=4.2)

public struct Server_UsernameRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_UsernameRequest.Action = .isAvailable

  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case isAvailable // = 0
    case set // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .isAvailable
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .isAvailable
      case 1: self = .set
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .isAvailable: return 0
      case .set: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_UsernameRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UsernameRequest.Action] = [
    .isAvailable,
    .set,
  ]
}

#endif  // swift(>=4.2)

public struct Server_UsernameResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_UsernameResponse.Result = .ok

  public var reason: Server_UsernameResponse.Reason = .tooshort

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case tooshort // = 0
    case toolong // = 1
    case badexpr // = 2
    case notuniq // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .tooshort
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .tooshort
      case 1: self = .toolong
      case 2: self = .badexpr
      case 3: self = .notuniq
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .tooshort: return 0
      case .toolong: return 1
      case .badexpr: return 2
      case .notuniq: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_UsernameResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UsernameResponse.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_UsernameResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UsernameResponse.Reason] = [
    .tooshort,
    .toolong,
    .badexpr,
    .notuniq,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GeoTagRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GeoTagRequest.Action = .get

  public var gpsLocation: Server_GpsLocation {
    get {return _gpsLocation ?? Server_GpsLocation()}
    set {_gpsLocation = newValue}
  }
  /// Returns true if `gpsLocation` has been explicitly set.
  public var hasGpsLocation: Bool {return self._gpsLocation != nil}
  /// Clears the value of `gpsLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGpsLocation() {self._gpsLocation = nil}

  public var geoTag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case block // = 1
    case forceAdd // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .block
      case 2: self = .forceAdd
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .block: return 1
      case .forceAdd: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _gpsLocation: Server_GpsLocation? = nil
}

#if swift(>=4.2)

extension Server_GeoTagRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GeoTagRequest.Action] = [
    .get,
    .block,
    .forceAdd,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GeoTagResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_GeoTagResponse.Result = .ok

  public var reason: Server_GeoTagResponse.Reason = .unknown

  public var geoTags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case invalidRequest // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .invalidRequest
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .invalidRequest: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GeoTagResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GeoTagResponse.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_GeoTagResponse.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GeoTagResponse.Reason] = [
    .unknown,
    .invalidRequest,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var usernameString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_SearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_SearchResponse.Result = .ok

  public var searchResult: [Server_BasicUserProfile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_SearchResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_SearchResponse.Result] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FollowSuggestionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_FollowSuggestionsRequest.Action = .get

  public var rejectedUids: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case reject // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .reject
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .reject: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FollowSuggestionsRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FollowSuggestionsRequest.Action] = [
    .get,
    .reject,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SuggestedProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userProfile: Server_BasicUserProfile {
    get {return _userProfile ?? Server_BasicUserProfile()}
    set {_userProfile = newValue}
  }
  /// Returns true if `userProfile` has been explicitly set.
  public var hasUserProfile: Bool {return self._userProfile != nil}
  /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
  public mutating func clearUserProfile() {self._userProfile = nil}

  public var reason: Server_SuggestedProfile.Reason = .unknownReason

  /// Lower rank is better.
  public var rank: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case directContact // = 1
    case fof // = 2
    case campus // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .directContact
      case 2: self = .fof
      case 3: self = .campus
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .directContact: return 1
      case .fof: return 2
      case .campus: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _userProfile: Server_BasicUserProfile? = nil
}

#if swift(>=4.2)

extension Server_SuggestedProfile.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_SuggestedProfile.Reason] = [
    .unknownReason,
    .directContact,
    .fof,
    .campus,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FollowSuggestionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_FollowSuggestionsResponse.Result = .ok

  public var suggestedProfiles: [Server_SuggestedProfile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FollowSuggestionsResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FollowSuggestionsResponse.Result] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Link {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_Link.TypeEnum = .userDefined

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case userDefined // = 0
    case tiktok // = 1

    /// deprecated: using this on HalloApp results in BAD_TYPE error
    case snapchat // = 2
    case instagram // = 3
    case x // = 4
    case youtube // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .userDefined
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .userDefined
      case 1: self = .tiktok
      case 2: self = .snapchat
      case 3: self = .instagram
      case 4: self = .x
      case 5: self = .youtube
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .userDefined: return 0
      case .tiktok: return 1
      case .snapchat: return 2
      case .instagram: return 3
      case .x: return 4
      case .youtube: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Link.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Link.TypeEnum] = [
    .userDefined,
    .tiktok,
    .snapchat,
    .instagram,
    .x,
    .youtube,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SetLinkRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var link: Server_Link {
    get {return _link ?? Server_Link()}
    set {_link = newValue}
  }
  /// Returns true if `link` has been explicitly set.
  public var hasLink: Bool {return self._link != nil}
  /// Clears the value of `link`. Subsequent reads from it will return its default value.
  public mutating func clearLink() {self._link = nil}

  public var action: Server_SetLinkRequest.Action = .set

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case set // = 0
    case remove // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .set
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .set
      case 1: self = .remove
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .set: return 0
      case .remove: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _link: Server_Link? = nil
}

#if swift(>=4.2)

extension Server_SetLinkRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_SetLinkRequest.Action] = [
    .set,
    .remove,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SetLinkResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_SetLinkResult.Result = .ok

  public var reason: Server_SetLinkResult.Reason = .unknownReason

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case badType // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .badType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .badType: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_SetLinkResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_SetLinkResult.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_SetLinkResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_SetLinkResult.Reason] = [
    .unknownReason,
    .badType,
  ]
}

#endif  // swift(>=4.2)

public struct Server_SetBioRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_SetBioResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_SetBioResult.Result = .ok

  public var reason: Server_SetBioResult.Reason = .unknownReason

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case tooLong // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .tooLong
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .tooLong: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_SetBioResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_SetBioResult.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_SetBioResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_SetBioResult.Reason] = [
    .unknownReason,
    .tooLong,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AiImageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var text: String = String()

  public var numImages: Int64 = 0

  public var promptMode: Server_AiImageRequest.PromptMode = .unknown

  public var negativePrompt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PromptMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// feeds user text directly to AI image model
    case user // = 1

    /// server will enhance user text before feeding to AI image model
    case server // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .user
      case 2: self = .server
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .user: return 1
      case .server: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_AiImageRequest.PromptMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AiImageRequest.PromptMode] = [
    .unknown,
    .user,
    .server,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AiImageResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_AiImageResult.Result = .pending

  public var reason: Server_AiImageResult.Reason = .unknown

  public var id: String = String()

  public var backoff: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case pending // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .pending
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .pending: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case tooSoon // = 1
    case tooManyAttempts // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .tooSoon
      case 2: self = .tooManyAttempts
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .tooSoon: return 1
      case .tooManyAttempts: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_AiImageResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AiImageResult.Result] = [
    .pending,
    .fail,
  ]
}

extension Server_AiImageResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AiImageResult.Reason] = [
    .unknown,
    .tooSoon,
    .tooManyAttempts,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AiImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var image: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_TimeRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startTimestamp: Int64 = 0

  public var endTimestamp: Int64 = 0

  /// in seconds
  public var utcOffset: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Album {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var action: Server_Album.Action = .create

  public var name: String = String()

  public var owner: Int64 = 0

  public var timeRange: Server_TimeRange {
    get {return _timeRange ?? Server_TimeRange()}
    set {_timeRange = newValue}
  }
  /// Returns true if `timeRange` has been explicitly set.
  public var hasTimeRange: Bool {return self._timeRange != nil}
  /// Clears the value of `timeRange`. Subsequent reads from it will return its default value.
  public mutating func clearTimeRange() {self._timeRange = nil}

  public var location: Server_GpsLocation {
    get {return _location ?? Server_GpsLocation()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var canView: Server_AlbumAccess = .inviteOnly

  public var canContribute: Server_AlbumAccess = .inviteOnly

  public var members: [Server_AlbumMember] = []

  public var mediaItems: [Server_MediaItem] = []

  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case create // = 0
    case changeName // = 1
    case changeLocation // = 2
    case changeTime // = 3
    case changeViewAccess // = 4
    case changeContributeAccess // = 5
    case modifyMembers // = 6
    case addMedia // = 7
    case removeMedia // = 8
    case mediaUpdate // = 9
    case getInfo // = 10
    case getMedia // = 11

    /// Gets all the album info and also the initial set of media items
    case get // = 12
    case delete // = 13
    case UNRECOGNIZED(Int)

    public init() {
      self = .create
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .create
      case 1: self = .changeName
      case 2: self = .changeLocation
      case 3: self = .changeTime
      case 4: self = .changeViewAccess
      case 5: self = .changeContributeAccess
      case 6: self = .modifyMembers
      case 7: self = .addMedia
      case 8: self = .removeMedia
      case 9: self = .mediaUpdate
      case 10: self = .getInfo
      case 11: self = .getMedia
      case 12: self = .get
      case 13: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .create: return 0
      case .changeName: return 1
      case .changeLocation: return 2
      case .changeTime: return 3
      case .changeViewAccess: return 4
      case .changeContributeAccess: return 5
      case .modifyMembers: return 6
      case .addMedia: return 7
      case .removeMedia: return 8
      case .mediaUpdate: return 9
      case .getInfo: return 10
      case .getMedia: return 11
      case .get: return 12
      case .delete: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _timeRange: Server_TimeRange? = nil
  fileprivate var _location: Server_GpsLocation? = nil
}

#if swift(>=4.2)

extension Server_Album.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Album.Action] = [
    .create,
    .changeName,
    .changeLocation,
    .changeTime,
    .changeViewAccess,
    .changeContributeAccess,
    .modifyMembers,
    .addMedia,
    .removeMedia,
    .mediaUpdate,
    .getInfo,
    .getMedia,
    .get,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AlbumResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_AlbumResult.Result = .ok

  public var reason: Server_AlbumResult.Reason = .unknown

  public var album: Server_Album {
    get {return _album ?? Server_Album()}
    set {_album = newValue}
  }
  /// Returns true if `album` has been explicitly set.
  public var hasAlbum: Bool {return self._album != nil}
  /// Clears the value of `album`. Subsequent reads from it will return its default value.
  public mutating func clearAlbum() {self._album = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case badAlbumID // = 1
    case notAllowed // = 2
    case tooManyMembers // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .badAlbumID
      case 2: self = .notAllowed
      case 3: self = .tooManyMembers
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .badAlbumID: return 1
      case .notAllowed: return 2
      case .tooManyMembers: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _album: Server_Album? = nil
}

#if swift(>=4.2)

extension Server_AlbumResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AlbumResult.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_AlbumResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AlbumResult.Reason] = [
    .unknown,
    .badAlbumID,
    .notAllowed,
    .tooManyMembers,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AlbumMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var action: Server_AlbumMember.Action = .none

  public var name: String = String()

  public var username: String = String()

  public var avatarID: String = String()

  public var role: Server_AlbumMember.Role = .viewer

  public var pending: Bool = false

  public var removeMedia: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case none // = 0
    case acceptInvite // = 1
    case rejectInvite // = 2
    case join // = 3
    case leave // = 4
    case unInvite // = 5
    case remove // = 6
    case invite // = 7
    case promote // = 8
    case demote // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .acceptInvite
      case 2: self = .rejectInvite
      case 3: self = .join
      case 4: self = .leave
      case 5: self = .unInvite
      case 6: self = .remove
      case 7: self = .invite
      case 8: self = .promote
      case 9: self = .demote
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .acceptInvite: return 1
      case .rejectInvite: return 2
      case .join: return 3
      case .leave: return 4
      case .unInvite: return 5
      case .remove: return 6
      case .invite: return 7
      case .promote: return 8
      case .demote: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Role: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case viewer // = 0
    case contributor // = 1
    case admin // = 2
    case owner // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .viewer
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .viewer
      case 1: self = .contributor
      case 2: self = .admin
      case 3: self = .owner
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .viewer: return 0
      case .contributor: return 1
      case .admin: return 2
      case .owner: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_AlbumMember.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AlbumMember.Action] = [
    .none,
    .acceptInvite,
    .rejectInvite,
    .join,
    .leave,
    .unInvite,
    .remove,
    .invite,
    .promote,
    .demote,
  ]
}

extension Server_AlbumMember.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_AlbumMember.Role] = [
    .viewer,
    .contributor,
    .admin,
    .owner,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GetAlbums {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_GetAlbums.TypeEnum = .all

  /// set by server only
  public var albumIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case member // = 1
    case invited // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .member
      case 2: self = .invited
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .member: return 1
      case .invited: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GetAlbums.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GetAlbums.TypeEnum] = [
    .all,
    .member,
    .invited,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var publisherUid: Int64 = 0

  public var publisherName: String = String()

  public var publisherUsername: String = String()

  public var albumID: String = String()

  public var payload: Data = Data()

  public var deviceCaptureTimestampMs: Int64 = 0

  public var uploadTimestampMs: Int64 = 0

  /// set by the server only
  public var parentMediaID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_FriendshipRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_FriendshipRequest.Action = .addFriend

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// sending a friend request.
    case addFriend // = 0

    /// accepting the friend request.
    case acceptFriend // = 1

    /// remove the friend request after accepting.
    case removeFriend // = 2

    /// reject the friend request.
    case rejectFriend // = 3

    /// block the user.
    case block // = 4

    /// unblock user.
    case unblock // = 5

    /// reject friend suggestion.
    case rejectSuggestion // = 6

    /// withdraw pending friend request by sender.
    case withdrawFriendRequest // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .addFriend
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .addFriend
      case 1: self = .acceptFriend
      case 2: self = .removeFriend
      case 3: self = .rejectFriend
      case 4: self = .block
      case 5: self = .unblock
      case 6: self = .rejectSuggestion
      case 7: self = .withdrawFriendRequest
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .addFriend: return 0
      case .acceptFriend: return 1
      case .removeFriend: return 2
      case .rejectFriend: return 3
      case .block: return 4
      case .unblock: return 5
      case .rejectSuggestion: return 6
      case .withdrawFriendRequest: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FriendshipRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FriendshipRequest.Action] = [
    .addFriend,
    .acceptFriend,
    .removeFriend,
    .rejectFriend,
    .block,
    .unblock,
    .rejectSuggestion,
    .withdrawFriendRequest,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FriendshipResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_FriendshipResponse.Result = .ok

  public var profile: Server_HalloappUserProfile {
    get {return _profile ?? Server_HalloappUserProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _profile: Server_HalloappUserProfile? = nil
}

#if swift(>=4.2)

extension Server_FriendshipResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FriendshipResponse.Result] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_HalloappUserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var username: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var status: Server_FriendshipStatus = .noneStatus

  public var blocked: Bool = false

  public var links: [Server_Link] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HalloappProfileUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_HalloappProfileUpdate.TypeEnum = .normal

  public var profile: Server_HalloappUserProfile {
    get {return _profile ?? Server_HalloappUserProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Profile information update
    case normal // = 0

    /// When the uid accepts my friend request.
    case friendNotice // = 1

    /// When the uid sends me a friend request.
    case incomingFriendRequest // = 2

    /// When the uid deletes their account
    case deleteNotice // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .friendNotice
      case 2: self = .incomingFriendRequest
      case 3: self = .deleteNotice
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .friendNotice: return 1
      case .incomingFriendRequest: return 2
      case .deleteNotice: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _profile: Server_HalloappUserProfile? = nil
}

#if swift(>=4.2)

extension Server_HalloappProfileUpdate.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HalloappProfileUpdate.TypeEnum] = [
    .normal,
    .friendNotice,
    .incomingFriendRequest,
    .deleteNotice,
  ]
}

#endif  // swift(>=4.2)

public struct Server_HalloappSearchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var usernameString: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HalloappSearchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_HalloappSearchResponse.Result = .ok

  public var searchResult: [Server_HalloappUserProfile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_HalloappSearchResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HalloappSearchResponse.Result] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_HalloappProfileRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var username: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HalloappProfileResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_HalloappProfileResult.Result = .ok

  public var reason: Server_HalloappProfileResult.Reason = .unknownReason

  public var profile: Server_HalloappUserProfile {
    get {return _profile ?? Server_HalloappUserProfile()}
    set {_profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  public var hasProfile: Bool {return self._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  public mutating func clearProfile() {self._profile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case noUser // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .noUser
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .noUser: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _profile: Server_HalloappUserProfile? = nil
}

#if swift(>=4.2)

extension Server_HalloappProfileResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HalloappProfileResult.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_HalloappProfileResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_HalloappProfileResult.Reason] = [
    .unknownReason,
    .noUser,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FriendListRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_FriendListRequest.Action = .getFriends

  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Fetch all friends of the user.
    case getFriends // = 0

    /// Fetch all incoming pending friend requests to the user.
    case getIncomingPending // = 1

    /// Fetch all outgoing friend requests from the user.
    case getOutgoingPending // = 2

    /// Fetch all friend suggestions from the user.
    case getSuggestions // = 3

    /// Fetch blocked users of this user.
    case getBlocked // = 4

    /// Set by server_only. Clients should sync all their lists with the server.
    case syncAll // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .getFriends
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .getFriends
      case 1: self = .getIncomingPending
      case 2: self = .getOutgoingPending
      case 3: self = .getSuggestions
      case 4: self = .getBlocked
      case 5: self = .syncAll
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .getFriends: return 0
      case .getIncomingPending: return 1
      case .getOutgoingPending: return 2
      case .getSuggestions: return 3
      case .getBlocked: return 4
      case .syncAll: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FriendListRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FriendListRequest.Action] = [
    .getFriends,
    .getIncomingPending,
    .getOutgoingPending,
    .getSuggestions,
    .getBlocked,
    .syncAll,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FriendProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userProfile: Server_HalloappUserProfile {
    get {return _userProfile ?? Server_HalloappUserProfile()}
    set {_userProfile = newValue}
  }
  /// Returns true if `userProfile` has been explicitly set.
  public var hasUserProfile: Bool {return self._userProfile != nil}
  /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
  public mutating func clearUserProfile() {self._userProfile = nil}

  /// Field is populated only for friend suggestions.
  public var reason: Server_FriendProfile.Reason = .unknownReason

  /// Lower rank is better. populated only for suggestions.
  public var rank: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownReason // = 0
    case directContact // = 1
    case incomingPending // = 2
    case friendsOfFriends // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownReason
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownReason
      case 1: self = .directContact
      case 2: self = .incomingPending
      case 3: self = .friendsOfFriends
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownReason: return 0
      case .directContact: return 1
      case .incomingPending: return 2
      case .friendsOfFriends: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _userProfile: Server_HalloappUserProfile? = nil
}

#if swift(>=4.2)

extension Server_FriendProfile.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FriendProfile.Reason] = [
    .unknownReason,
    .directContact,
    .incomingPending,
    .friendsOfFriends,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FriendListResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_FriendListResponse.Result = .ok

  public var cursor: String = String()

  public var friendProfiles: [Server_FriendProfile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FriendListResponse.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FriendListResponse.Result] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ReverseGeocodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var location: Server_GpsLocation {
    get {return _location ?? Server_GpsLocation()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _location: Server_GpsLocation? = nil
}

public struct Server_ReverseGeocodeLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var location: Server_GpsLocation {
    get {return _location ?? Server_GpsLocation()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var type: String = String()

  public var address: String = String()

  public var neighborhood: String = String()

  public var postcode: String = String()

  public var district: String = String()

  public var region: String = String()

  public var country: String = String()

  public var place: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _location: Server_GpsLocation? = nil
}

public struct Server_ReverseGeocodeResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_ReverseGeocodeResult.Result = .ok

  public var reason: Server_ReverseGeocodeResult.Reason = .unknown

  public var backoff: Int64 = 0

  public var location: Server_ReverseGeocodeLocation {
    get {return _location ?? Server_ReverseGeocodeLocation()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Reason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case tooSoon // = 1
    case invalidLatLong // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .tooSoon
      case 2: self = .invalidLatLong
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .tooSoon: return 1
      case .invalidLatLong: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _location: Server_ReverseGeocodeLocation? = nil
}

#if swift(>=4.2)

extension Server_ReverseGeocodeResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ReverseGeocodeResult.Result] = [
    .ok,
    .fail,
  ]
}

extension Server_ReverseGeocodeResult.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ReverseGeocodeResult.Reason] = [
    .unknown,
    .tooSoon,
    .invalidLatLong,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Server_PublicFeedContentType: @unchecked Sendable {}
extension Server_CallType: @unchecked Sendable {}
extension Server_FollowStatus: @unchecked Sendable {}
extension Server_AlbumAccess: @unchecked Sendable {}
extension Server_FriendshipStatus: @unchecked Sendable {}
extension Server_UploadAvatar: @unchecked Sendable {}
extension Server_Avatar: @unchecked Sendable {}
extension Server_Avatars: @unchecked Sendable {}
extension Server_UploadGroupAvatar: @unchecked Sendable {}
extension Server_CertMessage: @unchecked Sendable {}
extension Server_ClientMode: @unchecked Sendable {}
extension Server_ClientMode.Mode: @unchecked Sendable {}
extension Server_ClientVersion: @unchecked Sendable {}
extension Server_DeviceInfo: @unchecked Sendable {}
extension Server_ClientLog: @unchecked Sendable {}
extension Server_Count: @unchecked Sendable {}
extension Server_Dim: @unchecked Sendable {}
extension Server_Contact: @unchecked Sendable {}
extension Server_Contact.Action: @unchecked Sendable {}
extension Server_ContactList: @unchecked Sendable {}
extension Server_ContactList.TypeEnum: @unchecked Sendable {}
extension Server_ContactHash: @unchecked Sendable {}
extension Server_ContactSyncError: @unchecked Sendable {}
extension Server_MomentInfo: @unchecked Sendable {}
extension Server_MomentInfo.ContentType: @unchecked Sendable {}
extension Server_MediaCounters: @unchecked Sendable {}
extension Server_Audience: @unchecked Sendable {}
extension Server_Audience.TypeEnum: @unchecked Sendable {}
extension Server_Post: @unchecked Sendable {}
extension Server_Post.Tag: @unchecked Sendable {}
extension Server_Comment: @unchecked Sendable {}
extension Server_Comment.CommentType: @unchecked Sendable {}
extension Server_ShareStanza: @unchecked Sendable {}
extension Server_FeedItem: @unchecked Sendable {}
extension Server_FeedItem.OneOf_Item: @unchecked Sendable {}
extension Server_FeedItem.Action: @unchecked Sendable {}
extension Server_FeedItems: @unchecked Sendable {}
extension Server_PublicFeedRequest: @unchecked Sendable {}
extension Server_PublicFeedResponse: @unchecked Sendable {}
extension Server_PublicFeedResponse.Result: @unchecked Sendable {}
extension Server_PublicFeedResponse.Reason: @unchecked Sendable {}
extension Server_PublicFeedItem: @unchecked Sendable {}
extension Server_PublicFeedItem.Reason: @unchecked Sendable {}
extension Server_ServerScore: @unchecked Sendable {}
extension Server_PublicFeedUpdate: @unchecked Sendable {}
extension Server_GpsLocation: @unchecked Sendable {}
extension Server_PostSubscriptionRequest: @unchecked Sendable {}
extension Server_PostSubscriptionRequest.Action: @unchecked Sendable {}
extension Server_PostSubscriptionResponse: @unchecked Sendable {}
extension Server_PostSubscriptionResponse.Result: @unchecked Sendable {}
extension Server_PostSubscriptionResponse.Reason: @unchecked Sendable {}
extension Server_SenderStateWithKeyInfo: @unchecked Sendable {}
extension Server_SenderStateBundle: @unchecked Sendable {}
extension Server_GroupFeedItem: @unchecked Sendable {}
extension Server_GroupFeedItem.OneOf_Item: @unchecked Sendable {}
extension Server_GroupFeedItem.Action: @unchecked Sendable {}
extension Server_GroupFeedItems: @unchecked Sendable {}
extension Server_GroupFeedHistory: @unchecked Sendable {}
extension Server_GroupMember: @unchecked Sendable {}
extension Server_GroupMember.Action: @unchecked Sendable {}
extension Server_GroupMember.TypeEnum: @unchecked Sendable {}
extension Server_GroupStanza: @unchecked Sendable {}
extension Server_GroupStanza.Action: @unchecked Sendable {}
extension Server_GroupStanza.GroupType: @unchecked Sendable {}
extension Server_ExpiryInfo: @unchecked Sendable {}
extension Server_ExpiryInfo.ExpiryType: @unchecked Sendable {}
extension Server_GroupChat: @unchecked Sendable {}
extension Server_GroupChatStanza: @unchecked Sendable {}
extension Server_GroupChatStanza.ChatType: @unchecked Sendable {}
extension Server_GroupsStanza: @unchecked Sendable {}
extension Server_GroupsStanza.Action: @unchecked Sendable {}
extension Server_GroupInviteLink: @unchecked Sendable {}
extension Server_GroupInviteLink.Action: @unchecked Sendable {}
extension Server_AuthRequest: @unchecked Sendable {}
extension Server_AuthResult: @unchecked Sendable {}
extension Server_AuthResult.Result: @unchecked Sendable {}
extension Server_AuthResult.Reason: @unchecked Sendable {}
extension Server_Invite: @unchecked Sendable {}
extension Server_InvitesRequest: @unchecked Sendable {}
extension Server_InvitesResponse: @unchecked Sendable {}
extension Server_MediaUrl: @unchecked Sendable {}
extension Server_UploadMedia: @unchecked Sendable {}
extension Server_UploadMedia.TypeEnum: @unchecked Sendable {}
extension Server_ChatStanza: @unchecked Sendable {}
extension Server_ChatStanza.ChatType: @unchecked Sendable {}
extension Server_SilentChatStanza: @unchecked Sendable {}
extension Server_Ping: @unchecked Sendable {}
extension Server_ErrorStanza: @unchecked Sendable {}
extension Server_Name: @unchecked Sendable {}
extension Server_EndOfQueue: @unchecked Sendable {}
extension Server_HistoryResend: @unchecked Sendable {}
extension Server_StunServer: @unchecked Sendable {}
extension Server_TurnServer: @unchecked Sendable {}
extension Server_GetCallServers: @unchecked Sendable {}
extension Server_GetCallServersResult: @unchecked Sendable {}
extension Server_GetCallServersResult.Result: @unchecked Sendable {}
extension Server_CallCapabilities: @unchecked Sendable {}
extension Server_StartCall: @unchecked Sendable {}
extension Server_StartCallResult: @unchecked Sendable {}
extension Server_StartCallResult.Result: @unchecked Sendable {}
extension Server_WebRtcSessionDescription: @unchecked Sendable {}
extension Server_IncomingCallPush: @unchecked Sendable {}
extension Server_IncomingCall: @unchecked Sendable {}
extension Server_IceCandidate: @unchecked Sendable {}
extension Server_CallRinging: @unchecked Sendable {}
extension Server_PreAnswerCall: @unchecked Sendable {}
extension Server_AnswerCall: @unchecked Sendable {}
extension Server_CallSdp: @unchecked Sendable {}
extension Server_CallSdp.SdpType: @unchecked Sendable {}
extension Server_EndCall: @unchecked Sendable {}
extension Server_EndCall.Reason: @unchecked Sendable {}
extension Server_IceRestartOffer: @unchecked Sendable {}
extension Server_IceRestartAnswer: @unchecked Sendable {}
extension Server_HoldCall: @unchecked Sendable {}
extension Server_MuteCall: @unchecked Sendable {}
extension Server_MuteCall.MediaType: @unchecked Sendable {}
extension Server_CallConfig: @unchecked Sendable {}
extension Server_CallConfig.IceTransportPolicy: @unchecked Sendable {}
extension Server_OgTagInfo: @unchecked Sendable {}
extension Server_ExternalSharePost: @unchecked Sendable {}
extension Server_ExternalSharePost.Action: @unchecked Sendable {}
extension Server_ExternalSharePostContainer: @unchecked Sendable {}
extension Server_WebClientInfo: @unchecked Sendable {}
extension Server_WebClientInfo.Action: @unchecked Sendable {}
extension Server_WebClientInfo.Result: @unchecked Sendable {}
extension Server_ReportUserContent: @unchecked Sendable {}
extension Server_ReportUserContent.TypeEnum: @unchecked Sendable {}
extension Server_ReportUserContent.Reason: @unchecked Sendable {}
extension Server_WebStanza: @unchecked Sendable {}
extension Server_WebStanza.OneOf_Payload: @unchecked Sendable {}
extension Server_ContentMissing: @unchecked Sendable {}
extension Server_ContentMissing.ContentType: @unchecked Sendable {}
extension Server_MomentNotification: @unchecked Sendable {}
extension Server_MomentNotification.TypeEnum: @unchecked Sendable {}
extension Server_ArchiveRequest: @unchecked Sendable {}
extension Server_ArchiveResult: @unchecked Sendable {}
extension Server_ArchiveResult.Result: @unchecked Sendable {}
extension Server_ArchiveResult.Reason: @unchecked Sendable {}
extension Server_Iq: @unchecked Sendable {}
extension Server_Iq.OneOf_Payload: @unchecked Sendable {}
extension Server_Iq.TypeEnum: @unchecked Sendable {}
extension Server_Msg: @unchecked Sendable {}
extension Server_Msg.OneOf_Payload: @unchecked Sendable {}
extension Server_Msg.TypeEnum: @unchecked Sendable {}
extension Server_Presence: @unchecked Sendable {}
extension Server_Presence.TypeEnum: @unchecked Sendable {}
extension Server_ChatState: @unchecked Sendable {}
extension Server_ChatState.TypeEnum: @unchecked Sendable {}
extension Server_ChatState.ThreadType: @unchecked Sendable {}
extension Server_Ack: @unchecked Sendable {}
extension Server_HaError: @unchecked Sendable {}
extension Server_Packet: @unchecked Sendable {}
extension Server_Packet.OneOf_Stanza: @unchecked Sendable {}
extension Server_UidElement: @unchecked Sendable {}
extension Server_UidElement.Action: @unchecked Sendable {}
extension Server_PhoneElement: @unchecked Sendable {}
extension Server_PhoneElement.Action: @unchecked Sendable {}
extension Server_PrivacyList: @unchecked Sendable {}
extension Server_PrivacyList.TypeEnum: @unchecked Sendable {}
extension Server_PrivacyLists: @unchecked Sendable {}
extension Server_PrivacyLists.TypeEnum: @unchecked Sendable {}
extension Server_PushToken: @unchecked Sendable {}
extension Server_PushToken.TokenType: @unchecked Sendable {}
extension Server_PushRegister: @unchecked Sendable {}
extension Server_PushPref: @unchecked Sendable {}
extension Server_PushPref.Name: @unchecked Sendable {}
extension Server_NotificationPrefs: @unchecked Sendable {}
extension Server_Rerequest: @unchecked Sendable {}
extension Server_Rerequest.ContentType: @unchecked Sendable {}
extension Server_GroupFeedRerequest: @unchecked Sendable {}
extension Server_GroupFeedRerequest.RerequestType: @unchecked Sendable {}
extension Server_GroupFeedRerequest.ContentType: @unchecked Sendable {}
extension Server_HomeFeedRerequest: @unchecked Sendable {}
extension Server_HomeFeedRerequest.RerequestType: @unchecked Sendable {}
extension Server_HomeFeedRerequest.ContentType: @unchecked Sendable {}
extension Server_SeenReceipt: @unchecked Sendable {}
extension Server_DeliveryReceipt: @unchecked Sendable {}
extension Server_PlayedReceipt: @unchecked Sendable {}
extension Server_ScreenshotReceipt: @unchecked Sendable {}
extension Server_SavedReceipt: @unchecked Sendable {}
extension Server_GroupChatRetract: @unchecked Sendable {}
extension Server_ChatRetract: @unchecked Sendable {}
extension Server_Prop: @unchecked Sendable {}
extension Server_Props: @unchecked Sendable {}
extension Server_WhisperKeys: @unchecked Sendable {}
extension Server_WhisperKeys.Action: @unchecked Sendable {}
extension Server_TruncWhisperKeys: @unchecked Sendable {}
extension Server_WhisperKeysCollection: @unchecked Sendable {}
extension Server_TruncWhisperKeysCollection: @unchecked Sendable {}
extension Server_NoiseMessage: @unchecked Sendable {}
extension Server_NoiseMessage.MessageType: @unchecked Sendable {}
extension Server_DeleteAccount: @unchecked Sendable {}
extension Server_DeleteAccount.Reason: @unchecked Sendable {}
extension Server_ExportData: @unchecked Sendable {}
extension Server_ExportData.Status: @unchecked Sendable {}
extension Server_PushContent: @unchecked Sendable {}
extension Server_InviteeNotice: @unchecked Sendable {}
extension Server_Inviter: @unchecked Sendable {}
extension Server_IdentityKey: @unchecked Sendable {}
extension Server_RequestLogs: @unchecked Sendable {}
extension Server_RegisterRequest: @unchecked Sendable {}
extension Server_RegisterRequest.OneOf_Request: @unchecked Sendable {}
extension Server_RegisterResponse: @unchecked Sendable {}
extension Server_RegisterResponse.OneOf_Response: @unchecked Sendable {}
extension Server_HashcashRequest: @unchecked Sendable {}
extension Server_HashcashResponse: @unchecked Sendable {}
extension Server_OtpRequest: @unchecked Sendable {}
extension Server_OtpRequest.Method: @unchecked Sendable {}
extension Server_OtpResponse: @unchecked Sendable {}
extension Server_OtpResponse.Result: @unchecked Sendable {}
extension Server_OtpResponse.Reason: @unchecked Sendable {}
extension Server_VerifyOtpRequest: @unchecked Sendable {}
extension Server_VerifyOtpResponse: @unchecked Sendable {}
extension Server_VerifyOtpResponse.Result: @unchecked Sendable {}
extension Server_VerifyOtpResponse.Reason: @unchecked Sendable {}
extension Server_ClientOtpRequest: @unchecked Sendable {}
extension Server_ClientOtpRequest.Method: @unchecked Sendable {}
extension Server_ClientOtpResponse: @unchecked Sendable {}
extension Server_ClientOtpResponse.Result: @unchecked Sendable {}
extension Server_ClientOtpResponse.Reason: @unchecked Sendable {}
extension Server_WakeUp: @unchecked Sendable {}
extension Server_WakeUp.AlertType: @unchecked Sendable {}
extension Server_MarketingAlert: @unchecked Sendable {}
extension Server_MarketingAlert.TypeEnum: @unchecked Sendable {}
extension Server_BasicUserProfile: @unchecked Sendable {}
extension Server_UserProfile: @unchecked Sendable {}
extension Server_PostMetrics: @unchecked Sendable {}
extension Server_ProfileUpdate: @unchecked Sendable {}
extension Server_ProfileUpdate.TypeEnum: @unchecked Sendable {}
extension Server_UserProfileRequest: @unchecked Sendable {}
extension Server_UserProfileResult: @unchecked Sendable {}
extension Server_UserProfileResult.Result: @unchecked Sendable {}
extension Server_UserProfileResult.Reason: @unchecked Sendable {}
extension Server_PostMetricsRequest: @unchecked Sendable {}
extension Server_PostMetricsResult: @unchecked Sendable {}
extension Server_PostMetricsResult.Result: @unchecked Sendable {}
extension Server_PostMetricsResult.Reason: @unchecked Sendable {}
extension Server_RelationshipRequest: @unchecked Sendable {}
extension Server_RelationshipRequest.Action: @unchecked Sendable {}
extension Server_RelationshipResponse: @unchecked Sendable {}
extension Server_RelationshipResponse.Result: @unchecked Sendable {}
extension Server_RelationshipList: @unchecked Sendable {}
extension Server_RelationshipList.TypeEnum: @unchecked Sendable {}
extension Server_UsernameRequest: @unchecked Sendable {}
extension Server_UsernameRequest.Action: @unchecked Sendable {}
extension Server_UsernameResponse: @unchecked Sendable {}
extension Server_UsernameResponse.Result: @unchecked Sendable {}
extension Server_UsernameResponse.Reason: @unchecked Sendable {}
extension Server_GeoTagRequest: @unchecked Sendable {}
extension Server_GeoTagRequest.Action: @unchecked Sendable {}
extension Server_GeoTagResponse: @unchecked Sendable {}
extension Server_GeoTagResponse.Result: @unchecked Sendable {}
extension Server_GeoTagResponse.Reason: @unchecked Sendable {}
extension Server_SearchRequest: @unchecked Sendable {}
extension Server_SearchResponse: @unchecked Sendable {}
extension Server_SearchResponse.Result: @unchecked Sendable {}
extension Server_FollowSuggestionsRequest: @unchecked Sendable {}
extension Server_FollowSuggestionsRequest.Action: @unchecked Sendable {}
extension Server_SuggestedProfile: @unchecked Sendable {}
extension Server_SuggestedProfile.Reason: @unchecked Sendable {}
extension Server_FollowSuggestionsResponse: @unchecked Sendable {}
extension Server_FollowSuggestionsResponse.Result: @unchecked Sendable {}
extension Server_Link: @unchecked Sendable {}
extension Server_Link.TypeEnum: @unchecked Sendable {}
extension Server_SetLinkRequest: @unchecked Sendable {}
extension Server_SetLinkRequest.Action: @unchecked Sendable {}
extension Server_SetLinkResult: @unchecked Sendable {}
extension Server_SetLinkResult.Result: @unchecked Sendable {}
extension Server_SetLinkResult.Reason: @unchecked Sendable {}
extension Server_SetBioRequest: @unchecked Sendable {}
extension Server_SetBioResult: @unchecked Sendable {}
extension Server_SetBioResult.Result: @unchecked Sendable {}
extension Server_SetBioResult.Reason: @unchecked Sendable {}
extension Server_AiImageRequest: @unchecked Sendable {}
extension Server_AiImageRequest.PromptMode: @unchecked Sendable {}
extension Server_AiImageResult: @unchecked Sendable {}
extension Server_AiImageResult.Result: @unchecked Sendable {}
extension Server_AiImageResult.Reason: @unchecked Sendable {}
extension Server_AiImage: @unchecked Sendable {}
extension Server_TimeRange: @unchecked Sendable {}
extension Server_Album: @unchecked Sendable {}
extension Server_Album.Action: @unchecked Sendable {}
extension Server_AlbumResult: @unchecked Sendable {}
extension Server_AlbumResult.Result: @unchecked Sendable {}
extension Server_AlbumResult.Reason: @unchecked Sendable {}
extension Server_AlbumMember: @unchecked Sendable {}
extension Server_AlbumMember.Action: @unchecked Sendable {}
extension Server_AlbumMember.Role: @unchecked Sendable {}
extension Server_GetAlbums: @unchecked Sendable {}
extension Server_GetAlbums.TypeEnum: @unchecked Sendable {}
extension Server_MediaItem: @unchecked Sendable {}
extension Server_FriendshipRequest: @unchecked Sendable {}
extension Server_FriendshipRequest.Action: @unchecked Sendable {}
extension Server_FriendshipResponse: @unchecked Sendable {}
extension Server_FriendshipResponse.Result: @unchecked Sendable {}
extension Server_HalloappUserProfile: @unchecked Sendable {}
extension Server_HalloappProfileUpdate: @unchecked Sendable {}
extension Server_HalloappProfileUpdate.TypeEnum: @unchecked Sendable {}
extension Server_HalloappSearchRequest: @unchecked Sendable {}
extension Server_HalloappSearchResponse: @unchecked Sendable {}
extension Server_HalloappSearchResponse.Result: @unchecked Sendable {}
extension Server_HalloappProfileRequest: @unchecked Sendable {}
extension Server_HalloappProfileResult: @unchecked Sendable {}
extension Server_HalloappProfileResult.Result: @unchecked Sendable {}
extension Server_HalloappProfileResult.Reason: @unchecked Sendable {}
extension Server_FriendListRequest: @unchecked Sendable {}
extension Server_FriendListRequest.Action: @unchecked Sendable {}
extension Server_FriendProfile: @unchecked Sendable {}
extension Server_FriendProfile.Reason: @unchecked Sendable {}
extension Server_FriendListResponse: @unchecked Sendable {}
extension Server_FriendListResponse.Result: @unchecked Sendable {}
extension Server_ReverseGeocodeRequest: @unchecked Sendable {}
extension Server_ReverseGeocodeLocation: @unchecked Sendable {}
extension Server_ReverseGeocodeResult: @unchecked Sendable {}
extension Server_ReverseGeocodeResult.Result: @unchecked Sendable {}
extension Server_ReverseGeocodeResult.Reason: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_PublicFeedContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOMENTS"),
    1: .same(proto: "POSTS"),
  ]
}

extension Server_CallType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO"),
    2: .same(proto: "VIDEO"),
  ]
}

extension Server_FollowStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "FOLLOWING"),
  ]
}

extension Server_AlbumAccess: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVITE_ONLY"),
    1: .same(proto: "EVERYONE"),
  ]
}

extension Server_FriendshipStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE_STATUS"),
    1: .same(proto: "INCOMING_PENDING"),
    2: .same(proto: "OUTGOING_PENDING"),
    3: .same(proto: "FRIENDS"),
  ]
}

extension Server_UploadAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadAvatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
    3: .standard(proto: "full_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.fullData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.fullData.isEmpty {
      try visitor.visitSingularBytesField(value: self.fullData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadAvatar, rhs: Server_UploadAvatar) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.data != rhs.data {return false}
    if lhs.fullData != rhs.fullData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Avatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Avatar, rhs: Server_Avatar) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Avatars: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Avatars"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.avatars) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.avatars, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Avatars, rhs: Server_Avatars) -> Bool {
    if lhs.avatars != rhs.avatars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadGroupAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadGroupAvatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "data"),
    3: .standard(proto: "full_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.fullData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.fullData.isEmpty {
      try visitor.visitSingularBytesField(value: self.fullData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadGroupAvatar, rhs: Server_UploadGroupAvatar) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.data != rhs.data {return false}
    if lhs.fullData != rhs.fullData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CertMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "server_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.serverKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.serverKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CertMessage, rhs: Server_CertMessage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.serverKey != rhs.serverKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .active {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientMode, rhs: Server_ClientMode) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientMode.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "PASSIVE"),
  ]
}

extension Server_ClientVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "expires_in_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.expiresInSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.expiresInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresInSeconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientVersion, rhs: Server_ClientVersion) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.expiresInSeconds != rhs.expiresInSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .standard(proto: "os_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.device) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.device.isEmpty {
      try visitor.visitSingularStringField(value: self.device, fieldNumber: 1)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DeviceInfo, rhs: Server_DeviceInfo) -> Bool {
    if lhs.device != rhs.device {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counts"),
    2: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.counts) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.counts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.counts, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientLog, rhs: Server_ClientLog) -> Bool {
    if lhs.counts != rhs.counts {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Count"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .same(proto: "metric"),
    3: .same(proto: "count"),
    4: .same(proto: "dims"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metric) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.dims) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.metric.isEmpty {
      try visitor.visitSingularStringField(value: self.metric, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    if !self.dims.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dims, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Count, rhs: Server_Count) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.metric != rhs.metric {return false}
    if lhs.count != rhs.count {return false}
    if lhs.dims != rhs.dims {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Dim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dim"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Dim, rhs: Server_Dim) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "raw"),
    3: .same(proto: "normalized"),
    4: .same(proto: "uid"),
    5: .standard(proto: "avatar_id"),
    7: .same(proto: "name"),
    8: .standard(proto: "num_potential_friends"),
    9: .standard(proto: "num_potential_close_friends"),
    10: .standard(proto: "invitation_rank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.raw) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.normalized) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.numPotentialFriends) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.numPotentialCloseFriends) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.invitationRank) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 2)
    }
    if !self.normalized.isEmpty {
      try visitor.visitSingularStringField(value: self.normalized, fieldNumber: 3)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    if self.numPotentialFriends != 0 {
      try visitor.visitSingularInt64Field(value: self.numPotentialFriends, fieldNumber: 8)
    }
    if self.numPotentialCloseFriends != 0 {
      try visitor.visitSingularInt64Field(value: self.numPotentialCloseFriends, fieldNumber: 9)
    }
    if self.invitationRank != 0 {
      try visitor.visitSingularInt64Field(value: self.invitationRank, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Contact, rhs: Server_Contact) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.normalized != rhs.normalized {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.numPotentialFriends != rhs.numPotentialFriends {return false}
    if lhs.numPotentialCloseFriends != rhs.numPotentialCloseFriends {return false}
    if lhs.invitationRank != rhs.invitationRank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Contact.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_ContactList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "sync_id"),
    3: .standard(proto: "batch_index"),
    4: .standard(proto: "is_last"),
    5: .same(proto: "contacts"),
    6: .standard(proto: "has_permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.syncID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.batchIndex) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isLast) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.hasPermissions_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .full {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.syncID.isEmpty {
      try visitor.visitSingularStringField(value: self.syncID, fieldNumber: 2)
    }
    if self.batchIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.batchIndex, fieldNumber: 3)
    }
    if self.isLast != false {
      try visitor.visitSingularBoolField(value: self.isLast, fieldNumber: 4)
    }
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 5)
    }
    if self.hasPermissions_p != false {
      try visitor.visitSingularBoolField(value: self.hasPermissions_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactList, rhs: Server_ContactList) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.syncID != rhs.syncID {return false}
    if lhs.batchIndex != rhs.batchIndex {return false}
    if lhs.isLast != rhs.isLast {return false}
    if lhs.contacts != rhs.contacts {return false}
    if lhs.hasPermissions_p != rhs.hasPermissions_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ContactList.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FULL"),
    1: .same(proto: "DELTA"),
    2: .same(proto: "NORMAL"),
    3: .same(proto: "FRIEND_NOTICE"),
    4: .same(proto: "INVITER_NOTICE"),
    5: .same(proto: "DELETE_NOTICE"),
    6: .same(proto: "CONTACT_NOTICE"),
  ]
}

extension Server_ContactHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactHash, rhs: Server_ContactHash) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ContactSyncError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactSyncError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retry_after_secs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.retryAfterSecs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retryAfterSecs != 0 {
      try visitor.visitSingularInt32Field(value: self.retryAfterSecs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactSyncError, rhs: Server_ContactSyncError) -> Bool {
    if lhs.retryAfterSecs != rhs.retryAfterSecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MomentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notification_timestamp"),
    2: .standard(proto: "time_taken"),
    3: .standard(proto: "num_takes"),
    4: .standard(proto: "num_selfie_takes"),
    5: .standard(proto: "notification_id"),
    6: .standard(proto: "content_type"),
    7: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.notificationTimestamp) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeTaken) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.numTakes) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.numSelfieTakes) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.notificationID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.notificationTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.notificationTimestamp, fieldNumber: 1)
    }
    if self.timeTaken != 0 {
      try visitor.visitSingularInt64Field(value: self.timeTaken, fieldNumber: 2)
    }
    if self.numTakes != 0 {
      try visitor.visitSingularInt64Field(value: self.numTakes, fieldNumber: 3)
    }
    if self.numSelfieTakes != 0 {
      try visitor.visitSingularInt64Field(value: self.numSelfieTakes, fieldNumber: 4)
    }
    if self.notificationID != 0 {
      try visitor.visitSingularInt64Field(value: self.notificationID, fieldNumber: 5)
    }
    if self.contentType != .image {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 6)
    }
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MomentInfo, rhs: Server_MomentInfo) -> Bool {
    if lhs.notificationTimestamp != rhs.notificationTimestamp {return false}
    if lhs.timeTaken != rhs.timeTaken {return false}
    if lhs.numTakes != rhs.numTakes {return false}
    if lhs.numSelfieTakes != rhs.numSelfieTakes {return false}
    if lhs.notificationID != rhs.notificationID {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.date != rhs.date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MomentInfo.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMAGE"),
    1: .same(proto: "VIDEO"),
    2: .same(proto: "TEXT"),
    3: .same(proto: "ALBUM_IMAGE"),
    4: .same(proto: "ALBUM_DUMP"),
  ]
}

extension Server_MediaCounters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaCounters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_images"),
    2: .standard(proto: "num_videos"),
    3: .standard(proto: "num_audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numImages) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numVideos) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numAudio) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numImages != 0 {
      try visitor.visitSingularInt32Field(value: self.numImages, fieldNumber: 1)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularInt32Field(value: self.numVideos, fieldNumber: 2)
    }
    if self.numAudio != 0 {
      try visitor.visitSingularInt32Field(value: self.numAudio, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaCounters, rhs: Server_MediaCounters) -> Bool {
    if lhs.numImages != rhs.numImages {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.numAudio != rhs.numAudio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Audience: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Audience"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "uids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.uids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.uids.isEmpty {
      try visitor.visitPackedInt64Field(value: self.uids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Audience, rhs: Server_Audience) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.uids != rhs.uids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Audience.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "EXCEPT"),
    2: .same(proto: "ONLY"),
  ]
}

extension Server_Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Post"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "publisher_uid"),
    3: .same(proto: "payload"),
    4: .same(proto: "audience"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "publisher_name"),
    7: .standard(proto: "enc_payload"),
    8: .standard(proto: "media_counters"),
    9: .same(proto: "tag"),
    10: .standard(proto: "psa_tag"),
    11: .standard(proto: "moment_unlock_uid"),
    12: .standard(proto: "show_post_share_screen"),
    13: .standard(proto: "moment_info"),
    14: .standard(proto: "is_expired"),
    15: .standard(proto: "publisher_username"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _publisherUid: Int64 = 0
    var _payload: Data = Data()
    var _audience: Server_Audience? = nil
    var _timestamp: Int64 = 0
    var _publisherName: String = String()
    var _encPayload: Data = Data()
    var _mediaCounters: Server_MediaCounters? = nil
    var _tag: Server_Post.Tag = .empty
    var _psaTag: String = String()
    var _momentUnlockUid: Int64 = 0
    var _showPostShareScreen: Bool = false
    var _momentInfo: Server_MomentInfo? = nil
    var _isExpired: Bool = false
    var _publisherUsername: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _publisherUid = source._publisherUid
      _payload = source._payload
      _audience = source._audience
      _timestamp = source._timestamp
      _publisherName = source._publisherName
      _encPayload = source._encPayload
      _mediaCounters = source._mediaCounters
      _tag = source._tag
      _psaTag = source._psaTag
      _momentUnlockUid = source._momentUnlockUid
      _showPostShareScreen = source._showPostShareScreen
      _momentInfo = source._momentInfo
      _isExpired = source._isExpired
      _publisherUsername = source._publisherUsername
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._publisherUid) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._payload) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._audience) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._publisherName) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._encPayload) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._mediaCounters) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._tag) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._psaTag) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._momentUnlockUid) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._showPostShareScreen) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._momentInfo) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._isExpired) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._publisherUsername) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._publisherUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._publisherUid, fieldNumber: 2)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 3)
      }
      try { if let v = _storage._audience {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 5)
      }
      if !_storage._publisherName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._publisherName, fieldNumber: 6)
      }
      if !_storage._encPayload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encPayload, fieldNumber: 7)
      }
      try { if let v = _storage._mediaCounters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._tag != .empty {
        try visitor.visitSingularEnumField(value: _storage._tag, fieldNumber: 9)
      }
      if !_storage._psaTag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._psaTag, fieldNumber: 10)
      }
      if _storage._momentUnlockUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._momentUnlockUid, fieldNumber: 11)
      }
      if _storage._showPostShareScreen != false {
        try visitor.visitSingularBoolField(value: _storage._showPostShareScreen, fieldNumber: 12)
      }
      try { if let v = _storage._momentInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._isExpired != false {
        try visitor.visitSingularBoolField(value: _storage._isExpired, fieldNumber: 14)
      }
      if !_storage._publisherUsername.isEmpty {
        try visitor.visitSingularStringField(value: _storage._publisherUsername, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Post, rhs: Server_Post) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._publisherUid != rhs_storage._publisherUid {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._audience != rhs_storage._audience {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._publisherName != rhs_storage._publisherName {return false}
        if _storage._encPayload != rhs_storage._encPayload {return false}
        if _storage._mediaCounters != rhs_storage._mediaCounters {return false}
        if _storage._tag != rhs_storage._tag {return false}
        if _storage._psaTag != rhs_storage._psaTag {return false}
        if _storage._momentUnlockUid != rhs_storage._momentUnlockUid {return false}
        if _storage._showPostShareScreen != rhs_storage._showPostShareScreen {return false}
        if _storage._momentInfo != rhs_storage._momentInfo {return false}
        if _storage._isExpired != rhs_storage._isExpired {return false}
        if _storage._publisherUsername != rhs_storage._publisherUsername {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Post.Tag: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY"),
    1: .same(proto: "MOMENT"),
    2: .same(proto: "PUBLIC_MOMENT"),
    3: .same(proto: "PUBLIC_POST"),
  ]
}

extension Server_Comment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Comment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "post_id"),
    3: .standard(proto: "parent_comment_id"),
    4: .standard(proto: "publisher_uid"),
    5: .standard(proto: "publisher_name"),
    6: .same(proto: "payload"),
    7: .same(proto: "timestamp"),
    8: .standard(proto: "enc_payload"),
    9: .standard(proto: "media_counters"),
    10: .standard(proto: "comment_type"),
    11: .standard(proto: "publisher_username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parentCommentID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.publisherUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.publisherName) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._mediaCounters) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.commentType) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.publisherUsername) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 2)
    }
    if !self.parentCommentID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentCommentID, fieldNumber: 3)
    }
    if self.publisherUid != 0 {
      try visitor.visitSingularInt64Field(value: self.publisherUid, fieldNumber: 4)
    }
    if !self.publisherName.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherName, fieldNumber: 5)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 6)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 7)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 8)
    }
    try { if let v = self._mediaCounters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.commentType != .comment {
      try visitor.visitSingularEnumField(value: self.commentType, fieldNumber: 10)
    }
    if !self.publisherUsername.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherUsername, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Comment, rhs: Server_Comment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.parentCommentID != rhs.parentCommentID {return false}
    if lhs.publisherUid != rhs.publisherUid {return false}
    if lhs.publisherName != rhs.publisherName {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs._mediaCounters != rhs._mediaCounters {return false}
    if lhs.commentType != rhs.commentType {return false}
    if lhs.publisherUsername != rhs.publisherUsername {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Comment.CommentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMENT"),
    1: .same(proto: "COMMENT_REACTION"),
    2: .same(proto: "POST_REACTION"),
  ]
}

extension Server_ShareStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "post_ids"),
    3: .same(proto: "result"),
    4: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.postIds) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.postIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.postIds, fieldNumber: 2)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ShareStanza, rhs: Server_ShareStanza) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.postIds != rhs.postIds {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "post"),
    3: .same(proto: "comment"),
    4: .standard(proto: "share_stanzas"),
    5: .standard(proto: "sender_state_bundles"),
    6: .standard(proto: "sender_state"),
    7: .standard(proto: "sender_client_version"),
  ]

  fileprivate class _StorageClass {
    var _action: Server_FeedItem.Action = .publish
    var _item: Server_FeedItem.OneOf_Item?
    var _shareStanzas: [Server_ShareStanza] = []
    var _senderStateBundles: [Server_SenderStateBundle] = []
    var _senderState: Server_SenderStateWithKeyInfo? = nil
    var _senderClientVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _item = source._item
      _shareStanzas = source._shareStanzas
      _senderStateBundles = source._senderStateBundles
      _senderState = source._senderState
      _senderClientVersion = source._senderClientVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 2: try {
          var v: Server_Post?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .post(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .post(v)
          }
        }()
        case 3: try {
          var v: Server_Comment?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .comment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .comment(v)
          }
        }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._shareStanzas) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._senderStateBundles) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._senderState) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._senderClientVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._action != .publish {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 1)
      }
      switch _storage._item {
      case .post?: try {
        guard case .post(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .comment?: try {
        guard case .comment(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if !_storage._shareStanzas.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._shareStanzas, fieldNumber: 4)
      }
      if !_storage._senderStateBundles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._senderStateBundles, fieldNumber: 5)
      }
      try { if let v = _storage._senderState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._senderClientVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderClientVersion, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FeedItem, rhs: Server_FeedItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._shareStanzas != rhs_storage._shareStanzas {return false}
        if _storage._senderStateBundles != rhs_storage._senderStateBundles {return false}
        if _storage._senderState != rhs_storage._senderState {return false}
        if _storage._senderClientVersion != rhs_storage._senderClientVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FeedItem.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLISH"),
    1: .same(proto: "RETRACT"),
    2: .same(proto: "SHARE"),
    3: .same(proto: "PUBLIC_UPDATE_PUBLISH"),
    4: .same(proto: "EXPIRE"),
    5: .same(proto: "PUBLIC_UPDATE_RETRACT"),
  ]
}

extension Server_FeedItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedItems"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FeedItems, rhs: Server_FeedItems) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PublicFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .standard(proto: "public_feed_content_type"),
    3: .standard(proto: "gps_location"),
    4: .standard(proto: "show_dev_content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.publicFeedContentType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gpsLocation) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showDevContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 1)
    }
    if self.publicFeedContentType != .moments {
      try visitor.visitSingularEnumField(value: self.publicFeedContentType, fieldNumber: 2)
    }
    try { if let v = self._gpsLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.showDevContent != false {
      try visitor.visitSingularBoolField(value: self.showDevContent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PublicFeedRequest, rhs: Server_PublicFeedRequest) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs.publicFeedContentType != rhs.publicFeedContentType {return false}
    if lhs._gpsLocation != rhs._gpsLocation {return false}
    if lhs.showDevContent != rhs.showDevContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PublicFeedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicFeedResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "cursor"),
    4: .standard(proto: "public_feed_content_type"),
    5: .standard(proto: "cursor_restarted"),
    6: .same(proto: "items"),
    7: .standard(proto: "geo_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.publicFeedContentType) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.cursorRestarted) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.geoTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 3)
    }
    if self.publicFeedContentType != .moments {
      try visitor.visitSingularEnumField(value: self.publicFeedContentType, fieldNumber: 4)
    }
    if self.cursorRestarted != false {
      try visitor.visitSingularBoolField(value: self.cursorRestarted, fieldNumber: 5)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 6)
    }
    if !self.geoTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.geoTags, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PublicFeedResponse, rhs: Server_PublicFeedResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.publicFeedContentType != rhs.publicFeedContentType {return false}
    if lhs.cursorRestarted != rhs.cursorRestarted {return false}
    if lhs.items != rhs.items {return false}
    if lhs.geoTags != rhs.geoTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PublicFeedResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_PublicFeedResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "OK"),
  ]
}

extension Server_PublicFeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicFeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_profile"),
    2: .same(proto: "post"),
    3: .same(proto: "comments"),
    4: .same(proto: "reason"),
    5: .same(proto: "score"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userProfile) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._post) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.comments) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._score) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._post {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.comments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.comments, fieldNumber: 3)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 4)
    }
    try { if let v = self._score {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PublicFeedItem, rhs: Server_PublicFeedItem) -> Bool {
    if lhs._userProfile != rhs._userProfile {return false}
    if lhs._post != rhs._post {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._score != rhs._score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PublicFeedItem.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "CAMPUS"),
    2: .same(proto: "FOF"),
  ]
}

extension Server_ServerScore: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerScore"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "explanation"),
    3: .same(proto: "dscore"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.score) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.dscore) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularInt64Field(value: self.score, fieldNumber: 1)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 2)
    }
    if self.dscore != 0 {
      try visitor.visitSingularDoubleField(value: self.dscore, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ServerScore, rhs: Server_ServerScore) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.dscore != rhs.dscore {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PublicFeedUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicFeedUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .standard(proto: "public_feed_content_type"),
    3: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.publicFeedContentType) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 1)
    }
    if self.publicFeedContentType != .moments {
      try visitor.visitSingularEnumField(value: self.publicFeedContentType, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PublicFeedUpdate, rhs: Server_PublicFeedUpdate) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs.publicFeedContentType != rhs.publicFeedContentType {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GpsLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GpsLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GpsLocation, rhs: Server_GpsLocation) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PostSubscriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostSubscriptionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "post_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .unknownAction {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PostSubscriptionRequest, rhs: Server_PostSubscriptionRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PostSubscriptionRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTION"),
    1: .same(proto: "SUBSCRIBE"),
    2: .same(proto: "UNSUBSCRIBE"),
  ]
}

extension Server_PostSubscriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostSubscriptionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PostSubscriptionResponse, rhs: Server_PostSubscriptionResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PostSubscriptionResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_PostSubscriptionResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "INVALID_POST_ID"),
  ]
}

extension Server_SenderStateWithKeyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SenderStateWithKeyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "one_time_pre_key_id"),
    3: .standard(proto: "enc_sender_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encSenderState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 2)
    }
    if !self.encSenderState.isEmpty {
      try visitor.visitSingularBytesField(value: self.encSenderState, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SenderStateWithKeyInfo, rhs: Server_SenderStateWithKeyInfo) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.encSenderState != rhs.encSenderState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SenderStateBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SenderStateBundle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_state"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._senderState) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._senderState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SenderStateBundle, rhs: Server_SenderStateBundle) -> Bool {
    if lhs._senderState != rhs._senderState {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .same(proto: "post"),
    6: .same(proto: "comment"),
    7: .standard(proto: "sender_state_bundles"),
    8: .standard(proto: "sender_state"),
    9: .standard(proto: "audience_hash"),
    10: .standard(proto: "is_resent_history"),
    11: .standard(proto: "expiry_timestamp"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  fileprivate class _StorageClass {
    var _action: Server_GroupFeedItem.Action = .publish
    var _gid: String = String()
    var _name: String = String()
    var _avatarID: String = String()
    var _item: Server_GroupFeedItem.OneOf_Item?
    var _senderStateBundles: [Server_SenderStateBundle] = []
    var _senderState: Server_SenderStateWithKeyInfo? = nil
    var _audienceHash: Data = Data()
    var _isResentHistory: Bool = false
    var _expiryTimestamp: Int64 = 0
    var _senderLogInfo: String = String()
    var _senderClientVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _gid = source._gid
      _name = source._name
      _avatarID = source._avatarID
      _item = source._item
      _senderStateBundles = source._senderStateBundles
      _senderState = source._senderState
      _audienceHash = source._audienceHash
      _isResentHistory = source._isResentHistory
      _expiryTimestamp = source._expiryTimestamp
      _senderLogInfo = source._senderLogInfo
      _senderClientVersion = source._senderClientVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._gid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarID) }()
        case 5: try {
          var v: Server_Post?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .post(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .post(v)
          }
        }()
        case 6: try {
          var v: Server_Comment?
          var hadOneofValue = false
          if let current = _storage._item {
            hadOneofValue = true
            if case .comment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._item = .comment(v)
          }
        }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._senderStateBundles) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._senderState) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._audienceHash) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isResentHistory) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._expiryTimestamp) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._senderLogInfo) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._senderClientVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._action != .publish {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 1)
      }
      if !_storage._gid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gid, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._avatarID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarID, fieldNumber: 4)
      }
      switch _storage._item {
      case .post?: try {
        guard case .post(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .comment?: try {
        guard case .comment(let v)? = _storage._item else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      if !_storage._senderStateBundles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._senderStateBundles, fieldNumber: 7)
      }
      try { if let v = _storage._senderState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._audienceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._audienceHash, fieldNumber: 9)
      }
      if _storage._isResentHistory != false {
        try visitor.visitSingularBoolField(value: _storage._isResentHistory, fieldNumber: 10)
      }
      if _storage._expiryTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._expiryTimestamp, fieldNumber: 11)
      }
      if !_storage._senderLogInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderLogInfo, fieldNumber: 16)
      }
      if !_storage._senderClientVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderClientVersion, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedItem, rhs: Server_GroupFeedItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._gid != rhs_storage._gid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatarID != rhs_storage._avatarID {return false}
        if _storage._item != rhs_storage._item {return false}
        if _storage._senderStateBundles != rhs_storage._senderStateBundles {return false}
        if _storage._senderState != rhs_storage._senderState {return false}
        if _storage._audienceHash != rhs_storage._audienceHash {return false}
        if _storage._isResentHistory != rhs_storage._isResentHistory {return false}
        if _storage._expiryTimestamp != rhs_storage._expiryTimestamp {return false}
        if _storage._senderLogInfo != rhs_storage._senderLogInfo {return false}
        if _storage._senderClientVersion != rhs_storage._senderClientVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedItem.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLISH"),
    1: .same(proto: "RETRACT"),
    2: .same(proto: "SHARE"),
  ]
}

extension Server_GroupFeedItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedItems"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "name"),
    3: .standard(proto: "avatar_id"),
    4: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 3)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedItems, rhs: Server_GroupFeedItems) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedHistory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "id"),
    3: .same(proto: "payload"),
    4: .standard(proto: "enc_payload"),
    5: .standard(proto: "public_key"),
    6: .standard(proto: "one_time_pre_key_id"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.oneTimePreKeyID) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.senderLogInfo) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.senderClientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 5)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.oneTimePreKeyID, fieldNumber: 6)
    }
    if !self.senderLogInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.senderLogInfo, fieldNumber: 16)
    }
    if !self.senderClientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderClientVersion, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedHistory, rhs: Server_GroupFeedHistory) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.senderLogInfo != rhs.senderLogInfo {return false}
    if lhs.senderClientVersion != rhs.senderClientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMember"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
    3: .same(proto: "type"),
    4: .same(proto: "name"),
    5: .standard(proto: "avatar_id"),
    6: .same(proto: "result"),
    7: .same(proto: "reason"),
    8: .standard(proto: "identity_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    if self.type != .member {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 6)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 7)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupMember, rhs: Server_GroupMember) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupMember.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "REMOVE"),
    2: .same(proto: "PROMOTE"),
    3: .same(proto: "DEMOTE"),
    4: .same(proto: "LEAVE"),
    5: .same(proto: "JOIN"),
  ]
}

extension Server_GroupMember.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER"),
    1: .same(proto: "ADMIN"),
  ]
}

extension Server_GroupStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .standard(proto: "sender_uid"),
    6: .standard(proto: "sender_name"),
    7: .same(proto: "members"),
    8: .same(proto: "background"),
    9: .standard(proto: "audience_hash"),
    10: .same(proto: "description"),
    11: .standard(proto: "history_resend"),
    12: .standard(proto: "expiry_info"),
    13: .standard(proto: "group_type"),
    14: .standard(proto: "max_group_size"),
  ]

  fileprivate class _StorageClass {
    var _action: Server_GroupStanza.Action = .set
    var _gid: String = String()
    var _name: String = String()
    var _avatarID: String = String()
    var _senderUid: Int64 = 0
    var _senderName: String = String()
    var _members: [Server_GroupMember] = []
    var _background: String = String()
    var _audienceHash: Data = Data()
    var _description_p: String = String()
    var _historyResend: Server_HistoryResend? = nil
    var _expiryInfo: Server_ExpiryInfo? = nil
    var _groupType: Server_GroupStanza.GroupType = .feed
    var _maxGroupSize: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _action = source._action
      _gid = source._gid
      _name = source._name
      _avatarID = source._avatarID
      _senderUid = source._senderUid
      _senderName = source._senderName
      _members = source._members
      _background = source._background
      _audienceHash = source._audienceHash
      _description_p = source._description_p
      _historyResend = source._historyResend
      _expiryInfo = source._expiryInfo
      _groupType = source._groupType
      _maxGroupSize = source._maxGroupSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._gid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._avatarID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._senderUid) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._senderName) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._members) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._background) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._audienceHash) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._historyResend) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._expiryInfo) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._groupType) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._maxGroupSize) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._action != .set {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 1)
      }
      if !_storage._gid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gid, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._avatarID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarID, fieldNumber: 4)
      }
      if _storage._senderUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._senderUid, fieldNumber: 5)
      }
      if !_storage._senderName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderName, fieldNumber: 6)
      }
      if !_storage._members.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._members, fieldNumber: 7)
      }
      if !_storage._background.isEmpty {
        try visitor.visitSingularStringField(value: _storage._background, fieldNumber: 8)
      }
      if !_storage._audienceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._audienceHash, fieldNumber: 9)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 10)
      }
      try { if let v = _storage._historyResend {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._expiryInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._groupType != .feed {
        try visitor.visitSingularEnumField(value: _storage._groupType, fieldNumber: 13)
      }
      if _storage._maxGroupSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxGroupSize, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupStanza, rhs: Server_GroupStanza) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._action != rhs_storage._action {return false}
        if _storage._gid != rhs_storage._gid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatarID != rhs_storage._avatarID {return false}
        if _storage._senderUid != rhs_storage._senderUid {return false}
        if _storage._senderName != rhs_storage._senderName {return false}
        if _storage._members != rhs_storage._members {return false}
        if _storage._background != rhs_storage._background {return false}
        if _storage._audienceHash != rhs_storage._audienceHash {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._historyResend != rhs_storage._historyResend {return false}
        if _storage._expiryInfo != rhs_storage._expiryInfo {return false}
        if _storage._groupType != rhs_storage._groupType {return false}
        if _storage._maxGroupSize != rhs_storage._maxGroupSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupStanza.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET"),
    1: .same(proto: "GET"),
    2: .same(proto: "CREATE"),
    3: .same(proto: "DELETE"),
    4: .same(proto: "LEAVE"),
    5: .same(proto: "CHANGE_AVATAR"),
    6: .same(proto: "CHANGE_NAME"),
    7: .same(proto: "MODIFY_ADMINS"),
    8: .same(proto: "MODIFY_MEMBERS"),
    9: .same(proto: "AUTO_PROMOTE_ADMINS"),
    10: .same(proto: "SET_NAME"),
    11: .same(proto: "JOIN"),
    12: .same(proto: "PREVIEW"),
    13: .same(proto: "SET_BACKGROUND"),
    14: .same(proto: "GET_MEMBER_IDENTITY_KEYS"),
    15: .same(proto: "CHANGE_DESCRIPTION"),
    16: .same(proto: "SHARE_HISTORY"),
    17: .same(proto: "CHANGE_EXPIRY"),
  ]
}

extension Server_GroupStanza.GroupType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEED"),
    1: .same(proto: "CHAT"),
  ]
}

extension Server_ExpiryInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExpiryInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    12: .standard(proto: "expiry_type"),
    13: .standard(proto: "expires_in_seconds"),
    14: .standard(proto: "expiry_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 12: try { try decoder.decodeSingularEnumField(value: &self.expiryType) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.expiresInSeconds) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.expiryTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expiryType != .expiresInSeconds {
      try visitor.visitSingularEnumField(value: self.expiryType, fieldNumber: 12)
    }
    if self.expiresInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresInSeconds, fieldNumber: 13)
    }
    if self.expiryTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.expiryTimestamp, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ExpiryInfo, rhs: Server_ExpiryInfo) -> Bool {
    if lhs.expiryType != rhs.expiryType {return false}
    if lhs.expiresInSeconds != rhs.expiresInSeconds {return false}
    if lhs.expiryTimestamp != rhs.expiryTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ExpiryInfo.ExpiryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXPIRES_IN_SECONDS"),
    1: .same(proto: "NEVER"),
    2: .same(proto: "CUSTOM_DATE"),
  ]
}

extension Server_GroupChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "name"),
    3: .standard(proto: "avatar_id"),
    4: .standard(proto: "sender_uid"),
    5: .standard(proto: "sender_name"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.senderUid) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.senderName) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 3)
    }
    if self.senderUid != 0 {
      try visitor.visitSingularInt64Field(value: self.senderUid, fieldNumber: 4)
    }
    if !self.senderName.isEmpty {
      try visitor.visitSingularStringField(value: self.senderName, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupChat, rhs: Server_GroupChat) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.senderUid != rhs.senderUid {return false}
    if lhs.senderName != rhs.senderName {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupChatStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChatStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "name"),
    3: .standard(proto: "avatar_id"),
    4: .standard(proto: "sender_phone"),
    5: .standard(proto: "sender_name"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "payload"),
    8: .standard(proto: "enc_payload"),
    9: .standard(proto: "sender_state_bundles"),
    10: .standard(proto: "sender_state"),
    11: .standard(proto: "audience_hash"),
    12: .standard(proto: "media_counters"),
    13: .standard(proto: "chat_type"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  fileprivate class _StorageClass {
    var _gid: String = String()
    var _name: String = String()
    var _avatarID: String = String()
    var _senderPhone: String = String()
    var _senderName: String = String()
    var _timestamp: Int64 = 0
    var _payload: Data = Data()
    var _encPayload: Data = Data()
    var _senderStateBundles: [Server_SenderStateBundle] = []
    var _senderState: Server_SenderStateWithKeyInfo? = nil
    var _audienceHash: Data = Data()
    var _mediaCounters: Server_MediaCounters? = nil
    var _chatType: Server_GroupChatStanza.ChatType = .chat
    var _senderLogInfo: String = String()
    var _senderClientVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _gid = source._gid
      _name = source._name
      _avatarID = source._avatarID
      _senderPhone = source._senderPhone
      _senderName = source._senderName
      _timestamp = source._timestamp
      _payload = source._payload
      _encPayload = source._encPayload
      _senderStateBundles = source._senderStateBundles
      _senderState = source._senderState
      _audienceHash = source._audienceHash
      _mediaCounters = source._mediaCounters
      _chatType = source._chatType
      _senderLogInfo = source._senderLogInfo
      _senderClientVersion = source._senderClientVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._gid) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._avatarID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._senderPhone) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._senderName) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._payload) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._encPayload) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._senderStateBundles) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._senderState) }()
        case 11: try { try decoder.decodeSingularBytesField(value: &_storage._audienceHash) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._mediaCounters) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._chatType) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._senderLogInfo) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._senderClientVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._gid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gid, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._avatarID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarID, fieldNumber: 3)
      }
      if !_storage._senderPhone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderPhone, fieldNumber: 4)
      }
      if !_storage._senderName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderName, fieldNumber: 5)
      }
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 6)
      }
      if !_storage._payload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._payload, fieldNumber: 7)
      }
      if !_storage._encPayload.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._encPayload, fieldNumber: 8)
      }
      if !_storage._senderStateBundles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._senderStateBundles, fieldNumber: 9)
      }
      try { if let v = _storage._senderState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._audienceHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._audienceHash, fieldNumber: 11)
      }
      try { if let v = _storage._mediaCounters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._chatType != .chat {
        try visitor.visitSingularEnumField(value: _storage._chatType, fieldNumber: 13)
      }
      if !_storage._senderLogInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderLogInfo, fieldNumber: 16)
      }
      if !_storage._senderClientVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._senderClientVersion, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupChatStanza, rhs: Server_GroupChatStanza) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._gid != rhs_storage._gid {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._avatarID != rhs_storage._avatarID {return false}
        if _storage._senderPhone != rhs_storage._senderPhone {return false}
        if _storage._senderName != rhs_storage._senderName {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._encPayload != rhs_storage._encPayload {return false}
        if _storage._senderStateBundles != rhs_storage._senderStateBundles {return false}
        if _storage._senderState != rhs_storage._senderState {return false}
        if _storage._audienceHash != rhs_storage._audienceHash {return false}
        if _storage._mediaCounters != rhs_storage._mediaCounters {return false}
        if _storage._chatType != rhs_storage._chatType {return false}
        if _storage._senderLogInfo != rhs_storage._senderLogInfo {return false}
        if _storage._senderClientVersion != rhs_storage._senderClientVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupChatStanza.ChatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "CHAT_REACTION"),
  ]
}

extension Server_GroupsStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupsStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "group_stanzas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groupStanzas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .get {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.groupStanzas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupStanzas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupsStanza, rhs: Server_GroupsStanza) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.groupStanzas != rhs.groupStanzas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupsStanza.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
  ]
}

extension Server_GroupInviteLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupInviteLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "link"),
    4: .same(proto: "result"),
    5: .same(proto: "reason"),
    6: .same(proto: "group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.link) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 2)
    }
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 3)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 4)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 5)
    }
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupInviteLink, rhs: Server_GroupInviteLink) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.link != rhs.link {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupInviteLink.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GET"),
    2: .same(proto: "RESET"),
    3: .same(proto: "JOIN"),
    4: .same(proto: "PREVIEW"),
  ]
}

extension Server_AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "pwd"),
    3: .standard(proto: "client_mode"),
    4: .standard(proto: "client_version"),
    5: .same(proto: "resource"),
    6: .standard(proto: "device_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pwd) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientMode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deviceInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.pwd.isEmpty {
      try visitor.visitSingularStringField(value: self.pwd, fieldNumber: 2)
    }
    try { if let v = self._clientMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._clientVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 5)
    }
    try { if let v = self._deviceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AuthRequest, rhs: Server_AuthRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.pwd != rhs.pwd {return false}
    if lhs._clientMode != rhs._clientMode {return false}
    if lhs._clientVersion != rhs._clientVersion {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs._deviceInfo != rhs._deviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AuthResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_string"),
    2: .standard(proto: "reason_string"),
    3: .standard(proto: "props_hash"),
    4: .standard(proto: "version_ttl"),
    5: .same(proto: "result"),
    6: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resultString) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reasonString) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.propsHash) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.versionTtl) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resultString.isEmpty {
      try visitor.visitSingularStringField(value: self.resultString, fieldNumber: 1)
    }
    if !self.reasonString.isEmpty {
      try visitor.visitSingularStringField(value: self.reasonString, fieldNumber: 2)
    }
    if !self.propsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.propsHash, fieldNumber: 3)
    }
    if self.versionTtl != 0 {
      try visitor.visitSingularInt64Field(value: self.versionTtl, fieldNumber: 4)
    }
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 5)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AuthResult, rhs: Server_AuthResult) -> Bool {
    if lhs.resultString != rhs.resultString {return false}
    if lhs.reasonString != rhs.reasonString {return false}
    if lhs.propsHash != rhs.propsHash {return false}
    if lhs.versionTtl != rhs.versionTtl {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AuthResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_AuthResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "OK"),
    2: .same(proto: "SPUB_MISMATCH"),
    3: .same(proto: "INVALID_CLIENT_VERSION"),
    4: .same(proto: "INVALID_RESOURCE"),
    5: .same(proto: "ACCOUNT_DELETED"),
    6: .same(proto: "INVALID_UID_OR_PASSWORD"),
  ]
}

extension Server_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Invite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "result"),
    3: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Invite, rhs: Server_Invite) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InvitesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InvitesRequest, rhs: Server_InvitesRequest) -> Bool {
    if lhs.invites != rhs.invites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InvitesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invites_left"),
    2: .standard(proto: "time_until_refresh"),
    3: .same(proto: "invites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.invitesLeft) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeUntilRefresh) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.invites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invitesLeft != 0 {
      try visitor.visitSingularInt32Field(value: self.invitesLeft, fieldNumber: 1)
    }
    if self.timeUntilRefresh != 0 {
      try visitor.visitSingularInt64Field(value: self.timeUntilRefresh, fieldNumber: 2)
    }
    if !self.invites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invites, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InvitesResponse, rhs: Server_InvitesResponse) -> Bool {
    if lhs.invitesLeft != rhs.invitesLeft {return false}
    if lhs.timeUntilRefresh != rhs.timeUntilRefresh {return false}
    if lhs.invites != rhs.invites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaUrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "get"),
    2: .same(proto: "put"),
    3: .same(proto: "patch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.get) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.put) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.patch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.get.isEmpty {
      try visitor.visitSingularStringField(value: self.get, fieldNumber: 1)
    }
    if !self.put.isEmpty {
      try visitor.visitSingularStringField(value: self.put, fieldNumber: 2)
    }
    if !self.patch.isEmpty {
      try visitor.visitSingularStringField(value: self.patch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaUrl, rhs: Server_MediaUrl) -> Bool {
    if lhs.get != rhs.get {return false}
    if lhs.put != rhs.put {return false}
    if lhs.patch != rhs.patch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "url"),
    3: .standard(proto: "download_url"),
    4: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 1)
    }
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 3)
    }
    if self.type != .default {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadMedia, rhs: Server_UploadMedia) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs._url != rhs._url {return false}
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadMedia.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "RESUMABLE"),
    2: .same(proto: "DIRECT"),
  ]
}

extension Server_ChatStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "payload"),
    3: .standard(proto: "enc_payload"),
    4: .standard(proto: "public_key"),
    5: .standard(proto: "one_time_pre_key_id"),
    6: .standard(proto: "sender_name"),
    7: .standard(proto: "sender_phone"),
    8: .standard(proto: "media_counters"),
    9: .standard(proto: "chat_type"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.senderName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.senderPhone) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._mediaCounters) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.chatType) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.senderLogInfo) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.senderClientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 3)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 4)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 5)
    }
    if !self.senderName.isEmpty {
      try visitor.visitSingularStringField(value: self.senderName, fieldNumber: 6)
    }
    if !self.senderPhone.isEmpty {
      try visitor.visitSingularStringField(value: self.senderPhone, fieldNumber: 7)
    }
    try { if let v = self._mediaCounters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.chatType != .chat {
      try visitor.visitSingularEnumField(value: self.chatType, fieldNumber: 9)
    }
    if !self.senderLogInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.senderLogInfo, fieldNumber: 16)
    }
    if !self.senderClientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderClientVersion, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatStanza, rhs: Server_ChatStanza) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.senderName != rhs.senderName {return false}
    if lhs.senderPhone != rhs.senderPhone {return false}
    if lhs._mediaCounters != rhs._mediaCounters {return false}
    if lhs.chatType != rhs.chatType {return false}
    if lhs.senderLogInfo != rhs.senderLogInfo {return false}
    if lhs.senderClientVersion != rhs.senderClientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatStanza.ChatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "CHAT_REACTION"),
  ]
}

extension Server_SilentChatStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SilentChatStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_stanza"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chatStanza) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._chatStanza {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SilentChatStanza, rhs: Server_SilentChatStanza) -> Bool {
    if lhs._chatStanza != rhs._chatStanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Ping, rhs: Server_Ping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ErrorStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ErrorStanza, rhs: Server_ErrorStanza) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Name, rhs: Server_Name) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_EndOfQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndOfQueue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trimmed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.trimmed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.trimmed != false {
      try visitor.visitSingularBoolField(value: self.trimmed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EndOfQueue, rhs: Server_EndOfQueue) -> Bool {
    if lhs.trimmed != rhs.trimmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HistoryResend: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistoryResend"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "id"),
    4: .same(proto: "payload"),
    5: .standard(proto: "enc_payload"),
    6: .standard(proto: "sender_state_bundles"),
    7: .standard(proto: "sender_state"),
    8: .standard(proto: "audience_hash"),
    16: .standard(proto: "sender_log_info"),
    17: .standard(proto: "sender_client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.senderStateBundles) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._senderState) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.audienceHash) }()
      case 16: try { try decoder.decodeSingularStringField(value: &self.senderLogInfo) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.senderClientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 4)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 5)
    }
    if !self.senderStateBundles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.senderStateBundles, fieldNumber: 6)
    }
    try { if let v = self._senderState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.audienceHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.audienceHash, fieldNumber: 8)
    }
    if !self.senderLogInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.senderLogInfo, fieldNumber: 16)
    }
    if !self.senderClientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderClientVersion, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HistoryResend, rhs: Server_HistoryResend) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.senderStateBundles != rhs.senderStateBundles {return false}
    if lhs._senderState != rhs._senderState {return false}
    if lhs.audienceHash != rhs.audienceHash {return false}
    if lhs.senderLogInfo != rhs.senderLogInfo {return false}
    if lhs.senderClientVersion != rhs.senderClientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StunServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StunServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_StunServer, rhs: Server_StunServer) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_TurnServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TurnServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "port"),
    3: .same(proto: "username"),
    4: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TurnServer, rhs: Server_TurnServer) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCallServers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCallServers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "peer_uid"),
    3: .standard(proto: "call_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.peerUid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.callType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.peerUid != 0 {
      try visitor.visitSingularInt64Field(value: self.peerUid, fieldNumber: 2)
    }
    if self.callType != .unknownType {
      try visitor.visitSingularEnumField(value: self.callType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetCallServers, rhs: Server_GetCallServers) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.peerUid != rhs.peerUid {return false}
    if lhs.callType != rhs.callType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCallServersResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCallServersResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "stun_servers"),
    3: .standard(proto: "turn_servers"),
    4: .standard(proto: "call_config"),
    5: .standard(proto: "call_id"),
  ]

  fileprivate class _StorageClass {
    var _result: Server_GetCallServersResult.Result = .unknown
    var _stunServers: [Server_StunServer] = []
    var _turnServers: [Server_TurnServer] = []
    var _callConfig: Server_CallConfig? = nil
    var _callID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
      _stunServers = source._stunServers
      _turnServers = source._turnServers
      _callConfig = source._callConfig
      _callID = source._callID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._result) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._stunServers) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._turnServers) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._callConfig) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._callID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._result != .unknown {
        try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 1)
      }
      if !_storage._stunServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stunServers, fieldNumber: 2)
      }
      if !_storage._turnServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._turnServers, fieldNumber: 3)
      }
      try { if let v = _storage._callConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetCallServersResult, rhs: Server_GetCallServersResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        if _storage._stunServers != rhs_storage._stunServers {return false}
        if _storage._turnServers != rhs_storage._turnServers {return false}
        if _storage._callConfig != rhs_storage._callConfig {return false}
        if _storage._callID != rhs_storage._callID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetCallServersResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_CallCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallCapabilities"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pre_answer"),
    2: .standard(proto: "sdp_restart"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.preAnswer) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.sdpRestart) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.preAnswer != false {
      try visitor.visitSingularBoolField(value: self.preAnswer, fieldNumber: 1)
    }
    if self.sdpRestart != false {
      try visitor.visitSingularBoolField(value: self.sdpRestart, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallCapabilities, rhs: Server_CallCapabilities) -> Bool {
    if lhs.preAnswer != rhs.preAnswer {return false}
    if lhs.sdpRestart != rhs.sdpRestart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StartCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "peer_uid"),
    3: .standard(proto: "call_type"),
    4: .standard(proto: "webrtc_offer"),
    5: .standard(proto: "rerequest_count"),
    6: .standard(proto: "call_capabilities"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.peerUid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.callType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._webrtcOffer) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.rerequestCount) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._callCapabilities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.peerUid != 0 {
      try visitor.visitSingularInt64Field(value: self.peerUid, fieldNumber: 2)
    }
    if self.callType != .unknownType {
      try visitor.visitSingularEnumField(value: self.callType, fieldNumber: 3)
    }
    try { if let v = self._webrtcOffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.rerequestCount != 0 {
      try visitor.visitSingularInt32Field(value: self.rerequestCount, fieldNumber: 5)
    }
    try { if let v = self._callCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_StartCall, rhs: Server_StartCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.peerUid != rhs.peerUid {return false}
    if lhs.callType != rhs.callType {return false}
    if lhs._webrtcOffer != rhs._webrtcOffer {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs._callCapabilities != rhs._callCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StartCallResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartCallResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "stun_servers"),
    3: .standard(proto: "turn_servers"),
    4: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stunServers) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.turnServers) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.stunServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stunServers, fieldNumber: 2)
    }
    if !self.turnServers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.turnServers, fieldNumber: 3)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_StartCallResult, rhs: Server_StartCallResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.stunServers != rhs.stunServers {return false}
    if lhs.turnServers != rhs.turnServers {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_StartCallResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_WebRtcSessionDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebRtcSessionDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enc_payload"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "one_time_pre_key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encPayload) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.oneTimePreKeyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 1)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 2)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt32Field(value: self.oneTimePreKeyID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WebRtcSessionDescription, rhs: Server_WebRtcSessionDescription) -> Bool {
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IncomingCallPush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingCallPush"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "call_type"),
    3: .standard(proto: "stun_servers"),
    4: .standard(proto: "turn_servers"),
    5: .standard(proto: "timestamp_ms"),
    6: .standard(proto: "call_config"),
    7: .standard(proto: "call_capabilities"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _callType: Server_CallType = .unknownType
    var _stunServers: [Server_StunServer] = []
    var _turnServers: [Server_TurnServer] = []
    var _timestampMs: Int64 = 0
    var _callConfig: Server_CallConfig? = nil
    var _callCapabilities: Server_CallCapabilities? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _callType = source._callType
      _stunServers = source._stunServers
      _turnServers = source._turnServers
      _timestampMs = source._timestampMs
      _callConfig = source._callConfig
      _callCapabilities = source._callCapabilities
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._callID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._callType) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._stunServers) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._turnServers) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._timestampMs) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._callConfig) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._callCapabilities) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if _storage._callType != .unknownType {
        try visitor.visitSingularEnumField(value: _storage._callType, fieldNumber: 2)
      }
      if !_storage._stunServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stunServers, fieldNumber: 3)
      }
      if !_storage._turnServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._turnServers, fieldNumber: 4)
      }
      if _storage._timestampMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestampMs, fieldNumber: 5)
      }
      try { if let v = _storage._callConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._callCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IncomingCallPush, rhs: Server_IncomingCallPush) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._callType != rhs_storage._callType {return false}
        if _storage._stunServers != rhs_storage._stunServers {return false}
        if _storage._turnServers != rhs_storage._turnServers {return false}
        if _storage._timestampMs != rhs_storage._timestampMs {return false}
        if _storage._callConfig != rhs_storage._callConfig {return false}
        if _storage._callCapabilities != rhs_storage._callCapabilities {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IncomingCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "call_type"),
    3: .standard(proto: "webrtc_offer"),
    4: .standard(proto: "stun_servers"),
    5: .standard(proto: "turn_servers"),
    6: .standard(proto: "timestamp_ms"),
    7: .standard(proto: "server_sent_ts_ms"),
    8: .standard(proto: "call_config"),
    9: .standard(proto: "call_capabilities"),
  ]

  fileprivate class _StorageClass {
    var _callID: String = String()
    var _callType: Server_CallType = .unknownType
    var _webrtcOffer: Server_WebRtcSessionDescription? = nil
    var _stunServers: [Server_StunServer] = []
    var _turnServers: [Server_TurnServer] = []
    var _timestampMs: Int64 = 0
    var _serverSentTsMs: Int64 = 0
    var _callConfig: Server_CallConfig? = nil
    var _callCapabilities: Server_CallCapabilities? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _callID = source._callID
      _callType = source._callType
      _webrtcOffer = source._webrtcOffer
      _stunServers = source._stunServers
      _turnServers = source._turnServers
      _timestampMs = source._timestampMs
      _serverSentTsMs = source._serverSentTsMs
      _callConfig = source._callConfig
      _callCapabilities = source._callCapabilities
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._callID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._callType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._webrtcOffer) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._stunServers) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._turnServers) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._timestampMs) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._serverSentTsMs) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._callConfig) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._callCapabilities) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._callID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._callID, fieldNumber: 1)
      }
      if _storage._callType != .unknownType {
        try visitor.visitSingularEnumField(value: _storage._callType, fieldNumber: 2)
      }
      try { if let v = _storage._webrtcOffer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stunServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stunServers, fieldNumber: 4)
      }
      if !_storage._turnServers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._turnServers, fieldNumber: 5)
      }
      if _storage._timestampMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestampMs, fieldNumber: 6)
      }
      if _storage._serverSentTsMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._serverSentTsMs, fieldNumber: 7)
      }
      try { if let v = _storage._callConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._callCapabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IncomingCall, rhs: Server_IncomingCall) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._callID != rhs_storage._callID {return false}
        if _storage._callType != rhs_storage._callType {return false}
        if _storage._webrtcOffer != rhs_storage._webrtcOffer {return false}
        if _storage._stunServers != rhs_storage._stunServers {return false}
        if _storage._turnServers != rhs_storage._turnServers {return false}
        if _storage._timestampMs != rhs_storage._timestampMs {return false}
        if _storage._serverSentTsMs != rhs_storage._serverSentTsMs {return false}
        if _storage._callConfig != rhs_storage._callConfig {return false}
        if _storage._callCapabilities != rhs_storage._callCapabilities {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IceCandidate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceCandidate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "sdp_media_id"),
    3: .standard(proto: "sdp_media_line_index"),
    4: .same(proto: "sdp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sdpMediaID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sdpMediaLineIndex) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sdp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if !self.sdpMediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.sdpMediaID, fieldNumber: 2)
    }
    if self.sdpMediaLineIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.sdpMediaLineIndex, fieldNumber: 3)
    }
    if !self.sdp.isEmpty {
      try visitor.visitSingularStringField(value: self.sdp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IceCandidate, rhs: Server_IceCandidate) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.sdpMediaID != rhs.sdpMediaID {return false}
    if lhs.sdpMediaLineIndex != rhs.sdpMediaLineIndex {return false}
    if lhs.sdp != rhs.sdp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CallRinging: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallRinging"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "timestamp_ms"),
    3: .standard(proto: "webrtc_answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 2)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallRinging, rhs: Server_CallRinging) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PreAnswerCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreAnswerCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "webrtc_answer"),
    3: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PreAnswerCall, rhs: Server_PreAnswerCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AnswerCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnswerCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "webrtc_answer"),
    3: .standard(proto: "timestamp_ms"),
    4: .standard(proto: "webrtc_offer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._webrtcOffer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try { if let v = self._webrtcOffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AnswerCall, rhs: Server_AnswerCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs._webrtcOffer != rhs._webrtcOffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CallSdp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallSdp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "sdp_type"),
    3: .same(proto: "info"),
    4: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sdpType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.sdpType != .unknown {
      try visitor.visitSingularEnumField(value: self.sdpType, fieldNumber: 2)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallSdp, rhs: Server_CallSdp) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.sdpType != rhs.sdpType {return false}
    if lhs._info != rhs._info {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CallSdp.SdpType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OFFER"),
    2: .same(proto: "ANSWER"),
  ]
}

extension Server_EndCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "reason"),
    3: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EndCall, rhs: Server_EndCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_EndCall.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REJECT"),
    2: .same(proto: "BUSY"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "CALL_END"),
    5: .same(proto: "CANCEL"),
    6: .same(proto: "DECRYPTION_FAILED"),
    7: .same(proto: "ENCRYPTION_FAILED"),
    8: .same(proto: "SYSTEM_ERROR"),
    9: .same(proto: "VIDEO_UNSUPPORTED"),
    10: .same(proto: "CONNECTION_ERROR"),
  ]
}

extension Server_IceRestartOffer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceRestartOffer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "idx"),
    3: .standard(proto: "webrtc_offer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.idx) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._webrtcOffer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.idx != 0 {
      try visitor.visitSingularInt32Field(value: self.idx, fieldNumber: 2)
    }
    try { if let v = self._webrtcOffer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IceRestartOffer, rhs: Server_IceRestartOffer) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.idx != rhs.idx {return false}
    if lhs._webrtcOffer != rhs._webrtcOffer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IceRestartAnswer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IceRestartAnswer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "idx"),
    3: .standard(proto: "webrtc_answer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.idx) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._webrtcAnswer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.idx != 0 {
      try visitor.visitSingularInt32Field(value: self.idx, fieldNumber: 2)
    }
    try { if let v = self._webrtcAnswer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IceRestartAnswer, rhs: Server_IceRestartAnswer) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.idx != rhs.idx {return false}
    if lhs._webrtcAnswer != rhs._webrtcAnswer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HoldCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoldCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .same(proto: "hold"),
    3: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.hold) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.hold != false {
      try visitor.visitSingularBoolField(value: self.hold, fieldNumber: 2)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HoldCall, rhs: Server_HoldCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.hold != rhs.hold {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MuteCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MuteCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "media_type"),
    3: .same(proto: "muted"),
    4: .standard(proto: "timestamp_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mediaType) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.muted) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestampMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.mediaType != .audio {
      try visitor.visitSingularEnumField(value: self.mediaType, fieldNumber: 2)
    }
    if self.muted != false {
      try visitor.visitSingularBoolField(value: self.muted, fieldNumber: 3)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MuteCall, rhs: Server_MuteCall) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.muted != rhs.muted {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MuteCall.MediaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUDIO"),
    1: .same(proto: "VIDEO"),
  ]
}

extension Server_CallConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_bitrate_max"),
    2: .standard(proto: "video_bitrate_max"),
    3: .standard(proto: "audio_codec"),
    4: .standard(proto: "video_codec"),
    5: .standard(proto: "video_width"),
    6: .standard(proto: "video_height"),
    7: .standard(proto: "video_fps"),
    8: .standard(proto: "audio_jitter_buffer_max_packets"),
    9: .standard(proto: "audio_jitter_buffer_fast_accelerate"),
    10: .standard(proto: "ice_transport_policy"),
    11: .standard(proto: "ice_restart_delay_ms"),
    12: .standard(proto: "prune_turn_ports"),
    13: .standard(proto: "ice_candidate_pool_size"),
    14: .standard(proto: "ice_backup_ping_interval_ms"),
    15: .standard(proto: "ice_connection_timeout_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.audioBitrateMax) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.videoBitrateMax) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.audioCodec) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.videoCodec) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.videoWidth) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.videoHeight) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.videoFps) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.audioJitterBufferMaxPackets) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.audioJitterBufferFastAccelerate) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.iceTransportPolicy) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.iceRestartDelayMs) }()
      case 12: try { try decoder.decodeSingularBoolField(value: &self.pruneTurnPorts) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.iceCandidatePoolSize) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.iceBackupPingIntervalMs) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.iceConnectionTimeoutMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.audioBitrateMax != 0 {
      try visitor.visitSingularInt32Field(value: self.audioBitrateMax, fieldNumber: 1)
    }
    if self.videoBitrateMax != 0 {
      try visitor.visitSingularInt32Field(value: self.videoBitrateMax, fieldNumber: 2)
    }
    if self.audioCodec != 0 {
      try visitor.visitSingularInt32Field(value: self.audioCodec, fieldNumber: 3)
    }
    if self.videoCodec != 0 {
      try visitor.visitSingularInt32Field(value: self.videoCodec, fieldNumber: 4)
    }
    if self.videoWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.videoWidth, fieldNumber: 5)
    }
    if self.videoHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.videoHeight, fieldNumber: 6)
    }
    if self.videoFps != 0 {
      try visitor.visitSingularInt32Field(value: self.videoFps, fieldNumber: 7)
    }
    if self.audioJitterBufferMaxPackets != 0 {
      try visitor.visitSingularInt32Field(value: self.audioJitterBufferMaxPackets, fieldNumber: 8)
    }
    if self.audioJitterBufferFastAccelerate != false {
      try visitor.visitSingularBoolField(value: self.audioJitterBufferFastAccelerate, fieldNumber: 9)
    }
    if self.iceTransportPolicy != .all {
      try visitor.visitSingularEnumField(value: self.iceTransportPolicy, fieldNumber: 10)
    }
    if self.iceRestartDelayMs != 0 {
      try visitor.visitSingularInt32Field(value: self.iceRestartDelayMs, fieldNumber: 11)
    }
    if self.pruneTurnPorts != false {
      try visitor.visitSingularBoolField(value: self.pruneTurnPorts, fieldNumber: 12)
    }
    if self.iceCandidatePoolSize != 0 {
      try visitor.visitSingularInt32Field(value: self.iceCandidatePoolSize, fieldNumber: 13)
    }
    if self.iceBackupPingIntervalMs != 0 {
      try visitor.visitSingularInt32Field(value: self.iceBackupPingIntervalMs, fieldNumber: 14)
    }
    if self.iceConnectionTimeoutMs != 0 {
      try visitor.visitSingularInt32Field(value: self.iceConnectionTimeoutMs, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CallConfig, rhs: Server_CallConfig) -> Bool {
    if lhs.audioBitrateMax != rhs.audioBitrateMax {return false}
    if lhs.videoBitrateMax != rhs.videoBitrateMax {return false}
    if lhs.audioCodec != rhs.audioCodec {return false}
    if lhs.videoCodec != rhs.videoCodec {return false}
    if lhs.videoWidth != rhs.videoWidth {return false}
    if lhs.videoHeight != rhs.videoHeight {return false}
    if lhs.videoFps != rhs.videoFps {return false}
    if lhs.audioJitterBufferMaxPackets != rhs.audioJitterBufferMaxPackets {return false}
    if lhs.audioJitterBufferFastAccelerate != rhs.audioJitterBufferFastAccelerate {return false}
    if lhs.iceTransportPolicy != rhs.iceTransportPolicy {return false}
    if lhs.iceRestartDelayMs != rhs.iceRestartDelayMs {return false}
    if lhs.pruneTurnPorts != rhs.pruneTurnPorts {return false}
    if lhs.iceCandidatePoolSize != rhs.iceCandidatePoolSize {return false}
    if lhs.iceBackupPingIntervalMs != rhs.iceBackupPingIntervalMs {return false}
    if lhs.iceConnectionTimeoutMs != rhs.iceConnectionTimeoutMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CallConfig.IceTransportPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "RELAY"),
  ]
}

extension Server_OgTagInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OgTagInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "thumbnail_url"),
    4: .standard(proto: "thumbnail_width"),
    5: .standard(proto: "thumbnail_height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailURL) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.thumbnailWidth) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.thumbnailHeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.thumbnailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailURL, fieldNumber: 3)
    }
    if self.thumbnailWidth != 0 {
      try visitor.visitSingularInt32Field(value: self.thumbnailWidth, fieldNumber: 4)
    }
    if self.thumbnailHeight != 0 {
      try visitor.visitSingularInt32Field(value: self.thumbnailHeight, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_OgTagInfo, rhs: Server_OgTagInfo) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.thumbnailURL != rhs.thumbnailURL {return false}
    if lhs.thumbnailWidth != rhs.thumbnailWidth {return false}
    if lhs.thumbnailHeight != rhs.thumbnailHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ExternalSharePost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalSharePost"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "blob_id"),
    3: .same(proto: "blob"),
    4: .standard(proto: "expires_in_seconds"),
    5: .standard(proto: "og_tag_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.blobID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.blob) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.expiresInSeconds) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ogTagInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .store {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.blobID.isEmpty {
      try visitor.visitSingularStringField(value: self.blobID, fieldNumber: 2)
    }
    if !self.blob.isEmpty {
      try visitor.visitSingularBytesField(value: self.blob, fieldNumber: 3)
    }
    if self.expiresInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresInSeconds, fieldNumber: 4)
    }
    try { if let v = self._ogTagInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ExternalSharePost, rhs: Server_ExternalSharePost) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.blobID != rhs.blobID {return false}
    if lhs.blob != rhs.blob {return false}
    if lhs.expiresInSeconds != rhs.expiresInSeconds {return false}
    if lhs._ogTagInfo != rhs._ogTagInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ExternalSharePost.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE"),
    1: .same(proto: "DELETE"),
    2: .same(proto: "GET"),
  ]
}

extension Server_ExternalSharePostContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalSharePostContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "blob"),
    3: .standard(proto: "og_tag_info"),
    4: .same(proto: "name"),
    5: .standard(proto: "avatar_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.blob) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ogTagInfo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.blob.isEmpty {
      try visitor.visitSingularBytesField(value: self.blob, fieldNumber: 2)
    }
    try { if let v = self._ogTagInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ExternalSharePostContainer, rhs: Server_ExternalSharePostContainer) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.blob != rhs.blob {return false}
    if lhs._ogTagInfo != rhs._ogTagInfo {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WebClientInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebClientInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "static_key"),
    3: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.staticKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .unknownAction {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.staticKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.staticKey, fieldNumber: 2)
    }
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WebClientInfo, rhs: Server_WebClientInfo) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.staticKey != rhs.staticKey {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WebClientInfo.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTION"),
    1: .same(proto: "ADD_KEY"),
    2: .same(proto: "IS_KEY_AUTHENTICATED"),
    3: .same(proto: "AUTHENTICATE_KEY"),
    4: .same(proto: "REMOVE_KEY"),
  ]
}

extension Server_WebClientInfo.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "AUTHENTICATED"),
    3: .same(proto: "NOT_AUTHENTICATED"),
  ]
}

extension Server_ReportUserContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReportUserContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "uid"),
    3: .standard(proto: "content_id"),
    4: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 3)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ReportUserContent, rhs: Server_ReportUserContent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ReportUserContent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "USER"),
    2: .same(proto: "POST"),
  ]
}

extension Server_ReportUserContent.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "DONT_LIKE"),
    2: .same(proto: "SPAM"),
    3: .same(proto: "VIOLATES_RULES"),
    4: .same(proto: "OTHER"),
  ]
}

extension Server_WebStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "static_key"),
    2: .same(proto: "content"),
    3: .standard(proto: "noise_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.staticKey) }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .content(v)
        }
      }()
      case 3: try {
        var v: Server_NoiseMessage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .noiseMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .noiseMessage(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.staticKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.staticKey, fieldNumber: 1)
    }
    switch self.payload {
    case .content?: try {
      guard case .content(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .noiseMessage?: try {
      guard case .noiseMessage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WebStanza, rhs: Server_WebStanza) -> Bool {
    if lhs.staticKey != rhs.staticKey {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ContentMissing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContentMissing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_id"),
    2: .standard(proto: "content_type"),
    3: .standard(proto: "sender_client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.senderClientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 1)
    }
    if self.contentType != .unknown {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 2)
    }
    if !self.senderClientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderClientVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContentMissing, rhs: Server_ContentMissing) -> Bool {
    if lhs.contentID != rhs.contentID {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.senderClientVersion != rhs.senderClientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ContentMissing.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CHAT"),
    2: .same(proto: "CALL"),
    3: .same(proto: "GROUP_FEED_POST"),
    4: .same(proto: "GROUP_FEED_COMMENT"),
    5: .same(proto: "HOME_FEED_POST"),
    6: .same(proto: "HOME_FEED_COMMENT"),
    7: .same(proto: "HISTORY_RESEND"),
    8: .same(proto: "GROUP_HISTORY"),
    9: .same(proto: "CHAT_REACTION"),
    10: .same(proto: "GROUP_COMMENT_REACTION"),
    11: .same(proto: "GROUP_POST_REACTION"),
    12: .same(proto: "HOME_COMMENT_REACTION"),
    13: .same(proto: "HOME_POST_REACTION"),
    14: .same(proto: "GROUP_CHAT"),
    15: .same(proto: "GROUP_CHAT_REACTION"),
  ]
}

extension Server_MomentNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MomentNotification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "notification_id"),
    3: .same(proto: "type"),
    4: .same(proto: "prompt"),
    5: .standard(proto: "hide_banner"),
    6: .standard(proto: "prompt_image"),
    7: .same(proto: "date"),
    8: .same(proto: "reminder"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.notificationID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hideBanner) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.promptImage) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.date) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.reminder) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if self.notificationID != 0 {
      try visitor.visitSingularInt64Field(value: self.notificationID, fieldNumber: 2)
    }
    if self.type != .liveCamera {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 4)
    }
    if self.hideBanner != false {
      try visitor.visitSingularBoolField(value: self.hideBanner, fieldNumber: 5)
    }
    if !self.promptImage.isEmpty {
      try visitor.visitSingularBytesField(value: self.promptImage, fieldNumber: 6)
    }
    if !self.date.isEmpty {
      try visitor.visitSingularStringField(value: self.date, fieldNumber: 7)
    }
    if self.reminder != false {
      try visitor.visitSingularBoolField(value: self.reminder, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MomentNotification, rhs: Server_MomentNotification) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.notificationID != rhs.notificationID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.prompt != rhs.prompt {return false}
    if lhs.hideBanner != rhs.hideBanner {return false}
    if lhs.promptImage != rhs.promptImage {return false}
    if lhs.date != rhs.date {return false}
    if lhs.reminder != rhs.reminder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MomentNotification.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIVE_CAMERA"),
    1: .same(proto: "TEXT_POST"),
    2: .same(proto: "PROMPT_POST"),
    3: .same(proto: "ALBUM_POST"),
    4: .same(proto: "ALBUM_DUMP"),
  ]
}

extension Server_ArchiveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ArchiveRequest, rhs: Server_ArchiveRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ArchiveResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArchiveResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "uid"),
    4: .same(proto: "posts"),
    5: .standard(proto: "start_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.posts) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.startDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 3)
    }
    if !self.posts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.posts, fieldNumber: 4)
    }
    if !self.startDate.isEmpty {
      try visitor.visitSingularStringField(value: self.startDate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ArchiveResult, rhs: Server_ArchiveResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.posts != rhs.posts {return false}
    if lhs.startDate != rhs.startDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ArchiveResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_ArchiveResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "INVALID_USER"),
  ]
}

extension Server_Iq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Iq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "upload_media"),
    4: .standard(proto: "contact_list"),
    5: .standard(proto: "upload_avatar"),
    6: .same(proto: "avatar"),
    7: .same(proto: "avatars"),
    8: .standard(proto: "client_mode"),
    9: .standard(proto: "client_version"),
    10: .standard(proto: "push_register"),
    11: .standard(proto: "whisper_keys"),
    12: .same(proto: "ping"),
    13: .standard(proto: "feed_item"),
    14: .standard(proto: "privacy_list"),
    16: .standard(proto: "privacy_lists"),
    17: .standard(proto: "group_stanza"),
    18: .standard(proto: "groups_stanza"),
    19: .standard(proto: "client_log"),
    20: .same(proto: "name"),
    21: .standard(proto: "error_stanza"),
    22: .same(proto: "props"),
    23: .standard(proto: "invites_request"),
    24: .standard(proto: "invites_response"),
    25: .standard(proto: "notification_prefs"),
    26: .standard(proto: "group_feed_item"),
    27: .standard(proto: "group_avatar"),
    28: .standard(proto: "delete_account"),
    31: .standard(proto: "group_invite_link"),
    32: .standard(proto: "history_resend"),
    33: .standard(proto: "export_data"),
    34: .standard(proto: "contact_sync_error"),
    35: .standard(proto: "client_otp_request"),
    36: .standard(proto: "client_otp_response"),
    37: .standard(proto: "whisper_keys_collection"),
    38: .standard(proto: "get_call_servers"),
    39: .standard(proto: "get_call_servers_result"),
    40: .standard(proto: "start_call"),
    41: .standard(proto: "start_call_result"),
    42: .standard(proto: "trunc_whisper_keys_collection"),
    43: .standard(proto: "external_share_post"),
    44: .standard(proto: "external_share_post_container"),
    45: .standard(proto: "web_client_info"),
    46: .standard(proto: "report_user_content"),
    47: .standard(proto: "public_feed_request"),
    48: .standard(proto: "public_feed_response"),
    49: .standard(proto: "relationship_request"),
    50: .standard(proto: "relationship_response"),
    51: .standard(proto: "relationship_list"),
    52: .standard(proto: "username_request"),
    53: .standard(proto: "username_response"),
    54: .standard(proto: "search_request"),
    55: .standard(proto: "search_response"),
    56: .standard(proto: "follow_suggestions_request"),
    57: .standard(proto: "follow_suggestions_response"),
    58: .standard(proto: "set_link_request"),
    59: .standard(proto: "set_link_result"),
    60: .standard(proto: "set_bio_request"),
    61: .standard(proto: "set_bio_result"),
    62: .standard(proto: "user_profile_request"),
    63: .standard(proto: "user_profile_result"),
    64: .standard(proto: "post_metrics_request"),
    65: .standard(proto: "post_metrics_result"),
    66: .standard(proto: "ai_image_request"),
    67: .standard(proto: "ai_image_result"),
    68: .standard(proto: "archive_request"),
    69: .standard(proto: "archive_result"),
    70: .standard(proto: "post_subscription_request"),
    71: .standard(proto: "post_subscription_response"),
    72: .standard(proto: "geo_tag_request"),
    73: .standard(proto: "geo_tag_response"),
    74: .standard(proto: "register_request"),
    75: .standard(proto: "register_response"),
    76: .standard(proto: "halloapp_search_request"),
    77: .standard(proto: "halloapp_search_response"),
    78: .standard(proto: "friendship_request"),
    79: .standard(proto: "friendship_response"),
    80: .standard(proto: "friend_list_request"),
    81: .standard(proto: "friend_list_response"),
    82: .same(proto: "album"),
    83: .standard(proto: "album_result"),
    84: .standard(proto: "get_albums"),
    85: .standard(proto: "halloapp_profile_request"),
    86: .standard(proto: "hallaopp_profile_result"),
    87: .standard(proto: "reverse_geocode_request"),
    88: .standard(proto: "reverse_geocode_result"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: Server_Iq.TypeEnum = .get
    var _payload: Server_Iq.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try {
          var v: Server_UploadMedia?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .uploadMedia(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .uploadMedia(v)
          }
        }()
        case 4: try {
          var v: Server_ContactList?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .contactList(v)
          }
        }()
        case 5: try {
          var v: Server_UploadAvatar?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .uploadAvatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .uploadAvatar(v)
          }
        }()
        case 6: try {
          var v: Server_Avatar?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .avatar(v)
          }
        }()
        case 7: try {
          var v: Server_Avatars?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .avatars(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .avatars(v)
          }
        }()
        case 8: try {
          var v: Server_ClientMode?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .clientMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .clientMode(v)
          }
        }()
        case 9: try {
          var v: Server_ClientVersion?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .clientVersion(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .clientVersion(v)
          }
        }()
        case 10: try {
          var v: Server_PushRegister?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .pushRegister(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .pushRegister(v)
          }
        }()
        case 11: try {
          var v: Server_WhisperKeys?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .whisperKeys(v)
          }
        }()
        case 12: try {
          var v: Server_Ping?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .ping(v)
          }
        }()
        case 13: try {
          var v: Server_FeedItem?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .feedItem(v)
          }
        }()
        case 14: try {
          var v: Server_PrivacyList?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .privacyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .privacyList(v)
          }
        }()
        case 16: try {
          var v: Server_PrivacyLists?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .privacyLists(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .privacyLists(v)
          }
        }()
        case 17: try {
          var v: Server_GroupStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupStanza(v)
          }
        }()
        case 18: try {
          var v: Server_GroupsStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupsStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupsStanza(v)
          }
        }()
        case 19: try {
          var v: Server_ClientLog?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .clientLog(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .clientLog(v)
          }
        }()
        case 20: try {
          var v: Server_Name?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .name(v)
          }
        }()
        case 21: try {
          var v: Server_ErrorStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .errorStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .errorStanza(v)
          }
        }()
        case 22: try {
          var v: Server_Props?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .props(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .props(v)
          }
        }()
        case 23: try {
          var v: Server_InvitesRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .invitesRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .invitesRequest(v)
          }
        }()
        case 24: try {
          var v: Server_InvitesResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .invitesResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .invitesResponse(v)
          }
        }()
        case 25: try {
          var v: Server_NotificationPrefs?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .notificationPrefs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .notificationPrefs(v)
          }
        }()
        case 26: try {
          var v: Server_GroupFeedItem?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedItem(v)
          }
        }()
        case 27: try {
          var v: Server_UploadGroupAvatar?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupAvatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupAvatar(v)
          }
        }()
        case 28: try {
          var v: Server_DeleteAccount?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .deleteAccount(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .deleteAccount(v)
          }
        }()
        case 31: try {
          var v: Server_GroupInviteLink?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupInviteLink(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupInviteLink(v)
          }
        }()
        case 32: try {
          var v: Server_HistoryResend?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .historyResend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .historyResend(v)
          }
        }()
        case 33: try {
          var v: Server_ExportData?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .exportData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .exportData(v)
          }
        }()
        case 34: try {
          var v: Server_ContactSyncError?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .contactSyncError(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .contactSyncError(v)
          }
        }()
        case 35: try {
          var v: Server_ClientOtpRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .clientOtpRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .clientOtpRequest(v)
          }
        }()
        case 36: try {
          var v: Server_ClientOtpResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .clientOtpResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .clientOtpResponse(v)
          }
        }()
        case 37: try {
          var v: Server_WhisperKeysCollection?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .whisperKeysCollection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .whisperKeysCollection(v)
          }
        }()
        case 38: try {
          var v: Server_GetCallServers?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .getCallServers(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .getCallServers(v)
          }
        }()
        case 39: try {
          var v: Server_GetCallServersResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .getCallServersResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .getCallServersResult(v)
          }
        }()
        case 40: try {
          var v: Server_StartCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .startCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .startCall(v)
          }
        }()
        case 41: try {
          var v: Server_StartCallResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .startCallResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .startCallResult(v)
          }
        }()
        case 42: try {
          var v: Server_TruncWhisperKeysCollection?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .truncWhisperKeysCollection(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .truncWhisperKeysCollection(v)
          }
        }()
        case 43: try {
          var v: Server_ExternalSharePost?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .externalSharePost(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .externalSharePost(v)
          }
        }()
        case 44: try {
          var v: Server_ExternalSharePostContainer?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .externalSharePostContainer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .externalSharePostContainer(v)
          }
        }()
        case 45: try {
          var v: Server_WebClientInfo?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .webClientInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .webClientInfo(v)
          }
        }()
        case 46: try {
          var v: Server_ReportUserContent?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .reportUserContent(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .reportUserContent(v)
          }
        }()
        case 47: try {
          var v: Server_PublicFeedRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .publicFeedRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .publicFeedRequest(v)
          }
        }()
        case 48: try {
          var v: Server_PublicFeedResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .publicFeedResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .publicFeedResponse(v)
          }
        }()
        case 49: try {
          var v: Server_RelationshipRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .relationshipRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .relationshipRequest(v)
          }
        }()
        case 50: try {
          var v: Server_RelationshipResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .relationshipResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .relationshipResponse(v)
          }
        }()
        case 51: try {
          var v: Server_RelationshipList?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .relationshipList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .relationshipList(v)
          }
        }()
        case 52: try {
          var v: Server_UsernameRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .usernameRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .usernameRequest(v)
          }
        }()
        case 53: try {
          var v: Server_UsernameResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .usernameResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .usernameResponse(v)
          }
        }()
        case 54: try {
          var v: Server_SearchRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .searchRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .searchRequest(v)
          }
        }()
        case 55: try {
          var v: Server_SearchResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .searchResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .searchResponse(v)
          }
        }()
        case 56: try {
          var v: Server_FollowSuggestionsRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .followSuggestionsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .followSuggestionsRequest(v)
          }
        }()
        case 57: try {
          var v: Server_FollowSuggestionsResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .followSuggestionsResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .followSuggestionsResponse(v)
          }
        }()
        case 58: try {
          var v: Server_SetLinkRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .setLinkRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .setLinkRequest(v)
          }
        }()
        case 59: try {
          var v: Server_SetLinkResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .setLinkResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .setLinkResult(v)
          }
        }()
        case 60: try {
          var v: Server_SetBioRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .setBioRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .setBioRequest(v)
          }
        }()
        case 61: try {
          var v: Server_SetBioResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .setBioResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .setBioResult(v)
          }
        }()
        case 62: try {
          var v: Server_UserProfileRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .userProfileRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .userProfileRequest(v)
          }
        }()
        case 63: try {
          var v: Server_UserProfileResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .userProfileResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .userProfileResult(v)
          }
        }()
        case 64: try {
          var v: Server_PostMetricsRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .postMetricsRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .postMetricsRequest(v)
          }
        }()
        case 65: try {
          var v: Server_PostMetricsResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .postMetricsResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .postMetricsResult(v)
          }
        }()
        case 66: try {
          var v: Server_AiImageRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .aiImageRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .aiImageRequest(v)
          }
        }()
        case 67: try {
          var v: Server_AiImageResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .aiImageResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .aiImageResult(v)
          }
        }()
        case 68: try {
          var v: Server_ArchiveRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .archiveRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .archiveRequest(v)
          }
        }()
        case 69: try {
          var v: Server_ArchiveResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .archiveResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .archiveResult(v)
          }
        }()
        case 70: try {
          var v: Server_PostSubscriptionRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .postSubscriptionRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .postSubscriptionRequest(v)
          }
        }()
        case 71: try {
          var v: Server_PostSubscriptionResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .postSubscriptionResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .postSubscriptionResponse(v)
          }
        }()
        case 72: try {
          var v: Server_GeoTagRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .geoTagRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .geoTagRequest(v)
          }
        }()
        case 73: try {
          var v: Server_GeoTagResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .geoTagResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .geoTagResponse(v)
          }
        }()
        case 74: try {
          var v: Server_RegisterRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .registerRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .registerRequest(v)
          }
        }()
        case 75: try {
          var v: Server_RegisterResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .registerResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .registerResponse(v)
          }
        }()
        case 76: try {
          var v: Server_HalloappSearchRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .halloappSearchRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .halloappSearchRequest(v)
          }
        }()
        case 77: try {
          var v: Server_HalloappSearchResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .halloappSearchResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .halloappSearchResponse(v)
          }
        }()
        case 78: try {
          var v: Server_FriendshipRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .friendshipRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .friendshipRequest(v)
          }
        }()
        case 79: try {
          var v: Server_FriendshipResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .friendshipResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .friendshipResponse(v)
          }
        }()
        case 80: try {
          var v: Server_FriendListRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .friendListRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .friendListRequest(v)
          }
        }()
        case 81: try {
          var v: Server_FriendListResponse?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .friendListResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .friendListResponse(v)
          }
        }()
        case 82: try {
          var v: Server_Album?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .album(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .album(v)
          }
        }()
        case 83: try {
          var v: Server_AlbumResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .albumResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .albumResult(v)
          }
        }()
        case 84: try {
          var v: Server_GetAlbums?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .getAlbums(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .getAlbums(v)
          }
        }()
        case 85: try {
          var v: Server_HalloappProfileRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .halloappProfileRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .halloappProfileRequest(v)
          }
        }()
        case 86: try {
          var v: Server_HalloappProfileResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .hallaoppProfileResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .hallaoppProfileResult(v)
          }
        }()
        case 87: try {
          var v: Server_ReverseGeocodeRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .reverseGeocodeRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .reverseGeocodeRequest(v)
          }
        }()
        case 88: try {
          var v: Server_ReverseGeocodeResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .reverseGeocodeResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .reverseGeocodeResult(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .get {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      switch _storage._payload {
      case .uploadMedia?: try {
        guard case .uploadMedia(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .contactList?: try {
        guard case .contactList(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .uploadAvatar?: try {
        guard case .uploadAvatar(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .avatar?: try {
        guard case .avatar(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .avatars?: try {
        guard case .avatars(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .clientMode?: try {
        guard case .clientMode(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .clientVersion?: try {
        guard case .clientVersion(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .pushRegister?: try {
        guard case .pushRegister(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .whisperKeys?: try {
        guard case .whisperKeys(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .ping?: try {
        guard case .ping(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .feedItem?: try {
        guard case .feedItem(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .privacyList?: try {
        guard case .privacyList(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .privacyLists?: try {
        guard case .privacyLists(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .groupStanza?: try {
        guard case .groupStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .groupsStanza?: try {
        guard case .groupsStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .clientLog?: try {
        guard case .clientLog(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .name?: try {
        guard case .name(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .errorStanza?: try {
        guard case .errorStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .props?: try {
        guard case .props(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .invitesRequest?: try {
        guard case .invitesRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .invitesResponse?: try {
        guard case .invitesResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .notificationPrefs?: try {
        guard case .notificationPrefs(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .groupFeedItem?: try {
        guard case .groupFeedItem(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .groupAvatar?: try {
        guard case .groupAvatar(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .deleteAccount?: try {
        guard case .deleteAccount(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .groupInviteLink?: try {
        guard case .groupInviteLink(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .historyResend?: try {
        guard case .historyResend(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .exportData?: try {
        guard case .exportData(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .contactSyncError?: try {
        guard case .contactSyncError(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .clientOtpRequest?: try {
        guard case .clientOtpRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .clientOtpResponse?: try {
        guard case .clientOtpResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .whisperKeysCollection?: try {
        guard case .whisperKeysCollection(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .getCallServers?: try {
        guard case .getCallServers(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .getCallServersResult?: try {
        guard case .getCallServersResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .startCall?: try {
        guard case .startCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .startCallResult?: try {
        guard case .startCallResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .truncWhisperKeysCollection?: try {
        guard case .truncWhisperKeysCollection(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .externalSharePost?: try {
        guard case .externalSharePost(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .externalSharePostContainer?: try {
        guard case .externalSharePostContainer(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .webClientInfo?: try {
        guard case .webClientInfo(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .reportUserContent?: try {
        guard case .reportUserContent(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .publicFeedRequest?: try {
        guard case .publicFeedRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .publicFeedResponse?: try {
        guard case .publicFeedResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .relationshipRequest?: try {
        guard case .relationshipRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .relationshipResponse?: try {
        guard case .relationshipResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .relationshipList?: try {
        guard case .relationshipList(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .usernameRequest?: try {
        guard case .usernameRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .usernameResponse?: try {
        guard case .usernameResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .searchRequest?: try {
        guard case .searchRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case .searchResponse?: try {
        guard case .searchResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }()
      case .followSuggestionsRequest?: try {
        guard case .followSuggestionsRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      }()
      case .followSuggestionsResponse?: try {
        guard case .followSuggestionsResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }()
      case .setLinkRequest?: try {
        guard case .setLinkRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      }()
      case .setLinkResult?: try {
        guard case .setLinkResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      }()
      case .setBioRequest?: try {
        guard case .setBioRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }()
      case .setBioResult?: try {
        guard case .setBioResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }()
      case .userProfileRequest?: try {
        guard case .userProfileRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }()
      case .userProfileResult?: try {
        guard case .userProfileResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 63)
      }()
      case .postMetricsRequest?: try {
        guard case .postMetricsRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 64)
      }()
      case .postMetricsResult?: try {
        guard case .postMetricsResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 65)
      }()
      case .aiImageRequest?: try {
        guard case .aiImageRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 66)
      }()
      case .aiImageResult?: try {
        guard case .aiImageResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 67)
      }()
      case .archiveRequest?: try {
        guard case .archiveRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 68)
      }()
      case .archiveResult?: try {
        guard case .archiveResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 69)
      }()
      case .postSubscriptionRequest?: try {
        guard case .postSubscriptionRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 70)
      }()
      case .postSubscriptionResponse?: try {
        guard case .postSubscriptionResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 71)
      }()
      case .geoTagRequest?: try {
        guard case .geoTagRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 72)
      }()
      case .geoTagResponse?: try {
        guard case .geoTagResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 73)
      }()
      case .registerRequest?: try {
        guard case .registerRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 74)
      }()
      case .registerResponse?: try {
        guard case .registerResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 75)
      }()
      case .halloappSearchRequest?: try {
        guard case .halloappSearchRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 76)
      }()
      case .halloappSearchResponse?: try {
        guard case .halloappSearchResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 77)
      }()
      case .friendshipRequest?: try {
        guard case .friendshipRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 78)
      }()
      case .friendshipResponse?: try {
        guard case .friendshipResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 79)
      }()
      case .friendListRequest?: try {
        guard case .friendListRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 80)
      }()
      case .friendListResponse?: try {
        guard case .friendListResponse(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 81)
      }()
      case .album?: try {
        guard case .album(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 82)
      }()
      case .albumResult?: try {
        guard case .albumResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 83)
      }()
      case .getAlbums?: try {
        guard case .getAlbums(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 84)
      }()
      case .halloappProfileRequest?: try {
        guard case .halloappProfileRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 85)
      }()
      case .hallaoppProfileResult?: try {
        guard case .hallaoppProfileResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 86)
      }()
      case .reverseGeocodeRequest?: try {
        guard case .reverseGeocodeRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 87)
      }()
      case .reverseGeocodeResult?: try {
        guard case .reverseGeocodeResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 88)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Iq, rhs: Server_Iq) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Iq.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "SET"),
    2: .same(proto: "RESULT"),
    3: .same(proto: "ERROR"),
  ]
}

extension Server_Msg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Msg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "to_uid"),
    4: .standard(proto: "from_uid"),
    5: .standard(proto: "contact_list"),
    6: .same(proto: "avatar"),
    7: .standard(proto: "whisper_keys"),
    8: .standard(proto: "seen_receipt"),
    9: .standard(proto: "delivery_receipt"),
    10: .standard(proto: "chat_stanza"),
    11: .standard(proto: "feed_item"),
    12: .standard(proto: "feed_items"),
    13: .standard(proto: "contact_hash"),
    14: .standard(proto: "group_stanza"),
    15: .standard(proto: "group_chat"),
    16: .same(proto: "name"),
    17: .standard(proto: "error_stanza"),
    18: .standard(proto: "groupchat_retract"),
    19: .standard(proto: "chat_retract"),
    20: .standard(proto: "group_feed_item"),
    22: .same(proto: "rerequest"),
    23: .standard(proto: "silent_chat_stanza"),
    24: .standard(proto: "group_feed_items"),
    26: .standard(proto: "end_of_queue"),
    27: .standard(proto: "invitee_notice"),
    28: .standard(proto: "group_feed_rerequest"),
    29: .standard(proto: "history_resend"),
    30: .standard(proto: "played_receipt"),
    31: .standard(proto: "request_logs"),
    32: .same(proto: "wakeup"),
    33: .standard(proto: "home_feed_rerequest"),
    34: .standard(proto: "incoming_call"),
    35: .standard(proto: "call_ringing"),
    36: .standard(proto: "answer_call"),
    37: .standard(proto: "end_call"),
    38: .standard(proto: "ice_candidate"),
    39: .standard(proto: "marketing_alert"),
    40: .standard(proto: "ice_restart_offer"),
    41: .standard(proto: "ice_restart_answer"),
    42: .standard(proto: "group_feed_history"),
    43: .standard(proto: "pre_answer_call"),
    44: .standard(proto: "hold_call"),
    45: .standard(proto: "mute_call"),
    46: .standard(proto: "incoming_call_push"),
    47: .standard(proto: "call_sdp"),
    48: .standard(proto: "web_stanza"),
    49: .standard(proto: "content_missing"),
    50: .standard(proto: "screenshot_receipt"),
    51: .standard(proto: "saved_receipt"),
    52: .standard(proto: "group_chat_stanza"),
    53: .standard(proto: "moment_notification"),
    54: .standard(proto: "profile_update"),
    55: .standard(proto: "public_feed_update"),
    56: .standard(proto: "ai_image"),
    57: .standard(proto: "halloapp_profile_update"),
    58: .same(proto: "album"),
    59: .standard(proto: "friend_list_request"),
    21: .standard(proto: "retry_count"),
    25: .standard(proto: "rerequest_count"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: Server_Msg.TypeEnum = .normal
    var _toUid: Int64 = 0
    var _fromUid: Int64 = 0
    var _payload: Server_Msg.OneOf_Payload?
    var _retryCount: Int32 = 0
    var _rerequestCount: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _toUid = source._toUid
      _fromUid = source._fromUid
      _payload = source._payload
      _retryCount = source._retryCount
      _rerequestCount = source._rerequestCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._toUid) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._fromUid) }()
        case 5: try {
          var v: Server_ContactList?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .contactList(v)
          }
        }()
        case 6: try {
          var v: Server_Avatar?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .avatar(v)
          }
        }()
        case 7: try {
          var v: Server_WhisperKeys?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .whisperKeys(v)
          }
        }()
        case 8: try {
          var v: Server_SeenReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .seenReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .seenReceipt(v)
          }
        }()
        case 9: try {
          var v: Server_DeliveryReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .deliveryReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .deliveryReceipt(v)
          }
        }()
        case 10: try {
          var v: Server_ChatStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .chatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .chatStanza(v)
          }
        }()
        case 11: try {
          var v: Server_FeedItem?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .feedItem(v)
          }
        }()
        case 12: try {
          var v: Server_FeedItems?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .feedItems(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .feedItems(v)
          }
        }()
        case 13: try {
          var v: Server_ContactHash?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .contactHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .contactHash(v)
          }
        }()
        case 14: try {
          var v: Server_GroupStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupStanza(v)
          }
        }()
        case 15: try {
          var v: Server_GroupChat?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupChat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupChat(v)
          }
        }()
        case 16: try {
          var v: Server_Name?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .name(v)
          }
        }()
        case 17: try {
          var v: Server_ErrorStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .errorStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .errorStanza(v)
          }
        }()
        case 18: try {
          var v: Server_GroupChatRetract?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupchatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupchatRetract(v)
          }
        }()
        case 19: try {
          var v: Server_ChatRetract?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .chatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .chatRetract(v)
          }
        }()
        case 20: try {
          var v: Server_GroupFeedItem?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedItem(v)
          }
        }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._retryCount) }()
        case 22: try {
          var v: Server_Rerequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .rerequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .rerequest(v)
          }
        }()
        case 23: try {
          var v: Server_SilentChatStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .silentChatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .silentChatStanza(v)
          }
        }()
        case 24: try {
          var v: Server_GroupFeedItems?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedItems(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedItems(v)
          }
        }()
        case 25: try { try decoder.decodeSingularInt32Field(value: &_storage._rerequestCount) }()
        case 26: try {
          var v: Server_EndOfQueue?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .endOfQueue(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .endOfQueue(v)
          }
        }()
        case 27: try {
          var v: Server_InviteeNotice?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .inviteeNotice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .inviteeNotice(v)
          }
        }()
        case 28: try {
          var v: Server_GroupFeedRerequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedRerequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedRerequest(v)
          }
        }()
        case 29: try {
          var v: Server_HistoryResend?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .historyResend(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .historyResend(v)
          }
        }()
        case 30: try {
          var v: Server_PlayedReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .playedReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .playedReceipt(v)
          }
        }()
        case 31: try {
          var v: Server_RequestLogs?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .requestLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .requestLogs(v)
          }
        }()
        case 32: try {
          var v: Server_WakeUp?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .wakeup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .wakeup(v)
          }
        }()
        case 33: try {
          var v: Server_HomeFeedRerequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .homeFeedRerequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .homeFeedRerequest(v)
          }
        }()
        case 34: try {
          var v: Server_IncomingCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .incomingCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .incomingCall(v)
          }
        }()
        case 35: try {
          var v: Server_CallRinging?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .callRinging(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .callRinging(v)
          }
        }()
        case 36: try {
          var v: Server_AnswerCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .answerCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .answerCall(v)
          }
        }()
        case 37: try {
          var v: Server_EndCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .endCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .endCall(v)
          }
        }()
        case 38: try {
          var v: Server_IceCandidate?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .iceCandidate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .iceCandidate(v)
          }
        }()
        case 39: try {
          var v: Server_MarketingAlert?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .marketingAlert(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .marketingAlert(v)
          }
        }()
        case 40: try {
          var v: Server_IceRestartOffer?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .iceRestartOffer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .iceRestartOffer(v)
          }
        }()
        case 41: try {
          var v: Server_IceRestartAnswer?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .iceRestartAnswer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .iceRestartAnswer(v)
          }
        }()
        case 42: try {
          var v: Server_GroupFeedHistory?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupFeedHistory(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupFeedHistory(v)
          }
        }()
        case 43: try {
          var v: Server_PreAnswerCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .preAnswerCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .preAnswerCall(v)
          }
        }()
        case 44: try {
          var v: Server_HoldCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .holdCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .holdCall(v)
          }
        }()
        case 45: try {
          var v: Server_MuteCall?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .muteCall(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .muteCall(v)
          }
        }()
        case 46: try {
          var v: Server_IncomingCallPush?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .incomingCallPush(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .incomingCallPush(v)
          }
        }()
        case 47: try {
          var v: Server_CallSdp?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .callSdp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .callSdp(v)
          }
        }()
        case 48: try {
          var v: Server_WebStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .webStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .webStanza(v)
          }
        }()
        case 49: try {
          var v: Server_ContentMissing?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .contentMissing(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .contentMissing(v)
          }
        }()
        case 50: try {
          var v: Server_ScreenshotReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .screenshotReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .screenshotReceipt(v)
          }
        }()
        case 51: try {
          var v: Server_SavedReceipt?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .savedReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .savedReceipt(v)
          }
        }()
        case 52: try {
          var v: Server_GroupChatStanza?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .groupChatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .groupChatStanza(v)
          }
        }()
        case 53: try {
          var v: Server_MomentNotification?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .momentNotification(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .momentNotification(v)
          }
        }()
        case 54: try {
          var v: Server_ProfileUpdate?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .profileUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .profileUpdate(v)
          }
        }()
        case 55: try {
          var v: Server_PublicFeedUpdate?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .publicFeedUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .publicFeedUpdate(v)
          }
        }()
        case 56: try {
          var v: Server_AiImage?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .aiImage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .aiImage(v)
          }
        }()
        case 57: try {
          var v: Server_HalloappProfileUpdate?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .halloappProfileUpdate(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .halloappProfileUpdate(v)
          }
        }()
        case 58: try {
          var v: Server_Album?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .album(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .album(v)
          }
        }()
        case 59: try {
          var v: Server_FriendListRequest?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .friendListRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .friendListRequest(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._toUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._toUid, fieldNumber: 3)
      }
      if _storage._fromUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fromUid, fieldNumber: 4)
      }
      switch _storage._payload {
      case .contactList?: try {
        guard case .contactList(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .avatar?: try {
        guard case .avatar(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .whisperKeys?: try {
        guard case .whisperKeys(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .seenReceipt?: try {
        guard case .seenReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .deliveryReceipt?: try {
        guard case .deliveryReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .chatStanza?: try {
        guard case .chatStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .feedItem?: try {
        guard case .feedItem(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .feedItems?: try {
        guard case .feedItems(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .contactHash?: try {
        guard case .contactHash(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .groupStanza?: try {
        guard case .groupStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .groupChat?: try {
        guard case .groupChat(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .name?: try {
        guard case .name(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .errorStanza?: try {
        guard case .errorStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .groupchatRetract?: try {
        guard case .groupchatRetract(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .chatRetract?: try {
        guard case .chatRetract(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .groupFeedItem?: try {
        guard case .groupFeedItem(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      default: break
      }
      if _storage._retryCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._retryCount, fieldNumber: 21)
      }
      switch _storage._payload {
      case .rerequest?: try {
        guard case .rerequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .silentChatStanza?: try {
        guard case .silentChatStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .groupFeedItems?: try {
        guard case .groupFeedItems(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      default: break
      }
      if _storage._rerequestCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._rerequestCount, fieldNumber: 25)
      }
      switch _storage._payload {
      case .endOfQueue?: try {
        guard case .endOfQueue(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .inviteeNotice?: try {
        guard case .inviteeNotice(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .groupFeedRerequest?: try {
        guard case .groupFeedRerequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .historyResend?: try {
        guard case .historyResend(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .playedReceipt?: try {
        guard case .playedReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .requestLogs?: try {
        guard case .requestLogs(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .wakeup?: try {
        guard case .wakeup(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .homeFeedRerequest?: try {
        guard case .homeFeedRerequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .incomingCall?: try {
        guard case .incomingCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .callRinging?: try {
        guard case .callRinging(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .answerCall?: try {
        guard case .answerCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .endCall?: try {
        guard case .endCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .iceCandidate?: try {
        guard case .iceCandidate(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .marketingAlert?: try {
        guard case .marketingAlert(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .iceRestartOffer?: try {
        guard case .iceRestartOffer(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .iceRestartAnswer?: try {
        guard case .iceRestartAnswer(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .groupFeedHistory?: try {
        guard case .groupFeedHistory(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .preAnswerCall?: try {
        guard case .preAnswerCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .holdCall?: try {
        guard case .holdCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .muteCall?: try {
        guard case .muteCall(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .incomingCallPush?: try {
        guard case .incomingCallPush(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .callSdp?: try {
        guard case .callSdp(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .webStanza?: try {
        guard case .webStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .contentMissing?: try {
        guard case .contentMissing(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .screenshotReceipt?: try {
        guard case .screenshotReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .savedReceipt?: try {
        guard case .savedReceipt(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .groupChatStanza?: try {
        guard case .groupChatStanza(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .momentNotification?: try {
        guard case .momentNotification(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .profileUpdate?: try {
        guard case .profileUpdate(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case .publicFeedUpdate?: try {
        guard case .publicFeedUpdate(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }()
      case .aiImage?: try {
        guard case .aiImage(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      }()
      case .halloappProfileUpdate?: try {
        guard case .halloappProfileUpdate(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }()
      case .album?: try {
        guard case .album(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      }()
      case .friendListRequest?: try {
        guard case .friendListRequest(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Msg, rhs: Server_Msg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._toUid != rhs_storage._toUid {return false}
        if _storage._fromUid != rhs_storage._fromUid {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._retryCount != rhs_storage._retryCount {return false}
        if _storage._rerequestCount != rhs_storage._rerequestCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Msg.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "GROUPCHAT"),
    3: .same(proto: "HEADLINE"),
    4: .same(proto: "CHAT"),
    5: .same(proto: "CALL"),
  ]
}

extension Server_Presence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Presence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "uid"),
    4: .standard(proto: "last_seen"),
    5: .standard(proto: "to_uid"),
    6: .standard(proto: "from_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastSeen) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.toUid) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.fromUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 3)
    }
    if self.lastSeen != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeen, fieldNumber: 4)
    }
    if self.toUid != 0 {
      try visitor.visitSingularInt64Field(value: self.toUid, fieldNumber: 5)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Presence, rhs: Server_Presence) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.lastSeen != rhs.lastSeen {return false}
    if lhs.toUid != rhs.toUid {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Presence.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AVAILABLE"),
    1: .same(proto: "AWAY"),
    2: .same(proto: "SUBSCRIBE"),
    3: .same(proto: "UNSUBSCRIBE"),
  ]
}

extension Server_ChatState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "thread_id"),
    3: .standard(proto: "thread_type"),
    4: .standard(proto: "from_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.threadType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.fromUid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.threadType != .chat {
      try visitor.visitSingularEnumField(value: self.threadType, fieldNumber: 3)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatState, rhs: Server_ChatState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.threadType != rhs.threadType {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatState.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AVAILABLE"),
    1: .same(proto: "TYPING"),
  ]
}

extension Server_ChatState.ThreadType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "GROUP_CHAT"),
  ]
}

extension Server_Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Ack, rhs: Server_Ack) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HaError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HaError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HaError, rhs: Server_HaError) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Packet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "iq"),
    3: .same(proto: "ack"),
    4: .same(proto: "presence"),
    5: .standard(proto: "ha_error"),
    6: .standard(proto: "chat_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Server_Msg?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .msg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .msg(v)
        }
      }()
      case 2: try {
        var v: Server_Iq?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .iq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .iq(v)
        }
      }()
      case 3: try {
        var v: Server_Ack?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .ack(v)
        }
      }()
      case 4: try {
        var v: Server_Presence?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .presence(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .presence(v)
        }
      }()
      case 5: try {
        var v: Server_HaError?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .haError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .haError(v)
        }
      }()
      case 6: try {
        var v: Server_ChatState?
        var hadOneofValue = false
        if let current = self.stanza {
          hadOneofValue = true
          if case .chatState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.stanza = .chatState(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.stanza {
    case .msg?: try {
      guard case .msg(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .iq?: try {
      guard case .iq(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .presence?: try {
      guard case .presence(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .haError?: try {
      guard case .haError(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .chatState?: try {
      guard case .chatState(let v)? = self.stanza else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Packet, rhs: Server_Packet) -> Bool {
    if lhs.stanza != rhs.stanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UidElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UidElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UidElement, rhs: Server_UidElement) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UidElement.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_PhoneElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhoneElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "phone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PhoneElement, rhs: Server_PhoneElement) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PhoneElement.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_PrivacyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "uid_elements"),
    3: .same(proto: "hash"),
    4: .standard(proto: "phone_elements"),
    5: .standard(proto: "using_phones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.uidElements) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.phoneElements) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.usingPhones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.uidElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uidElements, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 3)
    }
    if !self.phoneElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phoneElements, fieldNumber: 4)
    }
    if self.usingPhones != false {
      try visitor.visitSingularBoolField(value: self.usingPhones, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PrivacyList, rhs: Server_PrivacyList) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.uidElements != rhs.uidElements {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.phoneElements != rhs.phoneElements {return false}
    if lhs.usingPhones != rhs.usingPhones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PrivacyList.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "EXCEPT"),
    3: .same(proto: "MUTE"),
    4: .same(proto: "ONLY"),
  ]
}

extension Server_PrivacyLists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyLists"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_type"),
    2: .same(proto: "lists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.activeType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lists) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeType != .all {
      try visitor.visitSingularEnumField(value: self.activeType, fieldNumber: 1)
    }
    if !self.lists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lists, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PrivacyLists, rhs: Server_PrivacyLists) -> Bool {
    if lhs.activeType != rhs.activeType {return false}
    if lhs.lists != rhs.lists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PrivacyLists.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "EXCEPT"),
    3: .same(proto: "ONLY"),
  ]
}

extension Server_PushToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_type"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tokenType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tokenType != .android {
      try visitor.visitSingularEnumField(value: self.tokenType, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushToken, rhs: Server_PushToken) -> Bool {
    if lhs.tokenType != rhs.tokenType {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushToken.TokenType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANDROID"),
    1: .same(proto: "IOS"),
    2: .same(proto: "IOS_DEV"),
    3: .same(proto: "IOS_APPCLIP"),
    4: .same(proto: "IOS_VOIP"),
    5: .same(proto: "ANDROID_HUAWEI"),
  ]
}

extension Server_PushRegister: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushRegister"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_token"),
    2: .standard(proto: "lang_id"),
    3: .same(proto: "zoneOffset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pushToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.langID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.zoneOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pushToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.langID.isEmpty {
      try visitor.visitSingularStringField(value: self.langID, fieldNumber: 2)
    }
    if self.zoneOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.zoneOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushRegister, rhs: Server_PushRegister) -> Bool {
    if lhs._pushToken != rhs._pushToken {return false}
    if lhs.langID != rhs.langID {return false}
    if lhs.zoneOffset != rhs.zoneOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushPref: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushPref"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.name != .post {
      try visitor.visitSingularEnumField(value: self.name, fieldNumber: 1)
    }
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushPref, rhs: Server_PushPref) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushPref.Name: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "COMMENT"),
    2: .same(proto: "MENTIONS"),
    3: .same(proto: "ON_FIRE"),
    4: .same(proto: "NEW_USERS"),
    5: .same(proto: "FOLLOWERS"),
  ]
}

extension Server_NotificationPrefs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationPrefs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_prefs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pushPrefs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pushPrefs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pushPrefs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_NotificationPrefs, rhs: Server_NotificationPrefs) -> Bool {
    if lhs.pushPrefs != rhs.pushPrefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Rerequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rerequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "identity_key"),
    3: .standard(proto: "signed_pre_key_id"),
    4: .standard(proto: "one_time_pre_key_id"),
    5: .standard(proto: "session_setup_ephemeral_key"),
    6: .standard(proto: "message_ephemeral_key"),
    7: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.signedPreKeyID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.sessionSetupEphemeralKey) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.messageEphemeralKey) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 2)
    }
    if self.signedPreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.signedPreKeyID, fieldNumber: 3)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 4)
    }
    if !self.sessionSetupEphemeralKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionSetupEphemeralKey, fieldNumber: 5)
    }
    if !self.messageEphemeralKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageEphemeralKey, fieldNumber: 6)
    }
    if self.contentType != .chat {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Rerequest, rhs: Server_Rerequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.signedPreKeyID != rhs.signedPreKeyID {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.sessionSetupEphemeralKey != rhs.sessionSetupEphemeralKey {return false}
    if lhs.messageEphemeralKey != rhs.messageEphemeralKey {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Rerequest.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "CALL"),
    2: .same(proto: "GROUP_HISTORY"),
    3: .same(proto: "CHAT_REACTION"),
  ]
}

extension Server_GroupFeedRerequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedRerequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "id"),
    3: .standard(proto: "rerequest_type"),
    4: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rerequestType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if self.rerequestType != .payload {
      try visitor.visitSingularEnumField(value: self.rerequestType, fieldNumber: 3)
    }
    if self.contentType != .unknown {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedRerequest, rhs: Server_GroupFeedRerequest) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.id != rhs.id {return false}
    if lhs.rerequestType != rhs.rerequestType {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedRerequest.RerequestType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PAYLOAD"),
    1: .same(proto: "SENDER_STATE"),
  ]
}

extension Server_GroupFeedRerequest.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "POST"),
    2: .same(proto: "COMMENT"),
    3: .same(proto: "HISTORY_RESEND"),
    4: .same(proto: "POST_REACTION"),
    5: .same(proto: "COMMENT_REACTION"),
    6: .same(proto: "MESSAGE"),
    7: .same(proto: "MESSAGE_REACTION"),
  ]
}

extension Server_HomeFeedRerequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HomeFeedRerequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "rerequest_type"),
    4: .standard(proto: "content_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.rerequestType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.rerequestType != .unknownType {
      try visitor.visitSingularEnumField(value: self.rerequestType, fieldNumber: 2)
    }
    if self.contentType != .unknown {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HomeFeedRerequest, rhs: Server_HomeFeedRerequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rerequestType != rhs.rerequestType {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HomeFeedRerequest.RerequestType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "PAYLOAD"),
    2: .same(proto: "SENDER_STATE"),
  ]
}

extension Server_HomeFeedRerequest.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "POST"),
    2: .same(proto: "COMMENT"),
    3: .same(proto: "POST_REACTION"),
    4: .same(proto: "COMMENT_REACTION"),
  ]
}

extension Server_SeenReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeenReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SeenReceipt, rhs: Server_SeenReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DeliveryReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeliveryReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DeliveryReceipt, rhs: Server_DeliveryReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PlayedReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlayedReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PlayedReceipt, rhs: Server_PlayedReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ScreenshotReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScreenshotReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ScreenshotReceipt, rhs: Server_ScreenshotReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SavedReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SavedReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.threadID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SavedReceipt, rhs: Server_SavedReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupChatRetract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChatRetract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "gid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupChatRetract, rhs: Server_GroupChatRetract) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatRetract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatRetract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatRetract, rhs: Server_ChatRetract) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Prop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Prop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Prop, rhs: Server_Prop) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Props: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Props"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "props"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.props) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.props.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.props, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Props, rhs: Server_Props) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.props != rhs.props {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhisperKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "action"),
    3: .standard(proto: "identity_key"),
    4: .standard(proto: "signed_key"),
    5: .standard(proto: "otp_key_count"),
    6: .standard(proto: "one_time_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.identityKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signedKey) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.otpKeyCount) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.oneTimeKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if self.action != .normal {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 3)
    }
    if !self.signedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedKey, fieldNumber: 4)
    }
    if self.otpKeyCount != 0 {
      try visitor.visitSingularInt32Field(value: self.otpKeyCount, fieldNumber: 5)
    }
    if !self.oneTimeKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.oneTimeKeys, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WhisperKeys, rhs: Server_WhisperKeys) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.action != rhs.action {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.signedKey != rhs.signedKey {return false}
    if lhs.otpKeyCount != rhs.otpKeyCount {return false}
    if lhs.oneTimeKeys != rhs.oneTimeKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeys.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ADD"),
    2: .same(proto: "COUNT"),
    3: .same(proto: "GET"),
    4: .same(proto: "SET"),
    5: .same(proto: "UPDATE"),
  ]
}

extension Server_TruncWhisperKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TruncWhisperKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "trunc_public_identity_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.truncPublicIdentityKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.truncPublicIdentityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.truncPublicIdentityKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TruncWhisperKeys, rhs: Server_TruncWhisperKeys) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.truncPublicIdentityKey != rhs.truncPublicIdentityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeysCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhisperKeysCollection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WhisperKeysCollection, rhs: Server_WhisperKeysCollection) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_TruncWhisperKeysCollection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TruncWhisperKeysCollection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "collection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.collection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collection.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.collection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TruncWhisperKeysCollection, rhs: Server_TruncWhisperKeysCollection) -> Bool {
    if lhs.collection != rhs.collection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_NoiseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NoiseMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_type"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.messageType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageType != .xxA {
      try visitor.visitSingularEnumField(value: self.messageType, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_NoiseMessage, rhs: Server_NoiseMessage) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_NoiseMessage.MessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "XX_A"),
    1: .same(proto: "XX_B"),
    2: .same(proto: "XX_C"),
    3: .same(proto: "IK_A"),
    4: .same(proto: "IK_B"),
    5: .same(proto: "XX_FALLBACK_A"),
    6: .same(proto: "XX_FALLBACK_B"),
    7: .same(proto: "KK_A"),
    8: .same(proto: "KK_B"),
  ]
}

extension Server_DeleteAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "reason"),
    3: .same(proto: "feedback"),
    4: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.feedback) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.reason != .unknownDeleteReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.feedback.isEmpty {
      try visitor.visitSingularStringField(value: self.feedback, fieldNumber: 3)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DeleteAccount, rhs: Server_DeleteAccount) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.feedback != rhs.feedback {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DeleteAccount.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DELETE_REASON"),
  ]
}

extension Server_ExportData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_ready_ts"),
    2: .same(proto: "status"),
    3: .standard(proto: "data_url"),
    4: .standard(proto: "available_until_ts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.dataReadyTs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.dataURL) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.availableUntilTs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dataReadyTs != 0 {
      try visitor.visitSingularInt64Field(value: self.dataReadyTs, fieldNumber: 1)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.dataURL.isEmpty {
      try visitor.visitSingularStringField(value: self.dataURL, fieldNumber: 3)
    }
    if self.availableUntilTs != 0 {
      try visitor.visitSingularInt64Field(value: self.availableUntilTs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ExportData, rhs: Server_ExportData) -> Bool {
    if lhs.dataReadyTs != rhs.dataReadyTs {return false}
    if lhs.status != rhs.status {return false}
    if lhs.dataURL != rhs.dataURL {return false}
    if lhs.availableUntilTs != rhs.availableUntilTs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ExportData.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "READY"),
    3: .same(proto: "NOT_STARTED"),
  ]
}

extension Server_PushContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certificate"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.certificate) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificate, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushContent, rhs: Server_PushContent) -> Bool {
    if lhs.certificate != rhs.certificate {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InviteeNotice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InviteeNotice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inviters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inviters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inviters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inviters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InviteeNotice, rhs: Server_InviteeNotice) -> Bool {
    if lhs.inviters != rhs.inviters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Inviter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Inviter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
    3: .same(proto: "phone"),
    4: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Inviter, rhs: Server_Inviter) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_IdentityKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdentityKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_IdentityKey, rhs: Server_IdentityKey) -> Bool {
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RequestLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RequestLogs, rhs: Server_RequestLogs) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RegisterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otp_request"),
    2: .standard(proto: "verify_request"),
    3: .standard(proto: "hashcash_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Server_OtpRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .otpRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .otpRequest(v)
        }
      }()
      case 2: try {
        var v: Server_VerifyOtpRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .verifyRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .verifyRequest(v)
        }
      }()
      case 3: try {
        var v: Server_HashcashRequest?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .hashcashRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .hashcashRequest(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .otpRequest?: try {
      guard case .otpRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .verifyRequest?: try {
      guard case .verifyRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hashcashRequest?: try {
      guard case .hashcashRequest(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RegisterRequest, rhs: Server_RegisterRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RegisterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "otp_response"),
    2: .standard(proto: "verify_response"),
    3: .standard(proto: "hashcash_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Server_OtpResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .otpResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .otpResponse(v)
        }
      }()
      case 2: try {
        var v: Server_VerifyOtpResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .verifyResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .verifyResponse(v)
        }
      }()
      case 3: try {
        var v: Server_HashcashResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .hashcashResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .hashcashResponse(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .otpResponse?: try {
      guard case .otpResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .verifyResponse?: try {
      guard case .verifyResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .hashcashResponse?: try {
      guard case .hashcashResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RegisterResponse, rhs: Server_RegisterResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HashcashRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashcashRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HashcashRequest, rhs: Server_HashcashRequest) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HashcashResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HashcashResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hashcash_challenge"),
    2: .standard(proto: "is_phone_not_needed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hashcashChallenge) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isPhoneNotNeeded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashcashChallenge.isEmpty {
      try visitor.visitSingularStringField(value: self.hashcashChallenge, fieldNumber: 1)
    }
    if self.isPhoneNotNeeded != false {
      try visitor.visitSingularBoolField(value: self.isPhoneNotNeeded, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HashcashResponse, rhs: Server_HashcashResponse) -> Bool {
    if lhs.hashcashChallenge != rhs.hashcashChallenge {return false}
    if lhs.isPhoneNotNeeded != rhs.isPhoneNotNeeded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_OtpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OtpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "method"),
    3: .standard(proto: "lang_id"),
    4: .standard(proto: "group_invite_token"),
    5: .standard(proto: "user_agent"),
    6: .standard(proto: "hashcash_solution"),
    7: .standard(proto: "hashcash_solution_time_taken_ms"),
    8: .standard(proto: "campaign_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.langID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.groupInviteToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hashcashSolution) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.hashcashSolutionTimeTakenMs) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.campaignID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.method != .sms {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 2)
    }
    if !self.langID.isEmpty {
      try visitor.visitSingularStringField(value: self.langID, fieldNumber: 3)
    }
    if !self.groupInviteToken.isEmpty {
      try visitor.visitSingularStringField(value: self.groupInviteToken, fieldNumber: 4)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 5)
    }
    if !self.hashcashSolution.isEmpty {
      try visitor.visitSingularStringField(value: self.hashcashSolution, fieldNumber: 6)
    }
    if self.hashcashSolutionTimeTakenMs != 0 {
      try visitor.visitSingularInt64Field(value: self.hashcashSolutionTimeTakenMs, fieldNumber: 7)
    }
    if !self.campaignID.isEmpty {
      try visitor.visitSingularStringField(value: self.campaignID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_OtpRequest, rhs: Server_OtpRequest) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.method != rhs.method {return false}
    if lhs.langID != rhs.langID {return false}
    if lhs.groupInviteToken != rhs.groupInviteToken {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.hashcashSolution != rhs.hashcashSolution {return false}
    if lhs.hashcashSolutionTimeTakenMs != rhs.hashcashSolutionTimeTakenMs {return false}
    if lhs.campaignID != rhs.campaignID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_OtpRequest.Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SMS"),
    1: .same(proto: "VOICE_CALL"),
  ]
}

extension Server_OtpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OtpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "result"),
    3: .same(proto: "reason"),
    4: .standard(proto: "retry_after_secs"),
    5: .standard(proto: "should_verify_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.retryAfterSecs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.shouldVerifyNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 2)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 3)
    }
    if self.retryAfterSecs != 0 {
      try visitor.visitSingularInt64Field(value: self.retryAfterSecs, fieldNumber: 4)
    }
    if self.shouldVerifyNumber != false {
      try visitor.visitSingularBoolField(value: self.shouldVerifyNumber, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_OtpResponse, rhs: Server_OtpResponse) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.retryAfterSecs != rhs.retryAfterSecs {return false}
    if lhs.shouldVerifyNumber != rhs.shouldVerifyNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_OtpResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_OtpResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "INVALID_PHONE_NUMBER"),
    2: .same(proto: "INVALID_CLIENT_VERSION"),
    3: .same(proto: "BAD_METHOD"),
    4: .same(proto: "OTP_FAIL"),
    5: .same(proto: "NOT_INVITED"),
    6: .same(proto: "INVALID_GROUP_INVITE_TOKEN"),
    7: .same(proto: "RETRIED_TOO_SOON"),
    8: .same(proto: "BAD_REQUEST"),
    9: .same(proto: "INTERNAL_SERVER_ERROR"),
    10: .same(proto: "INVALID_HASHCASH_NONCE"),
    11: .same(proto: "WRONG_HASHCASH_SOLUTION"),
    12: .same(proto: "INVALID_COUNTRY_CODE"),
    13: .same(proto: "INVALID_LENGTH"),
    14: .same(proto: "LINE_TYPE_VOIP"),
    15: .same(proto: "LINE_TYPE_FIXED"),
    16: .same(proto: "LINE_TYPE_OTHER"),
  ]
}

extension Server_VerifyOtpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyOtpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "code"),
    3: .same(proto: "name"),
    4: .standard(proto: "static_key"),
    5: .standard(proto: "signed_phrase"),
    6: .standard(proto: "identity_key"),
    7: .standard(proto: "signed_key"),
    8: .standard(proto: "one_time_keys"),
    9: .standard(proto: "group_invite_token"),
    10: .standard(proto: "push_register"),
    11: .standard(proto: "user_agent"),
    12: .standard(proto: "campaign_id"),
    13: .standard(proto: "hashcash_solution"),
    14: .standard(proto: "hashcash_solution_time_taken_ms"),
    15: .same(proto: "uid"),
  ]

  fileprivate class _StorageClass {
    var _phone: String = String()
    var _code: String = String()
    var _name: String = String()
    var _staticKey: Data = Data()
    var _signedPhrase: Data = Data()
    var _identityKey: Data = Data()
    var _signedKey: Data = Data()
    var _oneTimeKeys: [Data] = []
    var _groupInviteToken: String = String()
    var _pushRegister: Server_PushRegister? = nil
    var _userAgent: String = String()
    var _campaignID: String = String()
    var _hashcashSolution: String = String()
    var _hashcashSolutionTimeTakenMs: Int64 = 0
    var _uid: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _phone = source._phone
      _code = source._code
      _name = source._name
      _staticKey = source._staticKey
      _signedPhrase = source._signedPhrase
      _identityKey = source._identityKey
      _signedKey = source._signedKey
      _oneTimeKeys = source._oneTimeKeys
      _groupInviteToken = source._groupInviteToken
      _pushRegister = source._pushRegister
      _userAgent = source._userAgent
      _campaignID = source._campaignID
      _hashcashSolution = source._hashcashSolution
      _hashcashSolutionTimeTakenMs = source._hashcashSolutionTimeTakenMs
      _uid = source._uid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._phone) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._code) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._staticKey) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._signedPhrase) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._identityKey) }()
        case 7: try { try decoder.decodeSingularBytesField(value: &_storage._signedKey) }()
        case 8: try { try decoder.decodeRepeatedBytesField(value: &_storage._oneTimeKeys) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._groupInviteToken) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._pushRegister) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._userAgent) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._campaignID) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._hashcashSolution) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._hashcashSolutionTimeTakenMs) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._uid) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._phone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._phone, fieldNumber: 1)
      }
      if !_storage._code.isEmpty {
        try visitor.visitSingularStringField(value: _storage._code, fieldNumber: 2)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._staticKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._staticKey, fieldNumber: 4)
      }
      if !_storage._signedPhrase.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signedPhrase, fieldNumber: 5)
      }
      if !_storage._identityKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._identityKey, fieldNumber: 6)
      }
      if !_storage._signedKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signedKey, fieldNumber: 7)
      }
      if !_storage._oneTimeKeys.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._oneTimeKeys, fieldNumber: 8)
      }
      if !_storage._groupInviteToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupInviteToken, fieldNumber: 9)
      }
      try { if let v = _storage._pushRegister {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._userAgent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userAgent, fieldNumber: 11)
      }
      if !_storage._campaignID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._campaignID, fieldNumber: 12)
      }
      if !_storage._hashcashSolution.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hashcashSolution, fieldNumber: 13)
      }
      if _storage._hashcashSolutionTimeTakenMs != 0 {
        try visitor.visitSingularInt64Field(value: _storage._hashcashSolutionTimeTakenMs, fieldNumber: 14)
      }
      if _storage._uid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._uid, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_VerifyOtpRequest, rhs: Server_VerifyOtpRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._phone != rhs_storage._phone {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._staticKey != rhs_storage._staticKey {return false}
        if _storage._signedPhrase != rhs_storage._signedPhrase {return false}
        if _storage._identityKey != rhs_storage._identityKey {return false}
        if _storage._signedKey != rhs_storage._signedKey {return false}
        if _storage._oneTimeKeys != rhs_storage._oneTimeKeys {return false}
        if _storage._groupInviteToken != rhs_storage._groupInviteToken {return false}
        if _storage._pushRegister != rhs_storage._pushRegister {return false}
        if _storage._userAgent != rhs_storage._userAgent {return false}
        if _storage._campaignID != rhs_storage._campaignID {return false}
        if _storage._hashcashSolution != rhs_storage._hashcashSolution {return false}
        if _storage._hashcashSolutionTimeTakenMs != rhs_storage._hashcashSolutionTimeTakenMs {return false}
        if _storage._uid != rhs_storage._uid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_VerifyOtpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyOtpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "uid"),
    3: .same(proto: "name"),
    4: .same(proto: "result"),
    5: .same(proto: "reason"),
    6: .standard(proto: "group_invite_result"),
    7: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.groupInviteResult) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 4)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 5)
    }
    if !self.groupInviteResult.isEmpty {
      try visitor.visitSingularStringField(value: self.groupInviteResult, fieldNumber: 6)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_VerifyOtpResponse, rhs: Server_VerifyOtpResponse) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.groupInviteResult != rhs.groupInviteResult {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_VerifyOtpResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_VerifyOtpResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "INVALID_PHONE_NUMBER"),
    2: .same(proto: "INVALID_CLIENT_VERSION"),
    3: .same(proto: "WRONG_SMS_CODE"),
    4: .same(proto: "MISSING_PHONE"),
    5: .same(proto: "MISSING_CODE"),
    6: .same(proto: "MISSING_NAME"),
    7: .same(proto: "INVALID_NAME"),
    8: .same(proto: "MISSING_IDENTITY_KEY"),
    9: .same(proto: "MISSING_SIGNED_KEY"),
    10: .same(proto: "MISSING_ONE_TIME_KEYS"),
    11: .same(proto: "BAD_BASE64_KEY"),
    12: .same(proto: "INVALID_ONE_TIME_KEYS"),
    13: .same(proto: "TOO_FEW_ONE_TIME_KEYS"),
    14: .same(proto: "TOO_MANY_ONE_TIME_KEYS"),
    15: .same(proto: "TOO_BIG_IDENTITY_KEY"),
    16: .same(proto: "TOO_BIG_SIGNED_KEY"),
    17: .same(proto: "TOO_BIG_ONE_TIME_KEYS"),
    18: .same(proto: "INVALID_S_ED_PUB"),
    19: .same(proto: "INVALID_SIGNED_PHRASE"),
    20: .same(proto: "UNABLE_TO_OPEN_SIGNED_PHRASE"),
    21: .same(proto: "BAD_REQUEST"),
    22: .same(proto: "INTERNAL_SERVER_ERROR"),
    23: .same(proto: "INVALID_COUNTRY_CODE"),
    24: .same(proto: "INVALID_LENGTH"),
    25: .same(proto: "LINE_TYPE_VOIP"),
    26: .same(proto: "LINE_TYPE_FIXED"),
    27: .same(proto: "LINE_TYPE_OTHER"),
    28: .same(proto: "WRONG_HASHCASH_SOLUTION"),
  ]
}

extension Server_ClientOtpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientOtpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "phone"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.method) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.method != .sms {
      try visitor.visitSingularEnumField(value: self.method, fieldNumber: 1)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 2)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientOtpRequest, rhs: Server_ClientOtpRequest) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientOtpRequest.Method: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SMS"),
    1: .same(proto: "VOICE_CALL"),
  ]
}

extension Server_ClientOtpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientOtpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknownResult {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientOtpResponse, rhs: Server_ClientOtpResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientOtpResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_RESULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "FAILURE"),
  ]
}

extension Server_ClientOtpResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "SETUP_ISSUE"),
    2: .same(proto: "PERMISSION_ISSUE"),
    3: .same(proto: "FORMATTING_ISSUE"),
    4: .same(proto: "NETWORKING_ISSUE"),
  ]
}

extension Server_WakeUp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WakeUp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alert_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.alertType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alertType != .alert {
      try visitor.visitSingularEnumField(value: self.alertType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WakeUp, rhs: Server_WakeUp) -> Bool {
    if lhs.alertType != rhs.alertType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WakeUp.AlertType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALERT"),
    1: .same(proto: "SILENT"),
  ]
}

extension Server_MarketingAlert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MarketingAlert"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MarketingAlert, rhs: Server_MarketingAlert) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MarketingAlert.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVITE_FRIENDS"),
    2: .same(proto: "SHARE_POST"),
  ]
}

extension Server_BasicUserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BasicUserProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "username"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .standard(proto: "follower_status"),
    6: .standard(proto: "following_status"),
    7: .standard(proto: "num_mutual_following"),
    8: .same(proto: "blocked"),
    9: .standard(proto: "geo_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.followerStatus) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.followingStatus) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.numMutualFollowing) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.geoTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 4)
    }
    if self.followerStatus != .none {
      try visitor.visitSingularEnumField(value: self.followerStatus, fieldNumber: 5)
    }
    if self.followingStatus != .none {
      try visitor.visitSingularEnumField(value: self.followingStatus, fieldNumber: 6)
    }
    if self.numMutualFollowing != 0 {
      try visitor.visitSingularInt32Field(value: self.numMutualFollowing, fieldNumber: 7)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 8)
    }
    if !self.geoTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.geoTags, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_BasicUserProfile, rhs: Server_BasicUserProfile) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.username != rhs.username {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.followerStatus != rhs.followerStatus {return false}
    if lhs.followingStatus != rhs.followingStatus {return false}
    if lhs.numMutualFollowing != rhs.numMutualFollowing {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.geoTags != rhs.geoTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "username"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .standard(proto: "follower_status"),
    6: .standard(proto: "following_status"),
    7: .standard(proto: "num_mutual_following"),
    8: .same(proto: "bio"),
    9: .same(proto: "links"),
    10: .standard(proto: "relevant_followers"),
    11: .same(proto: "blocked"),
    12: .standard(proto: "total_post_impressions"),
    13: .standard(proto: "total_post_reactions"),
    14: .standard(proto: "total_num_posts"),
    15: .standard(proto: "geo_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.followerStatus) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.followingStatus) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.numMutualFollowing) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.bio) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.relevantFollowers) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.totalPostImpressions) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.totalPostReactions) }()
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.totalNumPosts) }()
      case 15: try { try decoder.decodeRepeatedStringField(value: &self.geoTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 4)
    }
    if self.followerStatus != .none {
      try visitor.visitSingularEnumField(value: self.followerStatus, fieldNumber: 5)
    }
    if self.followingStatus != .none {
      try visitor.visitSingularEnumField(value: self.followingStatus, fieldNumber: 6)
    }
    if self.numMutualFollowing != 0 {
      try visitor.visitSingularInt32Field(value: self.numMutualFollowing, fieldNumber: 7)
    }
    if !self.bio.isEmpty {
      try visitor.visitSingularStringField(value: self.bio, fieldNumber: 8)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 9)
    }
    if !self.relevantFollowers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relevantFollowers, fieldNumber: 10)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 11)
    }
    if self.totalPostImpressions != 0 {
      try visitor.visitSingularInt32Field(value: self.totalPostImpressions, fieldNumber: 12)
    }
    if self.totalPostReactions != 0 {
      try visitor.visitSingularInt32Field(value: self.totalPostReactions, fieldNumber: 13)
    }
    if self.totalNumPosts != 0 {
      try visitor.visitSingularInt32Field(value: self.totalNumPosts, fieldNumber: 14)
    }
    if !self.geoTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.geoTags, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UserProfile, rhs: Server_UserProfile) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.username != rhs.username {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.followerStatus != rhs.followerStatus {return false}
    if lhs.followingStatus != rhs.followingStatus {return false}
    if lhs.numMutualFollowing != rhs.numMutualFollowing {return false}
    if lhs.bio != rhs.bio {return false}
    if lhs.links != rhs.links {return false}
    if lhs.relevantFollowers != rhs.relevantFollowers {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.totalPostImpressions != rhs.totalPostImpressions {return false}
    if lhs.totalPostReactions != rhs.totalPostReactions {return false}
    if lhs.totalNumPosts != rhs.totalNumPosts {return false}
    if lhs.geoTags != rhs.geoTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PostMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_impressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numImpressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numImpressions != 0 {
      try visitor.visitSingularInt32Field(value: self.numImpressions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PostMetrics, rhs: Server_PostMetrics) -> Bool {
    if lhs.numImpressions != rhs.numImpressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ProfileUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .normal {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ProfileUpdate, rhs: Server_ProfileUpdate) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ProfileUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "DELETE"),
    2: .same(proto: "FOLLOWER_NOTICE"),
    3: .same(proto: "CONTACT_NOTICE"),
  ]
}

extension Server_UserProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserProfileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UserProfileRequest, rhs: Server_UserProfileRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UserProfileResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserProfileResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "profile"),
    4: .standard(proto: "recent_posts"),
  ]

  fileprivate class _StorageClass {
    var _result: Server_UserProfileResult.Result = .ok
    var _reason: Server_UserProfileResult.Reason = .unknownReason
    var _profile: Server_UserProfile? = nil
    var _recentPosts: [Server_Post] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _result = source._result
      _reason = source._reason
      _profile = source._profile
      _recentPosts = source._recentPosts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._result) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._reason) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._profile) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._recentPosts) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._result != .ok {
        try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 1)
      }
      if _storage._reason != .unknownReason {
        try visitor.visitSingularEnumField(value: _storage._reason, fieldNumber: 2)
      }
      try { if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._recentPosts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._recentPosts, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UserProfileResult, rhs: Server_UserProfileResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._result != rhs_storage._result {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._profile != rhs_storage._profile {return false}
        if _storage._recentPosts != rhs_storage._recentPosts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UserProfileResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_UserProfileResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "NO_USER"),
  ]
}

extension Server_PostMetricsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostMetricsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "post_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.postID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PostMetricsRequest, rhs: Server_PostMetricsRequest) -> Bool {
    if lhs.postID != rhs.postID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PostMetricsResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostMetricsResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "post_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._postMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try { if let v = self._postMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PostMetricsResult, rhs: Server_PostMetricsResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._postMetrics != rhs._postMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PostMetricsResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_PostMetricsResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "NO_POST"),
  ]
}

extension Server_RelationshipRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelationshipRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .follow {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RelationshipRequest, rhs: Server_RelationshipRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RelationshipRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FOLLOW"),
    1: .same(proto: "UNFOLLOW"),
    2: .same(proto: "ACCEPT_FOLLOW"),
    3: .same(proto: "IGNORE_FOLLOW"),
    4: .same(proto: "REMOVE_FOLLOWER"),
    5: .same(proto: "BLOCK"),
    6: .same(proto: "UNBLOCK"),
  ]
}

extension Server_RelationshipResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelationshipResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RelationshipResponse, rhs: Server_RelationshipResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RelationshipResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_RelationshipList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RelationshipList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "cursor"),
    3: .same(proto: "users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .follower {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_RelationshipList, rhs: Server_RelationshipList) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_RelationshipList.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FOLLOWER"),
    1: .same(proto: "FOLLOWING"),
    2: .same(proto: "INCOMING"),
    3: .same(proto: "OUTGOING"),
    4: .same(proto: "BLOCKED"),
  ]
}

extension Server_UsernameRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsernameRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .isAvailable {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UsernameRequest, rhs: Server_UsernameRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UsernameRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IS_AVAILABLE"),
    1: .same(proto: "SET"),
  ]
}

extension Server_UsernameResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsernameResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .tooshort {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UsernameResponse, rhs: Server_UsernameResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UsernameResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_UsernameResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOOSHORT"),
    1: .same(proto: "TOOLONG"),
    2: .same(proto: "BADEXPR"),
    3: .same(proto: "NOTUNIQ"),
  ]
}

extension Server_GeoTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoTagRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "gps_location"),
    3: .standard(proto: "geo_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gpsLocation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.geoTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .get {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    try { if let v = self._gpsLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.geoTag.isEmpty {
      try visitor.visitSingularStringField(value: self.geoTag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GeoTagRequest, rhs: Server_GeoTagRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs._gpsLocation != rhs._gpsLocation {return false}
    if lhs.geoTag != rhs.geoTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GeoTagRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "FORCE_ADD"),
  ]
}

extension Server_GeoTagResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeoTagResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "geo_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.geoTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.geoTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.geoTags, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GeoTagResponse, rhs: Server_GeoTagResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.geoTags != rhs.geoTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GeoTagResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_GeoTagResponse.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVALID_REQUEST"),
  ]
}

extension Server_SearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "username_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.usernameString) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.usernameString.isEmpty {
      try visitor.visitSingularStringField(value: self.usernameString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SearchRequest, rhs: Server_SearchRequest) -> Bool {
    if lhs.usernameString != rhs.usernameString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "search_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searchResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.searchResult.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searchResult, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SearchResponse, rhs: Server_SearchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.searchResult != rhs.searchResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SearchResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_FollowSuggestionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowSuggestionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "rejected_uids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeRepeatedInt64Field(value: &self.rejectedUids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .get {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.rejectedUids.isEmpty {
      try visitor.visitPackedInt64Field(value: self.rejectedUids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FollowSuggestionsRequest, rhs: Server_FollowSuggestionsRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.rejectedUids != rhs.rejectedUids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FollowSuggestionsRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "REJECT"),
  ]
}

extension Server_SuggestedProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SuggestedProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_profile"),
    2: .same(proto: "reason"),
    3: .same(proto: "rank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userProfile) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.rank) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if self.rank != 0 {
      try visitor.visitSingularInt32Field(value: self.rank, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SuggestedProfile, rhs: Server_SuggestedProfile) -> Bool {
    if lhs._userProfile != rhs._userProfile {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.rank != rhs.rank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SuggestedProfile.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "DIRECT_CONTACT"),
    2: .same(proto: "FOF"),
    3: .same(proto: "CAMPUS"),
  ]
}

extension Server_FollowSuggestionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FollowSuggestionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "suggested_profiles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.suggestedProfiles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.suggestedProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.suggestedProfiles, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FollowSuggestionsResponse, rhs: Server_FollowSuggestionsResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.suggestedProfiles != rhs.suggestedProfiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FollowSuggestionsResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .userDefined {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Link, rhs: Server_Link) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Link.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_DEFINED"),
    1: .same(proto: "TIKTOK"),
    2: .same(proto: "SNAPCHAT"),
    3: .same(proto: "INSTAGRAM"),
    4: .same(proto: "X"),
    5: .same(proto: "YOUTUBE"),
  ]
}

extension Server_SetLinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLinkRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "link"),
    2: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._link) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._link {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.action != .set {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SetLinkRequest, rhs: Server_SetLinkRequest) -> Bool {
    if lhs._link != rhs._link {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SetLinkRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET"),
    1: .same(proto: "REMOVE"),
  ]
}

extension Server_SetLinkResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLinkResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SetLinkResult, rhs: Server_SetLinkResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SetLinkResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_SetLinkResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "BAD_TYPE"),
  ]
}

extension Server_SetBioRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetBioRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SetBioRequest, rhs: Server_SetBioRequest) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SetBioResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetBioResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SetBioResult, rhs: Server_SetBioResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SetBioResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_SetBioResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "TOO_LONG"),
  ]
}

extension Server_AiImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AiImageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "num_images"),
    3: .standard(proto: "prompt_mode"),
    4: .standard(proto: "negative_prompt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.numImages) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.promptMode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.negativePrompt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.numImages != 0 {
      try visitor.visitSingularInt64Field(value: self.numImages, fieldNumber: 2)
    }
    if self.promptMode != .unknown {
      try visitor.visitSingularEnumField(value: self.promptMode, fieldNumber: 3)
    }
    if !self.negativePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.negativePrompt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AiImageRequest, rhs: Server_AiImageRequest) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.numImages != rhs.numImages {return false}
    if lhs.promptMode != rhs.promptMode {return false}
    if lhs.negativePrompt != rhs.negativePrompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AiImageRequest.PromptMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "USER"),
    2: .same(proto: "SERVER"),
  ]
}

extension Server_AiImageResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AiImageResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "id"),
    4: .same(proto: "backoff"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.backoff) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .pending {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 3)
    }
    if self.backoff != 0 {
      try visitor.visitSingularInt64Field(value: self.backoff, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AiImageResult, rhs: Server_AiImageResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.id != rhs.id {return false}
    if lhs.backoff != rhs.backoff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AiImageResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_AiImageResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TOO_SOON"),
    2: .same(proto: "TOO_MANY_ATTEMPTS"),
  ]
}

extension Server_AiImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AiImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "image"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.image) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.image.isEmpty {
      try visitor.visitSingularBytesField(value: self.image, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AiImage, rhs: Server_AiImage) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.image != rhs.image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_TimeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_timestamp"),
    2: .standard(proto: "end_timestamp"),
    3: .standard(proto: "utc_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startTimestamp) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endTimestamp) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.utcOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestamp, fieldNumber: 1)
    }
    if self.endTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.endTimestamp, fieldNumber: 2)
    }
    if self.utcOffset != 0 {
      try visitor.visitSingularInt64Field(value: self.utcOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_TimeRange, rhs: Server_TimeRange) -> Bool {
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.endTimestamp != rhs.endTimestamp {return false}
    if lhs.utcOffset != rhs.utcOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Album: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Album"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "action"),
    3: .same(proto: "name"),
    4: .same(proto: "owner"),
    5: .standard(proto: "time_range"),
    6: .same(proto: "location"),
    7: .standard(proto: "can_view"),
    8: .standard(proto: "can_contribute"),
    9: .same(proto: "members"),
    10: .standard(proto: "media_items"),
    11: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.owner) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timeRange) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.canView) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.canContribute) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.mediaItems) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.action != .create {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.owner != 0 {
      try visitor.visitSingularInt64Field(value: self.owner, fieldNumber: 4)
    }
    try { if let v = self._timeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.canView != .inviteOnly {
      try visitor.visitSingularEnumField(value: self.canView, fieldNumber: 7)
    }
    if self.canContribute != .inviteOnly {
      try visitor.visitSingularEnumField(value: self.canContribute, fieldNumber: 8)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 9)
    }
    if !self.mediaItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mediaItems, fieldNumber: 10)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Album, rhs: Server_Album) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.action != rhs.action {return false}
    if lhs.name != rhs.name {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs._timeRange != rhs._timeRange {return false}
    if lhs._location != rhs._location {return false}
    if lhs.canView != rhs.canView {return false}
    if lhs.canContribute != rhs.canContribute {return false}
    if lhs.members != rhs.members {return false}
    if lhs.mediaItems != rhs.mediaItems {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Album.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATE"),
    1: .same(proto: "CHANGE_NAME"),
    2: .same(proto: "CHANGE_LOCATION"),
    3: .same(proto: "CHANGE_TIME"),
    4: .same(proto: "CHANGE_VIEW_ACCESS"),
    5: .same(proto: "CHANGE_CONTRIBUTE_ACCESS"),
    6: .same(proto: "MODIFY_MEMBERS"),
    7: .same(proto: "ADD_MEDIA"),
    8: .same(proto: "REMOVE_MEDIA"),
    9: .same(proto: "MEDIA_UPDATE"),
    10: .same(proto: "GET_INFO"),
    11: .same(proto: "GET_MEDIA"),
    12: .same(proto: "GET"),
    13: .same(proto: "DELETE"),
  ]
}

extension Server_AlbumResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlbumResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "album"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._album) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try { if let v = self._album {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AlbumResult, rhs: Server_AlbumResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._album != rhs._album {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AlbumResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_AlbumResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "BAD_ALBUM_ID"),
    2: .same(proto: "NOT_ALLOWED"),
    3: .same(proto: "TOO_MANY_MEMBERS"),
  ]
}

extension Server_AlbumMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlbumMember"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "action"),
    3: .same(proto: "name"),
    4: .same(proto: "username"),
    5: .standard(proto: "avatar_id"),
    6: .same(proto: "role"),
    7: .same(proto: "pending"),
    8: .standard(proto: "remove_media"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.pending) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.removeMedia) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if self.action != .none {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    if self.role != .viewer {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 6)
    }
    if self.pending != false {
      try visitor.visitSingularBoolField(value: self.pending, fieldNumber: 7)
    }
    if self.removeMedia != false {
      try visitor.visitSingularBoolField(value: self.removeMedia, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AlbumMember, rhs: Server_AlbumMember) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.action != rhs.action {return false}
    if lhs.name != rhs.name {return false}
    if lhs.username != rhs.username {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.pending != rhs.pending {return false}
    if lhs.removeMedia != rhs.removeMedia {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AlbumMember.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "ACCEPT_INVITE"),
    2: .same(proto: "REJECT_INVITE"),
    3: .same(proto: "JOIN"),
    4: .same(proto: "LEAVE"),
    5: .same(proto: "UN_INVITE"),
    6: .same(proto: "REMOVE"),
    7: .same(proto: "INVITE"),
    8: .same(proto: "PROMOTE"),
    9: .same(proto: "DEMOTE"),
  ]
}

extension Server_AlbumMember.Role: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIEWER"),
    1: .same(proto: "CONTRIBUTOR"),
    2: .same(proto: "ADMIN"),
    3: .same(proto: "OWNER"),
  ]
}

extension Server_GetAlbums: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAlbums"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "album_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.albumIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.albumIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.albumIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GetAlbums, rhs: Server_GetAlbums) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.albumIds != rhs.albumIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GetAlbums.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "MEMBER"),
    2: .same(proto: "INVITED"),
  ]
}

extension Server_MediaItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "publisher_uid"),
    3: .standard(proto: "publisher_name"),
    4: .standard(proto: "publisher_username"),
    5: .standard(proto: "album_id"),
    6: .same(proto: "payload"),
    7: .standard(proto: "device_capture_timestamp_ms"),
    8: .standard(proto: "upload_timestamp_ms"),
    9: .standard(proto: "parent_media_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.publisherUid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publisherName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.publisherUsername) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.albumID) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.deviceCaptureTimestampMs) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.uploadTimestampMs) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.parentMediaID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.publisherUid != 0 {
      try visitor.visitSingularInt64Field(value: self.publisherUid, fieldNumber: 2)
    }
    if !self.publisherName.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherName, fieldNumber: 3)
    }
    if !self.publisherUsername.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherUsername, fieldNumber: 4)
    }
    if !self.albumID.isEmpty {
      try visitor.visitSingularStringField(value: self.albumID, fieldNumber: 5)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 6)
    }
    if self.deviceCaptureTimestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.deviceCaptureTimestampMs, fieldNumber: 7)
    }
    if self.uploadTimestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.uploadTimestampMs, fieldNumber: 8)
    }
    if !self.parentMediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentMediaID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaItem, rhs: Server_MediaItem) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.publisherUid != rhs.publisherUid {return false}
    if lhs.publisherName != rhs.publisherName {return false}
    if lhs.publisherUsername != rhs.publisherUsername {return false}
    if lhs.albumID != rhs.albumID {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.deviceCaptureTimestampMs != rhs.deviceCaptureTimestampMs {return false}
    if lhs.uploadTimestampMs != rhs.uploadTimestampMs {return false}
    if lhs.parentMediaID != rhs.parentMediaID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FriendshipRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FriendshipRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .addFriend {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FriendshipRequest, rhs: Server_FriendshipRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FriendshipRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD_FRIEND"),
    1: .same(proto: "ACCEPT_FRIEND"),
    2: .same(proto: "REMOVE_FRIEND"),
    3: .same(proto: "REJECT_FRIEND"),
    4: .same(proto: "BLOCK"),
    5: .same(proto: "UNBLOCK"),
    6: .same(proto: "REJECT_SUGGESTION"),
    7: .same(proto: "WITHDRAW_FRIEND_REQUEST"),
  ]
}

extension Server_FriendshipResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FriendshipResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FriendshipResponse, rhs: Server_FriendshipResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FriendshipResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_HalloappUserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HalloappUserProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "username"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .same(proto: "status"),
    6: .same(proto: "blocked"),
    7: .same(proto: "links"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatarID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 4)
    }
    if self.status != .noneStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 6)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HalloappUserProfile, rhs: Server_HalloappUserProfile) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.username != rhs.username {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HalloappProfileUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HalloappProfileUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .normal {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HalloappProfileUpdate, rhs: Server_HalloappProfileUpdate) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HalloappProfileUpdate.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "FRIEND_NOTICE"),
    2: .same(proto: "INCOMING_FRIEND_REQUEST"),
    3: .same(proto: "DELETE_NOTICE"),
  ]
}

extension Server_HalloappSearchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HalloappSearchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "username_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.usernameString) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.usernameString.isEmpty {
      try visitor.visitSingularStringField(value: self.usernameString, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HalloappSearchRequest, rhs: Server_HalloappSearchRequest) -> Bool {
    if lhs.usernameString != rhs.usernameString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HalloappSearchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HalloappSearchResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "search_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.searchResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.searchResult.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.searchResult, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HalloappSearchResponse, rhs: Server_HalloappSearchResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.searchResult != rhs.searchResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HalloappSearchResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_HalloappProfileRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HalloappProfileRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HalloappProfileRequest, rhs: Server_HalloappProfileRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HalloappProfileResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HalloappProfileResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "profile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._profile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try { if let v = self._profile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HalloappProfileResult, rhs: Server_HalloappProfileResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._profile != rhs._profile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HalloappProfileResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_HalloappProfileResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "NO_USER"),
  ]
}

extension Server_FriendListRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FriendListRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .getFriends {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FriendListRequest, rhs: Server_FriendListRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FriendListRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET_FRIENDS"),
    1: .same(proto: "GET_INCOMING_PENDING"),
    2: .same(proto: "GET_OUTGOING_PENDING"),
    3: .same(proto: "GET_SUGGESTIONS"),
    4: .same(proto: "GET_BLOCKED"),
    5: .same(proto: "SYNC_ALL"),
  ]
}

extension Server_FriendProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FriendProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_profile"),
    2: .same(proto: "reason"),
    3: .same(proto: "rank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userProfile) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.rank) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reason != .unknownReason {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if self.rank != 0 {
      try visitor.visitSingularInt32Field(value: self.rank, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FriendProfile, rhs: Server_FriendProfile) -> Bool {
    if lhs._userProfile != rhs._userProfile {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.rank != rhs.rank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FriendProfile.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REASON"),
    1: .same(proto: "DIRECT_CONTACT"),
    2: .same(proto: "INCOMING_PENDING"),
    3: .same(proto: "FRIENDS_OF_FRIENDS"),
  ]
}

extension Server_FriendListResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FriendListResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "cursor"),
    3: .standard(proto: "friend_profiles"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.friendProfiles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    if !self.friendProfiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.friendProfiles, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FriendListResponse, rhs: Server_FriendListResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.friendProfiles != rhs.friendProfiles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FriendListResponse.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_ReverseGeocodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReverseGeocodeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ReverseGeocodeRequest, rhs: Server_ReverseGeocodeRequest) -> Bool {
    if lhs._location != rhs._location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ReverseGeocodeLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReverseGeocodeLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "location"),
    3: .same(proto: "type"),
    4: .same(proto: "address"),
    5: .same(proto: "neighborhood"),
    6: .same(proto: "postcode"),
    7: .same(proto: "district"),
    8: .same(proto: "region"),
    9: .same(proto: "country"),
    10: .same(proto: "place"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.neighborhood) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.postcode) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.district) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.place) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 4)
    }
    if !self.neighborhood.isEmpty {
      try visitor.visitSingularStringField(value: self.neighborhood, fieldNumber: 5)
    }
    if !self.postcode.isEmpty {
      try visitor.visitSingularStringField(value: self.postcode, fieldNumber: 6)
    }
    if !self.district.isEmpty {
      try visitor.visitSingularStringField(value: self.district, fieldNumber: 7)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 8)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 9)
    }
    if !self.place.isEmpty {
      try visitor.visitSingularStringField(value: self.place, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ReverseGeocodeLocation, rhs: Server_ReverseGeocodeLocation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._location != rhs._location {return false}
    if lhs.type != rhs.type {return false}
    if lhs.address != rhs.address {return false}
    if lhs.neighborhood != rhs.neighborhood {return false}
    if lhs.postcode != rhs.postcode {return false}
    if lhs.district != rhs.district {return false}
    if lhs.region != rhs.region {return false}
    if lhs.country != rhs.country {return false}
    if lhs.place != rhs.place {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ReverseGeocodeResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReverseGeocodeResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "backoff"),
    4: .same(proto: "location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.backoff) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    if self.backoff != 0 {
      try visitor.visitSingularInt64Field(value: self.backoff, fieldNumber: 3)
    }
    try { if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ReverseGeocodeResult, rhs: Server_ReverseGeocodeResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.backoff != rhs.backoff {return false}
    if lhs._location != rhs._location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ReverseGeocodeResult.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_ReverseGeocodeResult.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "TOO_SOON"),
    2: .same(proto: "INVALID_LAT_LONG"),
  ]
}
