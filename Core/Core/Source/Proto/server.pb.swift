// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Server_UploadAvatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Avatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Avatars {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var avatars: [Server_Avatar] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UploadGroupAvatar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var data: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_CertMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var serverKey: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ClientMode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Server_ClientMode.Mode = .active

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Mode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case active // = 0
    case passive // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .active
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .active
      case 1: self = .passive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .active: return 0
      case .passive: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ClientMode.Mode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ClientMode.Mode] = [
    .active,
    .passive,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ClientVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var version: String = String()

  public var expiresInSeconds: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ClientLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var counts: [Server_Count] = []

  public var events: [Server_Event] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Count {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var namespace: String = String()

  public var metric: String = String()

  public var count: Int64 = 0

  public var dims: [Server_Dim] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var namespace: String = String()

  public var event: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Dim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_Contact.Action = .add

  public var raw: String = String()

  public var normalized: String = String()

  public var uid: Int64 = 0

  public var avatarID: String = String()

  public var role: Server_Contact.Role = .friends

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Role: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case friends // = 0
    case none // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .friends
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .friends
      case 1: self = .none
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .friends: return 0
      case .none: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Contact.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Contact.Action] = [
    .add,
    .delete,
  ]
}

extension Server_Contact.Role: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Contact.Role] = [
    .friends,
    .none,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ContactList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ContactList.TypeEnum = .full

  public var syncID: String = String()

  public var batchIndex: Int32 = 0

  public var isLast: Bool = false

  public var contacts: [Server_Contact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case full // = 0
    case delta // = 1
    case normal // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .full
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .full
      case 1: self = .delta
      case 2: self = .normal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .full: return 0
      case .delta: return 1
      case .normal: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ContactList.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ContactList.TypeEnum] = [
    .full,
    .delta,
    .normal,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ContactHash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Audience {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_Audience.TypeEnum = .all

  public var uids: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case except // = 1
    case only // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .except
      case 2: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .except: return 1
      case .only: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Audience.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Audience.TypeEnum] = [
    .all,
    .except,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Post {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var publisherUid: Int64 = 0

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var audience: Server_Audience {
    get {return _audience ?? Server_Audience()}
    set {_audience = newValue}
  }
  /// Returns true if `audience` has been explicitly set.
  public var hasAudience: Bool {return self._audience != nil}
  /// Clears the value of `audience`. Subsequent reads from it will return its default value.
  public mutating func clearAudience() {self._audience = nil}

  public var timestamp: Int64 = 0

  public var publisherName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _audience: Server_Audience? = nil
}

public struct Server_Comment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var postID: String = String()

  public var parentCommentID: String = String()

  public var publisherUid: Int64 = 0

  public var publisherName: String = String()

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ShareStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var postIds: [String] = []

  public var result: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_FeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_FeedItem.Action = .publish

  public var item: Server_FeedItem.OneOf_Item? = nil

  public var post: Server_Post {
    get {
      if case .post(let v)? = item {return v}
      return Server_Post()
    }
    set {item = .post(newValue)}
  }

  public var comment: Server_Comment {
    get {
      if case .comment(let v)? = item {return v}
      return Server_Comment()
    }
    set {item = .comment(newValue)}
  }

  public var shareStanzas: [Server_ShareStanza] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Item: Equatable {
    case post(Server_Post)
    case comment(Server_Comment)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_FeedItem.OneOf_Item, rhs: Server_FeedItem.OneOf_Item) -> Bool {
      switch (lhs, rhs) {
      case (.post(let l), .post(let r)): return l == r
      case (.comment(let l), .comment(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case publish // = 0
    case retract // = 1
    case share // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .publish
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .publish
      case 1: self = .retract
      case 2: self = .share
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .publish: return 0
      case .retract: return 1
      case .share: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FeedItem.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FeedItem.Action] = [
    .publish,
    .retract,
    .share,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FeedItems {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var items: [Server_FeedItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupFeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupFeedItem.Action = .publish

  public var gid: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var item: Server_GroupFeedItem.OneOf_Item? = nil

  public var post: Server_Post {
    get {
      if case .post(let v)? = item {return v}
      return Server_Post()
    }
    set {item = .post(newValue)}
  }

  public var comment: Server_Comment {
    get {
      if case .comment(let v)? = item {return v}
      return Server_Comment()
    }
    set {item = .comment(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Item: Equatable {
    case post(Server_Post)
    case comment(Server_Comment)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_GroupFeedItem.OneOf_Item, rhs: Server_GroupFeedItem.OneOf_Item) -> Bool {
      switch (lhs, rhs) {
      case (.post(let l), .post(let r)): return l == r
      case (.comment(let l), .comment(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case publish // = 0
    case retract // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .publish
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .publish
      case 1: self = .retract
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .publish: return 0
      case .retract: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupFeedItem.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupFeedItem.Action] = [
    .publish,
    .retract,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupMember.Action = .add

  public var uid: Int64 = 0

  public var type: Server_GroupMember.TypeEnum = .member

  public var name: String = String()

  public var avatarID: String = String()

  public var result: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case remove // = 1
    case promote // = 2
    case demote // = 3
    case leave // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .remove
      case 2: self = .promote
      case 3: self = .demote
      case 4: self = .leave
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .remove: return 1
      case .promote: return 2
      case .demote: return 3
      case .leave: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case member // = 0
    case admin // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .member
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .member
      case 1: self = .admin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .member: return 0
      case .admin: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupMember.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupMember.Action] = [
    .add,
    .remove,
    .promote,
    .demote,
    .leave,
  ]
}

extension Server_GroupMember.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupMember.TypeEnum] = [
    .member,
    .admin,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupStanza.Action = .set

  public var gid: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var senderUid: Int64 = 0

  public var senderName: String = String()

  public var members: [Server_GroupMember] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case set // = 0
    case get // = 1
    case create // = 2
    case delete // = 3
    case leave // = 4
    case changeAvatar // = 5
    case changeName // = 6
    case modifyAdmins // = 7
    case modifyMembers // = 8
    case autoPromoteAdmins // = 9
    case setName // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .set
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .set
      case 1: self = .get
      case 2: self = .create
      case 3: self = .delete
      case 4: self = .leave
      case 5: self = .changeAvatar
      case 6: self = .changeName
      case 7: self = .modifyAdmins
      case 8: self = .modifyMembers
      case 9: self = .autoPromoteAdmins
      case 10: self = .setName
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .set: return 0
      case .get: return 1
      case .create: return 2
      case .delete: return 3
      case .leave: return 4
      case .changeAvatar: return 5
      case .changeName: return 6
      case .modifyAdmins: return 7
      case .modifyMembers: return 8
      case .autoPromoteAdmins: return 9
      case .setName: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupStanza.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupStanza.Action] = [
    .set,
    .get,
    .create,
    .delete,
    .leave,
    .changeAvatar,
    .changeName,
    .modifyAdmins,
    .modifyMembers,
    .autoPromoteAdmins,
    .setName,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupChat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var gid: String = String()

  public var name: String = String()

  public var avatarID: String = String()

  public var senderUid: Int64 = 0

  public var senderName: String = String()

  public var timestamp: Int64 = 0

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupsStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_GroupsStanza.Action = .get

  public var groupStanzas: [Server_GroupStanza] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupsStanza.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupsStanza.Action] = [
    .get,
  ]
}

#endif  // swift(>=4.2)

public struct Server_AuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var pwd: String = String()

  public var clientMode: Server_ClientMode {
    get {return _clientMode ?? Server_ClientMode()}
    set {_clientMode = newValue}
  }
  /// Returns true if `clientMode` has been explicitly set.
  public var hasClientMode: Bool {return self._clientMode != nil}
  /// Clears the value of `clientMode`. Subsequent reads from it will return its default value.
  public mutating func clearClientMode() {self._clientMode = nil}

  public var clientVersion: Server_ClientVersion {
    get {return _clientVersion ?? Server_ClientVersion()}
    set {_clientVersion = newValue}
  }
  /// Returns true if `clientVersion` has been explicitly set.
  public var hasClientVersion: Bool {return self._clientVersion != nil}
  /// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
  public mutating func clearClientVersion() {self._clientVersion = nil}

  public var resource: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientMode: Server_ClientMode? = nil
  fileprivate var _clientVersion: Server_ClientVersion? = nil
}

/// Left them to be string for now, will update these later as necessary.
public struct Server_AuthResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: String = String()

  public var reason: String = String()

  public var propsHash: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Invite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var phone: String = String()

  public var result: String = String()

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_InvitesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invites: [Server_Invite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_InvitesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invitesLeft: Int32 = 0

  public var timeUntilRefresh: Int64 = 0

  public var invites: [Server_Invite] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_MediaUrl {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var get: String = String()

  public var put: String = String()

  public var patch: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_UploadMedia {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var size: Int64 = 0

  public var url: Server_MediaUrl {
    get {return _url ?? Server_MediaUrl()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _url: Server_MediaUrl? = nil
}

public struct Server_ChatStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var encPayload: Data = SwiftProtobuf.Internal.emptyData

  /// Temporarily added two payloads: one is for unencrypted and the other is encrypted.
  /// Clients currently send both of them at times.
  public var publicKey: Data = SwiftProtobuf.Internal.emptyData

  public var oneTimePreKeyID: Int64 = 0

  public var senderName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// clients should decrypt, report stats, and then drop this message
public struct Server_SilentChatStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chatStanza: Server_ChatStanza {
    get {return _chatStanza ?? Server_ChatStanza()}
    set {_chatStanza = newValue}
  }
  /// Returns true if `chatStanza` has been explicitly set.
  public var hasChatStanza: Bool {return self._chatStanza != nil}
  /// Clears the value of `chatStanza`. Subsequent reads from it will return its default value.
  public mutating func clearChatStanza() {self._chatStanza = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _chatStanza: Server_ChatStanza? = nil
}

public struct Server_Ping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ErrorStanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Name {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Iq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: Server_Iq.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var uploadMedia: Server_UploadMedia {
    get {
      if case .uploadMedia(let v)? = _storage._payload {return v}
      return Server_UploadMedia()
    }
    set {_uniqueStorage()._payload = .uploadMedia(newValue)}
  }

  public var contactList: Server_ContactList {
    get {
      if case .contactList(let v)? = _storage._payload {return v}
      return Server_ContactList()
    }
    set {_uniqueStorage()._payload = .contactList(newValue)}
  }

  public var uploadAvatar: Server_UploadAvatar {
    get {
      if case .uploadAvatar(let v)? = _storage._payload {return v}
      return Server_UploadAvatar()
    }
    set {_uniqueStorage()._payload = .uploadAvatar(newValue)}
  }

  public var avatar: Server_Avatar {
    get {
      if case .avatar(let v)? = _storage._payload {return v}
      return Server_Avatar()
    }
    set {_uniqueStorage()._payload = .avatar(newValue)}
  }

  public var avatars: Server_Avatars {
    get {
      if case .avatars(let v)? = _storage._payload {return v}
      return Server_Avatars()
    }
    set {_uniqueStorage()._payload = .avatars(newValue)}
  }

  public var clientMode: Server_ClientMode {
    get {
      if case .clientMode(let v)? = _storage._payload {return v}
      return Server_ClientMode()
    }
    set {_uniqueStorage()._payload = .clientMode(newValue)}
  }

  public var clientVersion: Server_ClientVersion {
    get {
      if case .clientVersion(let v)? = _storage._payload {return v}
      return Server_ClientVersion()
    }
    set {_uniqueStorage()._payload = .clientVersion(newValue)}
  }

  public var pushRegister: Server_PushRegister {
    get {
      if case .pushRegister(let v)? = _storage._payload {return v}
      return Server_PushRegister()
    }
    set {_uniqueStorage()._payload = .pushRegister(newValue)}
  }

  public var whisperKeys: Server_WhisperKeys {
    get {
      if case .whisperKeys(let v)? = _storage._payload {return v}
      return Server_WhisperKeys()
    }
    set {_uniqueStorage()._payload = .whisperKeys(newValue)}
  }

  public var ping: Server_Ping {
    get {
      if case .ping(let v)? = _storage._payload {return v}
      return Server_Ping()
    }
    set {_uniqueStorage()._payload = .ping(newValue)}
  }

  public var feedItem: Server_FeedItem {
    get {
      if case .feedItem(let v)? = _storage._payload {return v}
      return Server_FeedItem()
    }
    set {_uniqueStorage()._payload = .feedItem(newValue)}
  }

  public var privacyList: Server_PrivacyList {
    get {
      if case .privacyList(let v)? = _storage._payload {return v}
      return Server_PrivacyList()
    }
    set {_uniqueStorage()._payload = .privacyList(newValue)}
  }

  public var privacyListResult: Server_PrivacyListResult {
    get {
      if case .privacyListResult(let v)? = _storage._payload {return v}
      return Server_PrivacyListResult()
    }
    set {_uniqueStorage()._payload = .privacyListResult(newValue)}
  }

  public var privacyLists: Server_PrivacyLists {
    get {
      if case .privacyLists(let v)? = _storage._payload {return v}
      return Server_PrivacyLists()
    }
    set {_uniqueStorage()._payload = .privacyLists(newValue)}
  }

  public var groupStanza: Server_GroupStanza {
    get {
      if case .groupStanza(let v)? = _storage._payload {return v}
      return Server_GroupStanza()
    }
    set {_uniqueStorage()._payload = .groupStanza(newValue)}
  }

  public var groupsStanza: Server_GroupsStanza {
    get {
      if case .groupsStanza(let v)? = _storage._payload {return v}
      return Server_GroupsStanza()
    }
    set {_uniqueStorage()._payload = .groupsStanza(newValue)}
  }

  public var clientLog: Server_ClientLog {
    get {
      if case .clientLog(let v)? = _storage._payload {return v}
      return Server_ClientLog()
    }
    set {_uniqueStorage()._payload = .clientLog(newValue)}
  }

  public var name: Server_Name {
    get {
      if case .name(let v)? = _storage._payload {return v}
      return Server_Name()
    }
    set {_uniqueStorage()._payload = .name(newValue)}
  }

  public var errorStanza: Server_ErrorStanza {
    get {
      if case .errorStanza(let v)? = _storage._payload {return v}
      return Server_ErrorStanza()
    }
    set {_uniqueStorage()._payload = .errorStanza(newValue)}
  }

  public var props: Server_Props {
    get {
      if case .props(let v)? = _storage._payload {return v}
      return Server_Props()
    }
    set {_uniqueStorage()._payload = .props(newValue)}
  }

  public var invitesRequest: Server_InvitesRequest {
    get {
      if case .invitesRequest(let v)? = _storage._payload {return v}
      return Server_InvitesRequest()
    }
    set {_uniqueStorage()._payload = .invitesRequest(newValue)}
  }

  public var invitesResponse: Server_InvitesResponse {
    get {
      if case .invitesResponse(let v)? = _storage._payload {return v}
      return Server_InvitesResponse()
    }
    set {_uniqueStorage()._payload = .invitesResponse(newValue)}
  }

  public var notificationPrefs: Server_NotificationPrefs {
    get {
      if case .notificationPrefs(let v)? = _storage._payload {return v}
      return Server_NotificationPrefs()
    }
    set {_uniqueStorage()._payload = .notificationPrefs(newValue)}
  }

  public var groupFeedItem: Server_GroupFeedItem {
    get {
      if case .groupFeedItem(let v)? = _storage._payload {return v}
      return Server_GroupFeedItem()
    }
    set {_uniqueStorage()._payload = .groupFeedItem(newValue)}
  }

  public var groupAvatar: Server_UploadGroupAvatar {
    get {
      if case .groupAvatar(let v)? = _storage._payload {return v}
      return Server_UploadGroupAvatar()
    }
    set {_uniqueStorage()._payload = .groupAvatar(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case uploadMedia(Server_UploadMedia)
    case contactList(Server_ContactList)
    case uploadAvatar(Server_UploadAvatar)
    case avatar(Server_Avatar)
    case avatars(Server_Avatars)
    case clientMode(Server_ClientMode)
    case clientVersion(Server_ClientVersion)
    case pushRegister(Server_PushRegister)
    case whisperKeys(Server_WhisperKeys)
    case ping(Server_Ping)
    case feedItem(Server_FeedItem)
    case privacyList(Server_PrivacyList)
    case privacyListResult(Server_PrivacyListResult)
    case privacyLists(Server_PrivacyLists)
    case groupStanza(Server_GroupStanza)
    case groupsStanza(Server_GroupsStanza)
    case clientLog(Server_ClientLog)
    case name(Server_Name)
    case errorStanza(Server_ErrorStanza)
    case props(Server_Props)
    case invitesRequest(Server_InvitesRequest)
    case invitesResponse(Server_InvitesResponse)
    case notificationPrefs(Server_NotificationPrefs)
    case groupFeedItem(Server_GroupFeedItem)
    case groupAvatar(Server_UploadGroupAvatar)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Iq.OneOf_Payload, rhs: Server_Iq.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.uploadMedia(let l), .uploadMedia(let r)): return l == r
      case (.contactList(let l), .contactList(let r)): return l == r
      case (.uploadAvatar(let l), .uploadAvatar(let r)): return l == r
      case (.avatar(let l), .avatar(let r)): return l == r
      case (.avatars(let l), .avatars(let r)): return l == r
      case (.clientMode(let l), .clientMode(let r)): return l == r
      case (.clientVersion(let l), .clientVersion(let r)): return l == r
      case (.pushRegister(let l), .pushRegister(let r)): return l == r
      case (.whisperKeys(let l), .whisperKeys(let r)): return l == r
      case (.ping(let l), .ping(let r)): return l == r
      case (.feedItem(let l), .feedItem(let r)): return l == r
      case (.privacyList(let l), .privacyList(let r)): return l == r
      case (.privacyListResult(let l), .privacyListResult(let r)): return l == r
      case (.privacyLists(let l), .privacyLists(let r)): return l == r
      case (.groupStanza(let l), .groupStanza(let r)): return l == r
      case (.groupsStanza(let l), .groupsStanza(let r)): return l == r
      case (.clientLog(let l), .clientLog(let r)): return l == r
      case (.name(let l), .name(let r)): return l == r
      case (.errorStanza(let l), .errorStanza(let r)): return l == r
      case (.props(let l), .props(let r)): return l == r
      case (.invitesRequest(let l), .invitesRequest(let r)): return l == r
      case (.invitesResponse(let l), .invitesResponse(let r)): return l == r
      case (.notificationPrefs(let l), .notificationPrefs(let r)): return l == r
      case (.groupFeedItem(let l), .groupFeedItem(let r)): return l == r
      case (.groupAvatar(let l), .groupAvatar(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case set // = 1
    case result // = 2
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .set
      case 2: self = .result
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .set: return 1
      case .result: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_Iq.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Iq.TypeEnum] = [
    .get,
    .set,
    .result,
    .error,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Msg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: Server_Msg.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var toUid: Int64 {
    get {return _storage._toUid}
    set {_uniqueStorage()._toUid = newValue}
  }

  public var fromUid: Int64 {
    get {return _storage._fromUid}
    set {_uniqueStorage()._fromUid = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var contactList: Server_ContactList {
    get {
      if case .contactList(let v)? = _storage._payload {return v}
      return Server_ContactList()
    }
    set {_uniqueStorage()._payload = .contactList(newValue)}
  }

  public var avatar: Server_Avatar {
    get {
      if case .avatar(let v)? = _storage._payload {return v}
      return Server_Avatar()
    }
    set {_uniqueStorage()._payload = .avatar(newValue)}
  }

  public var whisperKeys: Server_WhisperKeys {
    get {
      if case .whisperKeys(let v)? = _storage._payload {return v}
      return Server_WhisperKeys()
    }
    set {_uniqueStorage()._payload = .whisperKeys(newValue)}
  }

  public var seenReceipt: Server_SeenReceipt {
    get {
      if case .seenReceipt(let v)? = _storage._payload {return v}
      return Server_SeenReceipt()
    }
    set {_uniqueStorage()._payload = .seenReceipt(newValue)}
  }

  public var deliveryReceipt: Server_DeliveryReceipt {
    get {
      if case .deliveryReceipt(let v)? = _storage._payload {return v}
      return Server_DeliveryReceipt()
    }
    set {_uniqueStorage()._payload = .deliveryReceipt(newValue)}
  }

  public var chatStanza: Server_ChatStanza {
    get {
      if case .chatStanza(let v)? = _storage._payload {return v}
      return Server_ChatStanza()
    }
    set {_uniqueStorage()._payload = .chatStanza(newValue)}
  }

  public var feedItem: Server_FeedItem {
    get {
      if case .feedItem(let v)? = _storage._payload {return v}
      return Server_FeedItem()
    }
    set {_uniqueStorage()._payload = .feedItem(newValue)}
  }

  public var feedItems: Server_FeedItems {
    get {
      if case .feedItems(let v)? = _storage._payload {return v}
      return Server_FeedItems()
    }
    set {_uniqueStorage()._payload = .feedItems(newValue)}
  }

  public var contactHash: Server_ContactHash {
    get {
      if case .contactHash(let v)? = _storage._payload {return v}
      return Server_ContactHash()
    }
    set {_uniqueStorage()._payload = .contactHash(newValue)}
  }

  public var groupStanza: Server_GroupStanza {
    get {
      if case .groupStanza(let v)? = _storage._payload {return v}
      return Server_GroupStanza()
    }
    set {_uniqueStorage()._payload = .groupStanza(newValue)}
  }

  public var groupChat: Server_GroupChat {
    get {
      if case .groupChat(let v)? = _storage._payload {return v}
      return Server_GroupChat()
    }
    set {_uniqueStorage()._payload = .groupChat(newValue)}
  }

  public var name: Server_Name {
    get {
      if case .name(let v)? = _storage._payload {return v}
      return Server_Name()
    }
    set {_uniqueStorage()._payload = .name(newValue)}
  }

  public var errorStanza: Server_ErrorStanza {
    get {
      if case .errorStanza(let v)? = _storage._payload {return v}
      return Server_ErrorStanza()
    }
    set {_uniqueStorage()._payload = .errorStanza(newValue)}
  }

  public var groupchatRetract: Server_GroupChatRetract {
    get {
      if case .groupchatRetract(let v)? = _storage._payload {return v}
      return Server_GroupChatRetract()
    }
    set {_uniqueStorage()._payload = .groupchatRetract(newValue)}
  }

  public var chatRetract: Server_ChatRetract {
    get {
      if case .chatRetract(let v)? = _storage._payload {return v}
      return Server_ChatRetract()
    }
    set {_uniqueStorage()._payload = .chatRetract(newValue)}
  }

  public var groupFeedItem: Server_GroupFeedItem {
    get {
      if case .groupFeedItem(let v)? = _storage._payload {return v}
      return Server_GroupFeedItem()
    }
    set {_uniqueStorage()._payload = .groupFeedItem(newValue)}
  }

  public var rerequest: Server_Rerequest {
    get {
      if case .rerequest(let v)? = _storage._payload {return v}
      return Server_Rerequest()
    }
    set {_uniqueStorage()._payload = .rerequest(newValue)}
  }

  public var silentChatStanza: Server_SilentChatStanza {
    get {
      if case .silentChatStanza(let v)? = _storage._payload {return v}
      return Server_SilentChatStanza()
    }
    set {_uniqueStorage()._payload = .silentChatStanza(newValue)}
  }

  public var retryCount: Int32 {
    get {return _storage._retryCount}
    set {_uniqueStorage()._retryCount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case contactList(Server_ContactList)
    case avatar(Server_Avatar)
    case whisperKeys(Server_WhisperKeys)
    case seenReceipt(Server_SeenReceipt)
    case deliveryReceipt(Server_DeliveryReceipt)
    case chatStanza(Server_ChatStanza)
    case feedItem(Server_FeedItem)
    case feedItems(Server_FeedItems)
    case contactHash(Server_ContactHash)
    case groupStanza(Server_GroupStanza)
    case groupChat(Server_GroupChat)
    case name(Server_Name)
    case errorStanza(Server_ErrorStanza)
    case groupchatRetract(Server_GroupChatRetract)
    case chatRetract(Server_ChatRetract)
    case groupFeedItem(Server_GroupFeedItem)
    case rerequest(Server_Rerequest)
    case silentChatStanza(Server_SilentChatStanza)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Msg.OneOf_Payload, rhs: Server_Msg.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.contactList(let l), .contactList(let r)): return l == r
      case (.avatar(let l), .avatar(let r)): return l == r
      case (.whisperKeys(let l), .whisperKeys(let r)): return l == r
      case (.seenReceipt(let l), .seenReceipt(let r)): return l == r
      case (.deliveryReceipt(let l), .deliveryReceipt(let r)): return l == r
      case (.chatStanza(let l), .chatStanza(let r)): return l == r
      case (.feedItem(let l), .feedItem(let r)): return l == r
      case (.feedItems(let l), .feedItems(let r)): return l == r
      case (.contactHash(let l), .contactHash(let r)): return l == r
      case (.groupStanza(let l), .groupStanza(let r)): return l == r
      case (.groupChat(let l), .groupChat(let r)): return l == r
      case (.name(let l), .name(let r)): return l == r
      case (.errorStanza(let l), .errorStanza(let r)): return l == r
      case (.groupchatRetract(let l), .groupchatRetract(let r)): return l == r
      case (.chatRetract(let l), .chatRetract(let r)): return l == r
      case (.groupFeedItem(let l), .groupFeedItem(let r)): return l == r
      case (.rerequest(let l), .rerequest(let r)): return l == r
      case (.silentChatStanza(let l), .silentChatStanza(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case error // = 1
    case groupchat // = 2
    case headline // = 3

    /// Not used yet.
    case chat // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .error
      case 2: self = .groupchat
      case 3: self = .headline
      case 4: self = .chat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .error: return 1
      case .groupchat: return 2
      case .headline: return 3
      case .chat: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Server_Msg.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Msg.TypeEnum] = [
    .normal,
    .error,
    .groupchat,
    .headline,
    .chat,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Presence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: Server_Presence.TypeEnum = .available

  public var uid: Int64 = 0

  public var lastSeen: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case away // = 1
    case subscribe // = 2
    case unsubscribe // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .away
      case 2: self = .subscribe
      case 3: self = .unsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .away: return 1
      case .subscribe: return 2
      case .unsubscribe: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Presence.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Presence.TypeEnum] = [
    .available,
    .away,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct Server_ChatState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_ChatState.TypeEnum = .available

  public var threadID: String = String()

  public var threadType: Server_ChatState.ThreadType = .chat

  public var fromUid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case typing // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .typing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .typing: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ThreadType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case groupChat // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .groupChat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .groupChat: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_ChatState.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ChatState.TypeEnum] = [
    .available,
    .typing,
  ]
}

extension Server_ChatState.ThreadType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_ChatState.ThreadType] = [
    .chat,
    .groupChat,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Ack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_HaError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Packet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stanza: Server_Packet.OneOf_Stanza? = nil

  public var msg: Server_Msg {
    get {
      if case .msg(let v)? = stanza {return v}
      return Server_Msg()
    }
    set {stanza = .msg(newValue)}
  }

  public var iq: Server_Iq {
    get {
      if case .iq(let v)? = stanza {return v}
      return Server_Iq()
    }
    set {stanza = .iq(newValue)}
  }

  public var ack: Server_Ack {
    get {
      if case .ack(let v)? = stanza {return v}
      return Server_Ack()
    }
    set {stanza = .ack(newValue)}
  }

  public var presence: Server_Presence {
    get {
      if case .presence(let v)? = stanza {return v}
      return Server_Presence()
    }
    set {stanza = .presence(newValue)}
  }

  public var haError: Server_HaError {
    get {
      if case .haError(let v)? = stanza {return v}
      return Server_HaError()
    }
    set {stanza = .haError(newValue)}
  }

  public var chatState: Server_ChatState {
    get {
      if case .chatState(let v)? = stanza {return v}
      return Server_ChatState()
    }
    set {stanza = .chatState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Stanza: Equatable {
    case msg(Server_Msg)
    case iq(Server_Iq)
    case ack(Server_Ack)
    case presence(Server_Presence)
    case haError(Server_HaError)
    case chatState(Server_ChatState)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_Packet.OneOf_Stanza, rhs: Server_Packet.OneOf_Stanza) -> Bool {
      switch (lhs, rhs) {
      case (.msg(let l), .msg(let r)): return l == r
      case (.iq(let l), .iq(let r)): return l == r
      case (.ack(let l), .ack(let r)): return l == r
      case (.presence(let l), .presence(let r)): return l == r
      case (.haError(let l), .haError(let r)): return l == r
      case (.chatState(let l), .chatState(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_UidElement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Server_UidElement.Action = .add

  public var uid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case add // = 0
    case delete // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .add
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .add
      case 1: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .add: return 0
      case .delete: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_UidElement.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_UidElement.Action] = [
    .add,
    .delete,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PrivacyList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_PrivacyList.TypeEnum = .all

  public var uidElements: [Server_UidElement] = []

  public var hash: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case block // = 1
    case except // = 2
    case mute // = 3
    case only // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .block
      case 2: self = .except
      case 3: self = .mute
      case 4: self = .only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .block: return 1
      case .except: return 2
      case .mute: return 3
      case .only: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PrivacyList.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PrivacyList.TypeEnum] = [
    .all,
    .block,
    .except,
    .mute,
    .only,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PrivacyListResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: String = String()

  public var reason: String = String()

  public var hash: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PrivacyLists {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var activeType: Server_PrivacyLists.TypeEnum = .all

  public var lists: [Server_PrivacyList] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case all // = 0
    case block // = 1
    case except // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .all
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .all
      case 1: self = .block
      case 2: self = .except
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .all: return 0
      case .block: return 1
      case .except: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PrivacyLists.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PrivacyLists.TypeEnum] = [
    .all,
    .block,
    .except,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PushToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var os: Server_PushToken.Os = .android

  public var token: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Os: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case android // = 0
    case ios // = 1
    case iosDev // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .android
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .android
      case 1: self = .ios
      case 2: self = .iosDev
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .android: return 0
      case .ios: return 1
      case .iosDev: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PushToken.Os: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PushToken.Os] = [
    .android,
    .ios,
    .iosDev,
  ]
}

#endif  // swift(>=4.2)

public struct Server_PushRegister {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pushToken: Server_PushToken {
    get {return _pushToken ?? Server_PushToken()}
    set {_pushToken = newValue}
  }
  /// Returns true if `pushToken` has been explicitly set.
  public var hasPushToken: Bool {return self._pushToken != nil}
  /// Clears the value of `pushToken`. Subsequent reads from it will return its default value.
  public mutating func clearPushToken() {self._pushToken = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pushToken: Server_PushToken? = nil
}

public struct Server_PushPref {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Server_PushPref.Name = .post

  public var value: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Name: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case post // = 0
    case comment // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .comment: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_PushPref.Name: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_PushPref.Name] = [
    .post,
    .comment,
  ]
}

#endif  // swift(>=4.2)

public struct Server_NotificationPrefs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pushPrefs: [Server_PushPref] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Rerequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var identityKey: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_SeenReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DeliveryReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var threadID: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_GroupChatRetract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var gid: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_ChatRetract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Prop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_Props {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var hash: Data = SwiftProtobuf.Internal.emptyData

  public var props: [Server_Prop] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_WhisperKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var action: Server_WhisperKeys.Action = .normal

  public var identityKey: Data = SwiftProtobuf.Internal.emptyData

  public var signedKey: Data = SwiftProtobuf.Internal.emptyData

  public var otpKeyCount: Int32 = 0

  public var oneTimeKeys: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case add // = 1
    case count // = 2
    case get // = 3
    case set // = 4
    case update // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .add
      case 2: self = .count
      case 3: self = .get
      case 4: self = .set
      case 5: self = .update
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .add: return 1
      case .count: return 2
      case .get: return 3
      case .set: return 4
      case .update: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_WhisperKeys.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_WhisperKeys.Action] = [
    .normal,
    .add,
    .count,
    .get,
    .set,
    .update,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_UploadAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadAvatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadAvatar, rhs: Server_UploadAvatar) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Avatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.uid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Avatar, rhs: Server_Avatar) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Avatars: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Avatars"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatars"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.avatars)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.avatars.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.avatars, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Avatars, rhs: Server_Avatars) -> Bool {
    if lhs.avatars != rhs.avatars {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadGroupAvatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadGroupAvatar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.gid)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadGroupAvatar, rhs: Server_UploadGroupAvatar) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_CertMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "server_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.serverKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.serverKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.serverKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_CertMessage, rhs: Server_CertMessage) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.serverKey != rhs.serverKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientMode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientMode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.mode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .active {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientMode, rhs: Server_ClientMode) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientMode.Mode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "PASSIVE"),
  ]
}

extension Server_ClientVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "expires_in_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.version)
      case 2: try decoder.decodeSingularInt64Field(value: &self.expiresInSeconds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.expiresInSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.expiresInSeconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientVersion, rhs: Server_ClientVersion) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.expiresInSeconds != rhs.expiresInSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ClientLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counts"),
    2: .same(proto: "events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.counts)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.events)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.counts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.counts, fieldNumber: 1)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ClientLog, rhs: Server_ClientLog) -> Bool {
    if lhs.counts != rhs.counts {return false}
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Count"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .same(proto: "metric"),
    3: .same(proto: "count"),
    4: .same(proto: "dims"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.namespace)
      case 2: try decoder.decodeSingularStringField(value: &self.metric)
      case 3: try decoder.decodeSingularInt64Field(value: &self.count)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.dims)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.metric.isEmpty {
      try visitor.visitSingularStringField(value: self.metric, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    if !self.dims.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dims, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Count, rhs: Server_Count) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.metric != rhs.metric {return false}
    if lhs.count != rhs.count {return false}
    if lhs.dims != rhs.dims {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "namespace"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.namespace)
      case 2: try decoder.decodeSingularBytesField(value: &self.event)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.event.isEmpty {
      try visitor.visitSingularBytesField(value: self.event, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Event, rhs: Server_Event) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Dim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dim"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Dim, rhs: Server_Dim) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "raw"),
    3: .same(proto: "normalized"),
    4: .same(proto: "uid"),
    5: .standard(proto: "avatar_id"),
    6: .same(proto: "role"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2: try decoder.decodeSingularStringField(value: &self.raw)
      case 3: try decoder.decodeSingularStringField(value: &self.normalized)
      case 4: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 5: try decoder.decodeSingularStringField(value: &self.avatarID)
      case 6: try decoder.decodeSingularEnumField(value: &self.role)
      case 7: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.raw.isEmpty {
      try visitor.visitSingularStringField(value: self.raw, fieldNumber: 2)
    }
    if !self.normalized.isEmpty {
      try visitor.visitSingularStringField(value: self.normalized, fieldNumber: 3)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    if self.role != .friends {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Contact, rhs: Server_Contact) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.raw != rhs.raw {return false}
    if lhs.normalized != rhs.normalized {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.role != rhs.role {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Contact.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_Contact.Role: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FRIENDS"),
    1: .same(proto: "NONE"),
  ]
}

extension Server_ContactList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "sync_id"),
    3: .standard(proto: "batch_index"),
    4: .standard(proto: "is_last"),
    5: .same(proto: "contacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.syncID)
      case 3: try decoder.decodeSingularInt32Field(value: &self.batchIndex)
      case 4: try decoder.decodeSingularBoolField(value: &self.isLast)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.contacts)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .full {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.syncID.isEmpty {
      try visitor.visitSingularStringField(value: self.syncID, fieldNumber: 2)
    }
    if self.batchIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.batchIndex, fieldNumber: 3)
    }
    if self.isLast != false {
      try visitor.visitSingularBoolField(value: self.isLast, fieldNumber: 4)
    }
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactList, rhs: Server_ContactList) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.syncID != rhs.syncID {return false}
    if lhs.batchIndex != rhs.batchIndex {return false}
    if lhs.isLast != rhs.isLast {return false}
    if lhs.contacts != rhs.contacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ContactList.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FULL"),
    1: .same(proto: "DELTA"),
    2: .same(proto: "NORMAL"),
  ]
}

extension Server_ContactHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ContactHash, rhs: Server_ContactHash) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Audience: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Audience"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "uids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeRepeatedInt64Field(value: &self.uids)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.uids.isEmpty {
      try visitor.visitPackedInt64Field(value: self.uids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Audience, rhs: Server_Audience) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.uids != rhs.uids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Audience.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "EXCEPT"),
    2: .same(proto: "ONLY"),
  ]
}

extension Server_Post: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Post"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "publisher_uid"),
    3: .same(proto: "payload"),
    4: .same(proto: "audience"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "publisher_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.publisherUid)
      case 3: try decoder.decodeSingularBytesField(value: &self.payload)
      case 4: try decoder.decodeSingularMessageField(value: &self._audience)
      case 5: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 6: try decoder.decodeSingularStringField(value: &self.publisherName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.publisherUid != 0 {
      try visitor.visitSingularInt64Field(value: self.publisherUid, fieldNumber: 2)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 3)
    }
    if let v = self._audience {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 5)
    }
    if !self.publisherName.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Post, rhs: Server_Post) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.publisherUid != rhs.publisherUid {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs._audience != rhs._audience {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.publisherName != rhs.publisherName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Comment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Comment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "post_id"),
    3: .standard(proto: "parent_comment_id"),
    4: .standard(proto: "publisher_uid"),
    5: .standard(proto: "publisher_name"),
    6: .same(proto: "payload"),
    7: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.postID)
      case 3: try decoder.decodeSingularStringField(value: &self.parentCommentID)
      case 4: try decoder.decodeSingularInt64Field(value: &self.publisherUid)
      case 5: try decoder.decodeSingularStringField(value: &self.publisherName)
      case 6: try decoder.decodeSingularBytesField(value: &self.payload)
      case 7: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.postID.isEmpty {
      try visitor.visitSingularStringField(value: self.postID, fieldNumber: 2)
    }
    if !self.parentCommentID.isEmpty {
      try visitor.visitSingularStringField(value: self.parentCommentID, fieldNumber: 3)
    }
    if self.publisherUid != 0 {
      try visitor.visitSingularInt64Field(value: self.publisherUid, fieldNumber: 4)
    }
    if !self.publisherName.isEmpty {
      try visitor.visitSingularStringField(value: self.publisherName, fieldNumber: 5)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 6)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Comment, rhs: Server_Comment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.postID != rhs.postID {return false}
    if lhs.parentCommentID != rhs.parentCommentID {return false}
    if lhs.publisherUid != rhs.publisherUid {return false}
    if lhs.publisherName != rhs.publisherName {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ShareStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShareStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .standard(proto: "post_ids"),
    3: .same(proto: "result"),
    4: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 2: try decoder.decodeRepeatedStringField(value: &self.postIds)
      case 3: try decoder.decodeSingularStringField(value: &self.result)
      case 4: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.postIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.postIds, fieldNumber: 2)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ShareStanza, rhs: Server_ShareStanza) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.postIds != rhs.postIds {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "post"),
    3: .same(proto: "comment"),
    4: .standard(proto: "share_stanzas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2:
        var v: Server_Post?
        if let current = self.item {
          try decoder.handleConflictingOneOf()
          if case .post(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.item = .post(v)}
      case 3:
        var v: Server_Comment?
        if let current = self.item {
          try decoder.handleConflictingOneOf()
          if case .comment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.item = .comment(v)}
      case 4: try decoder.decodeRepeatedMessageField(value: &self.shareStanzas)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .publish {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    switch self.item {
    case .post(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .comment(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    if !self.shareStanzas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shareStanzas, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FeedItem, rhs: Server_FeedItem) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.item != rhs.item {return false}
    if lhs.shareStanzas != rhs.shareStanzas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FeedItem.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLISH"),
    1: .same(proto: "RETRACT"),
    2: .same(proto: "SHARE"),
  ]
}

extension Server_FeedItems: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedItems"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FeedItems, rhs: Server_FeedItems) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupFeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .same(proto: "post"),
    6: .same(proto: "comment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2: try decoder.decodeSingularStringField(value: &self.gid)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeSingularStringField(value: &self.avatarID)
      case 5:
        var v: Server_Post?
        if let current = self.item {
          try decoder.handleConflictingOneOf()
          if case .post(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.item = .post(v)}
      case 6:
        var v: Server_Comment?
        if let current = self.item {
          try decoder.handleConflictingOneOf()
          if case .comment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.item = .comment(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .publish {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 4)
    }
    switch self.item {
    case .post(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .comment(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupFeedItem, rhs: Server_GroupFeedItem) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupFeedItem.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PUBLISH"),
    1: .same(proto: "RETRACT"),
  ]
}

extension Server_GroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupMember"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
    3: .same(proto: "type"),
    4: .same(proto: "name"),
    5: .standard(proto: "avatar_id"),
    6: .same(proto: "result"),
    7: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 3: try decoder.decodeSingularEnumField(value: &self.type)
      case 4: try decoder.decodeSingularStringField(value: &self.name)
      case 5: try decoder.decodeSingularStringField(value: &self.avatarID)
      case 6: try decoder.decodeSingularStringField(value: &self.result)
      case 7: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    if self.type != .member {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 5)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 6)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupMember, rhs: Server_GroupMember) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupMember.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "REMOVE"),
    2: .same(proto: "PROMOTE"),
    3: .same(proto: "DEMOTE"),
    4: .same(proto: "LEAVE"),
  ]
}

extension Server_GroupMember.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER"),
    1: .same(proto: "ADMIN"),
  ]
}

extension Server_GroupStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "gid"),
    3: .same(proto: "name"),
    4: .standard(proto: "avatar_id"),
    5: .standard(proto: "sender_uid"),
    6: .standard(proto: "sender_name"),
    7: .same(proto: "members"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2: try decoder.decodeSingularStringField(value: &self.gid)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeSingularStringField(value: &self.avatarID)
      case 5: try decoder.decodeSingularInt64Field(value: &self.senderUid)
      case 6: try decoder.decodeSingularStringField(value: &self.senderName)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.members)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .set {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 4)
    }
    if self.senderUid != 0 {
      try visitor.visitSingularInt64Field(value: self.senderUid, fieldNumber: 5)
    }
    if !self.senderName.isEmpty {
      try visitor.visitSingularStringField(value: self.senderName, fieldNumber: 6)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupStanza, rhs: Server_GroupStanza) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.senderUid != rhs.senderUid {return false}
    if lhs.senderName != rhs.senderName {return false}
    if lhs.members != rhs.members {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupStanza.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SET"),
    1: .same(proto: "GET"),
    2: .same(proto: "CREATE"),
    3: .same(proto: "DELETE"),
    4: .same(proto: "LEAVE"),
    5: .same(proto: "CHANGE_AVATAR"),
    6: .same(proto: "CHANGE_NAME"),
    7: .same(proto: "MODIFY_ADMINS"),
    8: .same(proto: "MODIFY_MEMBERS"),
    9: .same(proto: "AUTO_PROMOTE_ADMINS"),
    10: .same(proto: "SET_NAME"),
  ]
}

extension Server_GroupChat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "gid"),
    2: .same(proto: "name"),
    3: .standard(proto: "avatar_id"),
    4: .standard(proto: "sender_uid"),
    5: .standard(proto: "sender_name"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.gid)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.avatarID)
      case 4: try decoder.decodeSingularInt64Field(value: &self.senderUid)
      case 5: try decoder.decodeSingularStringField(value: &self.senderName)
      case 6: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 7: try decoder.decodeSingularBytesField(value: &self.payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.avatarID.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarID, fieldNumber: 3)
    }
    if self.senderUid != 0 {
      try visitor.visitSingularInt64Field(value: self.senderUid, fieldNumber: 4)
    }
    if !self.senderName.isEmpty {
      try visitor.visitSingularStringField(value: self.senderName, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupChat, rhs: Server_GroupChat) -> Bool {
    if lhs.gid != rhs.gid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.avatarID != rhs.avatarID {return false}
    if lhs.senderUid != rhs.senderUid {return false}
    if lhs.senderName != rhs.senderName {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupsStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupsStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "group_stanzas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.groupStanzas)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .get {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.groupStanzas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupStanzas, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupsStanza, rhs: Server_GroupsStanza) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.groupStanzas != rhs.groupStanzas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupsStanza.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
  ]
}

extension Server_AuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "pwd"),
    3: .standard(proto: "client_mode"),
    4: .standard(proto: "client_version"),
    5: .same(proto: "resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.pwd)
      case 3: try decoder.decodeSingularMessageField(value: &self._clientMode)
      case 4: try decoder.decodeSingularMessageField(value: &self._clientVersion)
      case 5: try decoder.decodeSingularStringField(value: &self.resource)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.pwd.isEmpty {
      try visitor.visitSingularStringField(value: self.pwd, fieldNumber: 2)
    }
    if let v = self._clientMode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._clientVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AuthRequest, rhs: Server_AuthRequest) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.pwd != rhs.pwd {return false}
    if lhs._clientMode != rhs._clientMode {return false}
    if lhs._clientVersion != rhs._clientVersion {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_AuthResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "props_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.result)
      case 2: try decoder.decodeSingularStringField(value: &self.reason)
      case 3: try decoder.decodeSingularBytesField(value: &self.propsHash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.propsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.propsHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_AuthResult, rhs: Server_AuthResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.propsHash != rhs.propsHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Invite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Invite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "phone"),
    2: .same(proto: "result"),
    3: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.phone)
      case 2: try decoder.decodeSingularStringField(value: &self.result)
      case 3: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Invite, rhs: Server_Invite) -> Bool {
    if lhs.phone != rhs.phone {return false}
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InvitesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.invites)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invites, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InvitesRequest, rhs: Server_InvitesRequest) -> Bool {
    if lhs.invites != rhs.invites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_InvitesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvitesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invites_left"),
    2: .standard(proto: "time_until_refresh"),
    3: .same(proto: "invites"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.invitesLeft)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timeUntilRefresh)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.invites)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invitesLeft != 0 {
      try visitor.visitSingularInt32Field(value: self.invitesLeft, fieldNumber: 1)
    }
    if self.timeUntilRefresh != 0 {
      try visitor.visitSingularInt64Field(value: self.timeUntilRefresh, fieldNumber: 2)
    }
    if !self.invites.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invites, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_InvitesResponse, rhs: Server_InvitesResponse) -> Bool {
    if lhs.invitesLeft != rhs.invitesLeft {return false}
    if lhs.timeUntilRefresh != rhs.timeUntilRefresh {return false}
    if lhs.invites != rhs.invites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUrl: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaUrl"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "get"),
    2: .same(proto: "put"),
    3: .same(proto: "patch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.get)
      case 2: try decoder.decodeSingularStringField(value: &self.put)
      case 3: try decoder.decodeSingularStringField(value: &self.patch)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.get.isEmpty {
      try visitor.visitSingularStringField(value: self.get, fieldNumber: 1)
    }
    if !self.put.isEmpty {
      try visitor.visitSingularStringField(value: self.put, fieldNumber: 2)
    }
    if !self.patch.isEmpty {
      try visitor.visitSingularStringField(value: self.patch, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaUrl, rhs: Server_MediaUrl) -> Bool {
    if lhs.get != rhs.get {return false}
    if lhs.put != rhs.put {return false}
    if lhs.patch != rhs.patch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UploadMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadMedia"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.size)
      case 2: try decoder.decodeSingularMessageField(value: &self._url)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 1)
    }
    if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UploadMedia, rhs: Server_UploadMedia) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "payload"),
    3: .standard(proto: "enc_payload"),
    4: .standard(proto: "public_key"),
    5: .standard(proto: "one_time_pre_key_id"),
    6: .standard(proto: "sender_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.payload)
      case 3: try decoder.decodeSingularBytesField(value: &self.encPayload)
      case 4: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 5: try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID)
      case 6: try decoder.decodeSingularStringField(value: &self.senderName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 3)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 4)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 5)
    }
    if !self.senderName.isEmpty {
      try visitor.visitSingularStringField(value: self.senderName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatStanza, rhs: Server_ChatStanza) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.senderName != rhs.senderName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SilentChatStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SilentChatStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chat_stanza"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._chatStanza)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._chatStanza {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SilentChatStanza, rhs: Server_SilentChatStanza) -> Bool {
    if lhs._chatStanza != rhs._chatStanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Ping, rhs: Server_Ping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ErrorStanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorStanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ErrorStanza, rhs: Server_ErrorStanza) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Name, rhs: Server_Name) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Iq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Iq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "upload_media"),
    4: .standard(proto: "contact_list"),
    5: .standard(proto: "upload_avatar"),
    6: .same(proto: "avatar"),
    7: .same(proto: "avatars"),
    8: .standard(proto: "client_mode"),
    9: .standard(proto: "client_version"),
    10: .standard(proto: "push_register"),
    11: .standard(proto: "whisper_keys"),
    12: .same(proto: "ping"),
    13: .standard(proto: "feed_item"),
    14: .standard(proto: "privacy_list"),
    15: .standard(proto: "privacy_list_result"),
    16: .standard(proto: "privacy_lists"),
    17: .standard(proto: "group_stanza"),
    18: .standard(proto: "groups_stanza"),
    19: .standard(proto: "client_log"),
    20: .same(proto: "name"),
    21: .standard(proto: "error_stanza"),
    22: .same(proto: "props"),
    23: .standard(proto: "invites_request"),
    24: .standard(proto: "invites_response"),
    25: .standard(proto: "notification_prefs"),
    26: .standard(proto: "group_feed_item"),
    27: .standard(proto: "group_avatar"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: Server_Iq.TypeEnum = .get
    var _payload: Server_Iq.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3:
          var v: Server_UploadMedia?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .uploadMedia(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .uploadMedia(v)}
        case 4:
          var v: Server_ContactList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .contactList(v)}
        case 5:
          var v: Server_UploadAvatar?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .uploadAvatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .uploadAvatar(v)}
        case 6:
          var v: Server_Avatar?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .avatar(v)}
        case 7:
          var v: Server_Avatars?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .avatars(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .avatars(v)}
        case 8:
          var v: Server_ClientMode?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .clientMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .clientMode(v)}
        case 9:
          var v: Server_ClientVersion?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .clientVersion(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .clientVersion(v)}
        case 10:
          var v: Server_PushRegister?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .pushRegister(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .pushRegister(v)}
        case 11:
          var v: Server_WhisperKeys?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .whisperKeys(v)}
        case 12:
          var v: Server_Ping?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .ping(v)}
        case 13:
          var v: Server_FeedItem?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .feedItem(v)}
        case 14:
          var v: Server_PrivacyList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .privacyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .privacyList(v)}
        case 15:
          var v: Server_PrivacyListResult?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .privacyListResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .privacyListResult(v)}
        case 16:
          var v: Server_PrivacyLists?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .privacyLists(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .privacyLists(v)}
        case 17:
          var v: Server_GroupStanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupStanza(v)}
        case 18:
          var v: Server_GroupsStanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsStanza(v)}
        case 19:
          var v: Server_ClientLog?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .clientLog(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .clientLog(v)}
        case 20:
          var v: Server_Name?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .name(v)}
        case 21:
          var v: Server_ErrorStanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .errorStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .errorStanza(v)}
        case 22:
          var v: Server_Props?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .props(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .props(v)}
        case 23:
          var v: Server_InvitesRequest?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .invitesRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .invitesRequest(v)}
        case 24:
          var v: Server_InvitesResponse?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .invitesResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .invitesResponse(v)}
        case 25:
          var v: Server_NotificationPrefs?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .notificationPrefs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .notificationPrefs(v)}
        case 26:
          var v: Server_GroupFeedItem?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupFeedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupFeedItem(v)}
        case 27:
          var v: Server_UploadGroupAvatar?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupAvatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupAvatar(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .get {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      switch _storage._payload {
      case .uploadMedia(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .contactList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .uploadAvatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .avatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .avatars(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .clientMode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .clientVersion(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .pushRegister(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .whisperKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .ping(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .feedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .privacyList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .privacyListResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .privacyLists(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .groupStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .groupsStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .clientLog(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .name(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .errorStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .props(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .invitesRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .invitesResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .notificationPrefs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .groupFeedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case .groupAvatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Iq, rhs: Server_Iq) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Iq.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GET"),
    1: .same(proto: "SET"),
    2: .same(proto: "RESULT"),
    3: .same(proto: "ERROR"),
  ]
}

extension Server_Msg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Msg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "to_uid"),
    4: .standard(proto: "from_uid"),
    5: .standard(proto: "contact_list"),
    6: .same(proto: "avatar"),
    7: .standard(proto: "whisper_keys"),
    8: .standard(proto: "seen_receipt"),
    9: .standard(proto: "delivery_receipt"),
    10: .standard(proto: "chat_stanza"),
    11: .standard(proto: "feed_item"),
    12: .standard(proto: "feed_items"),
    13: .standard(proto: "contact_hash"),
    14: .standard(proto: "group_stanza"),
    15: .standard(proto: "group_chat"),
    16: .same(proto: "name"),
    17: .standard(proto: "error_stanza"),
    18: .standard(proto: "groupchat_retract"),
    19: .standard(proto: "chat_retract"),
    20: .standard(proto: "group_feed_item"),
    22: .same(proto: "rerequest"),
    23: .standard(proto: "silent_chat_stanza"),
    21: .standard(proto: "retry_count"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: Server_Msg.TypeEnum = .normal
    var _toUid: Int64 = 0
    var _fromUid: Int64 = 0
    var _payload: Server_Msg.OneOf_Payload?
    var _retryCount: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _toUid = source._toUid
      _fromUid = source._fromUid
      _payload = source._payload
      _retryCount = source._retryCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._toUid)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._fromUid)
        case 5:
          var v: Server_ContactList?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .contactList(v)}
        case 6:
          var v: Server_Avatar?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .avatar(v)}
        case 7:
          var v: Server_WhisperKeys?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .whisperKeys(v)}
        case 8:
          var v: Server_SeenReceipt?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .seenReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .seenReceipt(v)}
        case 9:
          var v: Server_DeliveryReceipt?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .deliveryReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .deliveryReceipt(v)}
        case 10:
          var v: Server_ChatStanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .chatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .chatStanza(v)}
        case 11:
          var v: Server_FeedItem?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .feedItem(v)}
        case 12:
          var v: Server_FeedItems?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .feedItems(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .feedItems(v)}
        case 13:
          var v: Server_ContactHash?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .contactHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .contactHash(v)}
        case 14:
          var v: Server_GroupStanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupStanza(v)}
        case 15:
          var v: Server_GroupChat?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupChat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupChat(v)}
        case 16:
          var v: Server_Name?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .name(v)}
        case 17:
          var v: Server_ErrorStanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .errorStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .errorStanza(v)}
        case 18:
          var v: Server_GroupChatRetract?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupchatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupchatRetract(v)}
        case 19:
          var v: Server_ChatRetract?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .chatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .chatRetract(v)}
        case 20:
          var v: Server_GroupFeedItem?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupFeedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupFeedItem(v)}
        case 21: try decoder.decodeSingularInt32Field(value: &_storage._retryCount)
        case 22:
          var v: Server_Rerequest?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .rerequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .rerequest(v)}
        case 23:
          var v: Server_SilentChatStanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .silentChatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .silentChatStanza(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._toUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._toUid, fieldNumber: 3)
      }
      if _storage._fromUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fromUid, fieldNumber: 4)
      }
      switch _storage._payload {
      case .contactList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .avatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .whisperKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .seenReceipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .deliveryReceipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .chatStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .feedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .feedItems(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .contactHash(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .groupStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .groupChat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .name(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .errorStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .groupchatRetract(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .chatRetract(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .groupFeedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case nil: break
      default: break
      }
      if _storage._retryCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._retryCount, fieldNumber: 21)
      }
      switch _storage._payload {
      case .rerequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .silentChatStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case nil: break
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Msg, rhs: Server_Msg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._toUid != rhs_storage._toUid {return false}
        if _storage._fromUid != rhs_storage._fromUid {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._retryCount != rhs_storage._retryCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Msg.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ERROR"),
    2: .same(proto: "GROUPCHAT"),
    3: .same(proto: "HEADLINE"),
    4: .same(proto: "CHAT"),
  ]
}

extension Server_Presence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Presence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "uid"),
    4: .standard(proto: "last_seen"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 4: try decoder.decodeSingularInt64Field(value: &self.lastSeen)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 3)
    }
    if self.lastSeen != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeen, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Presence, rhs: Server_Presence) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.lastSeen != rhs.lastSeen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Presence.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AVAILABLE"),
    1: .same(proto: "AWAY"),
    2: .same(proto: "SUBSCRIBE"),
    3: .same(proto: "UNSUBSCRIBE"),
  ]
}

extension Server_ChatState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "thread_id"),
    3: .standard(proto: "thread_type"),
    4: .standard(proto: "from_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.threadID)
      case 3: try decoder.decodeSingularEnumField(value: &self.threadType)
      case 4: try decoder.decodeSingularInt64Field(value: &self.fromUid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.threadType != .chat {
      try visitor.visitSingularEnumField(value: self.threadType, fieldNumber: 3)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatState, rhs: Server_ChatState) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.threadType != rhs.threadType {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatState.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AVAILABLE"),
    1: .same(proto: "TYPING"),
  ]
}

extension Server_ChatState.ThreadType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHAT"),
    1: .same(proto: "GROUP_CHAT"),
  ]
}

extension Server_Ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Ack, rhs: Server_Ack) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_HaError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HaError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_HaError, rhs: Server_HaError) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Packet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Packet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "iq"),
    3: .same(proto: "ack"),
    4: .same(proto: "presence"),
    5: .standard(proto: "ha_error"),
    6: .standard(proto: "chat_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Server_Msg?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .msg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .msg(v)}
      case 2:
        var v: Server_Iq?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .iq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .iq(v)}
      case 3:
        var v: Server_Ack?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .ack(v)}
      case 4:
        var v: Server_Presence?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .presence(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .presence(v)}
      case 5:
        var v: Server_HaError?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .haError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .haError(v)}
      case 6:
        var v: Server_ChatState?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .chatState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .chatState(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.stanza {
    case .msg(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .iq(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .ack(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .presence(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .haError(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .chatState(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Packet, rhs: Server_Packet) -> Bool {
    if lhs.stanza != rhs.stanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UidElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UidElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.action)
      case 2: try decoder.decodeSingularInt64Field(value: &self.uid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .add {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_UidElement, rhs: Server_UidElement) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_UidElement.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADD"),
    1: .same(proto: "DELETE"),
  ]
}

extension Server_PrivacyList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "uid_elements"),
    3: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.uidElements)
      case 3: try decoder.decodeSingularBytesField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .all {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.uidElements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uidElements, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PrivacyList, rhs: Server_PrivacyList) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.uidElements != rhs.uidElements {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PrivacyList.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "EXCEPT"),
    3: .same(proto: "MUTE"),
    4: .same(proto: "ONLY"),
  ]
}

extension Server_PrivacyListResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyListResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.result)
      case 2: try decoder.decodeSingularStringField(value: &self.reason)
      case 3: try decoder.decodeSingularBytesField(value: &self.hash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PrivacyListResult, rhs: Server_PrivacyListResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PrivacyLists: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivacyLists"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_type"),
    2: .same(proto: "lists"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.activeType)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.lists)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.activeType != .all {
      try visitor.visitSingularEnumField(value: self.activeType, fieldNumber: 1)
    }
    if !self.lists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lists, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PrivacyLists, rhs: Server_PrivacyLists) -> Bool {
    if lhs.activeType != rhs.activeType {return false}
    if lhs.lists != rhs.lists {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PrivacyLists.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL"),
    1: .same(proto: "BLOCK"),
    2: .same(proto: "EXCEPT"),
  ]
}

extension Server_PushToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "os"),
    2: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.os)
      case 2: try decoder.decodeSingularStringField(value: &self.token)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.os != .android {
      try visitor.visitSingularEnumField(value: self.os, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushToken, rhs: Server_PushToken) -> Bool {
    if lhs.os != rhs.os {return false}
    if lhs.token != rhs.token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushToken.Os: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANDROID"),
    1: .same(proto: "IOS"),
    2: .same(proto: "IOS_DEV"),
  ]
}

extension Server_PushRegister: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushRegister"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._pushToken)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._pushToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushRegister, rhs: Server_PushRegister) -> Bool {
    if lhs._pushToken != rhs._pushToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushPref: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushPref"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.name)
      case 2: try decoder.decodeSingularBoolField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.name != .post {
      try visitor.visitSingularEnumField(value: self.name, fieldNumber: 1)
    }
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushPref, rhs: Server_PushPref) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushPref.Name: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "COMMENT"),
  ]
}

extension Server_NotificationPrefs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationPrefs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "push_prefs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.pushPrefs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pushPrefs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pushPrefs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_NotificationPrefs, rhs: Server_NotificationPrefs) -> Bool {
    if lhs.pushPrefs != rhs.pushPrefs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Rerequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rerequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "identity_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularBytesField(value: &self.identityKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Rerequest, rhs: Server_Rerequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_SeenReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeenReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.threadID)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_SeenReceipt, rhs: Server_SeenReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DeliveryReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeliveryReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "thread_id"),
    3: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.threadID)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DeliveryReceipt, rhs: Server_DeliveryReceipt) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupChatRetract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupChatRetract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "gid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.gid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupChatRetract, rhs: Server_GroupChatRetract) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_ChatRetract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChatRetract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_ChatRetract, rhs: Server_ChatRetract) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Prop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Prop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Prop, rhs: Server_Prop) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Props: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Props"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "props"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.props)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.props.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.props, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Props, rhs: Server_Props) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.props != rhs.props {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WhisperKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "action"),
    3: .standard(proto: "identity_key"),
    4: .standard(proto: "signed_key"),
    5: .standard(proto: "otp_key_count"),
    6: .standard(proto: "one_time_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 2: try decoder.decodeSingularEnumField(value: &self.action)
      case 3: try decoder.decodeSingularBytesField(value: &self.identityKey)
      case 4: try decoder.decodeSingularBytesField(value: &self.signedKey)
      case 5: try decoder.decodeSingularInt32Field(value: &self.otpKeyCount)
      case 6: try decoder.decodeRepeatedBytesField(value: &self.oneTimeKeys)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if self.action != .normal {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.identityKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.identityKey, fieldNumber: 3)
    }
    if !self.signedKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedKey, fieldNumber: 4)
    }
    if self.otpKeyCount != 0 {
      try visitor.visitSingularInt32Field(value: self.otpKeyCount, fieldNumber: 5)
    }
    if !self.oneTimeKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.oneTimeKeys, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_WhisperKeys, rhs: Server_WhisperKeys) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.action != rhs.action {return false}
    if lhs.identityKey != rhs.identityKey {return false}
    if lhs.signedKey != rhs.signedKey {return false}
    if lhs.otpKeyCount != rhs.otpKeyCount {return false}
    if lhs.oneTimeKeys != rhs.oneTimeKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_WhisperKeys.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ADD"),
    2: .same(proto: "COUNT"),
    3: .same(proto: "GET"),
    4: .same(proto: "SET"),
    5: .same(proto: "UPDATE"),
  ]
}
