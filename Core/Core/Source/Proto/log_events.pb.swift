// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: log_events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Server_Platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case android // = 0
  case ios // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .android
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .android
    case 1: self = .ios
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .android: return 0
    case .ios: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Platform] = [
    .android,
    .ios,
  ]
}

#endif  // swift(>=4.2)

public struct Server_EventData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt64 = 0

  /// client platform `android` or `ios`
  public var platform: Server_Platform = .android

  /// client version (eg.`0.94`)
  public var version: String = String()

  public var edata: Server_EventData.OneOf_Edata? = nil

  public var mediaUpload: Server_MediaUpload {
    get {
      if case .mediaUpload(let v)? = edata {return v}
      return Server_MediaUpload()
    }
    set {edata = .mediaUpload(newValue)}
  }

  public var mediaDownload: Server_MediaDownload {
    get {
      if case .mediaDownload(let v)? = edata {return v}
      return Server_MediaDownload()
    }
    set {edata = .mediaDownload(newValue)}
  }

  public var mediaComposeLoad: Server_MediaComposeLoad {
    get {
      if case .mediaComposeLoad(let v)? = edata {return v}
      return Server_MediaComposeLoad()
    }
    set {edata = .mediaComposeLoad(newValue)}
  }

  public var pushReceived: Server_PushReceived {
    get {
      if case .pushReceived(let v)? = edata {return v}
      return Server_PushReceived()
    }
    set {edata = .pushReceived(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Edata: Equatable {
    case mediaUpload(Server_MediaUpload)
    case mediaDownload(Server_MediaDownload)
    case mediaComposeLoad(Server_MediaComposeLoad)
    case pushReceived(Server_PushReceived)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_EventData.OneOf_Edata, rhs: Server_EventData.OneOf_Edata) -> Bool {
      switch (lhs, rhs) {
      case (.mediaUpload(let l), .mediaUpload(let r)): return l == r
      case (.mediaDownload(let l), .mediaDownload(let r)): return l == r
      case (.mediaComposeLoad(let l), .mediaComposeLoad(let r)): return l == r
      case (.pushReceived(let l), .pushReceived(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_MediaUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaUpload.TypeEnum = .post

  /// time in ms it took to upload all the media and send iq/message
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects uploaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaUpload.Status = .ok

  /// 0 if upload worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaUpload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.TypeEnum] = [
    .post,
    .message,
  ]
}

extension Server_MediaUpload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaDownload.TypeEnum = .post

  /// time in ms it took to download all the media
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects downloaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaDownload.Status = .ok

  /// 0 if download worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaDownload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.TypeEnum] = [
    .post,
    .message,
  ]
}

extension Server_MediaDownload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaComposeLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// time in ms it took to load all the media and transcode them.
  public var durationMs: UInt32 = 0

  /// Basically until the share button shows up.
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects
  public var totalSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PushReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var clientTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANDROID"),
    1: .same(proto: "IOS"),
  ]
}

extension Server_EventData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "platform"),
    3: .same(proto: "version"),
    10: .standard(proto: "media_upload"),
    11: .standard(proto: "media_download"),
    12: .standard(proto: "media_compose_load"),
    13: .standard(proto: "push_received"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.uid)
      case 2: try decoder.decodeSingularEnumField(value: &self.platform)
      case 3: try decoder.decodeSingularStringField(value: &self.version)
      case 10:
        var v: Server_MediaUpload?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .mediaUpload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .mediaUpload(v)}
      case 11:
        var v: Server_MediaDownload?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .mediaDownload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .mediaDownload(v)}
      case 12:
        var v: Server_MediaComposeLoad?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .mediaComposeLoad(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .mediaComposeLoad(v)}
      case 13:
        var v: Server_PushReceived?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .pushReceived(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .pushReceived(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt64Field(value: self.uid, fieldNumber: 1)
    }
    if self.platform != .android {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    switch self.edata {
    case .mediaUpload(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    case .mediaDownload(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    case .mediaComposeLoad(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    case .pushReceived(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EventData, rhs: Server_EventData) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.version != rhs.version {return false}
    if lhs.edata != rhs.edata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.durationMs)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numPhotos)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.numVideos)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.totalSize)
      case 7: try decoder.decodeSingularEnumField(value: &self.status)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.retryCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaUpload, rhs: Server_MediaUpload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUpload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
  ]
}

extension Server_MediaUpload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaDownload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.durationMs)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.numPhotos)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.numVideos)
      case 6: try decoder.decodeSingularUInt32Field(value: &self.totalSize)
      case 7: try decoder.decodeSingularEnumField(value: &self.status)
      case 8: try decoder.decodeSingularUInt32Field(value: &self.retryCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaDownload, rhs: Server_MediaDownload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaDownload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
  ]
}

extension Server_MediaDownload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaComposeLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaComposeLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_ms"),
    2: .standard(proto: "num_photos"),
    3: .standard(proto: "num_videos"),
    4: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.durationMs)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.numPhotos)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.numVideos)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.totalSize)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 1)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 2)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 3)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaComposeLoad, rhs: Server_MediaComposeLoad) -> Bool {
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushReceived"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "client_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.clientTimestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.clientTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushReceived, rhs: Server_PushReceived) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.clientTimestamp != rhs.clientTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
