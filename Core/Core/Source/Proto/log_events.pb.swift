// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: log_events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Server_Platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case ios // = 1
  case android // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ios
    case 2: self = .android
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ios: return 1
    case .android: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Platform] = [
    .unknown,
    .ios,
    .android,
  ]
}

#endif  // swift(>=4.2)

public struct Server_EventData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt64 = 0

  /// client platform `android` or `ios`
  public var platform: Server_Platform = .unknown

  /// client version (eg.`0.94`)
  public var version: String = String()

  /// set by server to indicate when event was received
  public var timestampMs: UInt64 = 0

  public var edata: Server_EventData.OneOf_Edata? = nil

  public var mediaUpload: Server_MediaUpload {
    get {
      if case .mediaUpload(let v)? = edata {return v}
      return Server_MediaUpload()
    }
    set {edata = .mediaUpload(newValue)}
  }

  public var mediaDownload: Server_MediaDownload {
    get {
      if case .mediaDownload(let v)? = edata {return v}
      return Server_MediaDownload()
    }
    set {edata = .mediaDownload(newValue)}
  }

  public var mediaComposeLoad: Server_MediaComposeLoad {
    get {
      if case .mediaComposeLoad(let v)? = edata {return v}
      return Server_MediaComposeLoad()
    }
    set {edata = .mediaComposeLoad(newValue)}
  }

  public var pushReceived: Server_PushReceived {
    get {
      if case .pushReceived(let v)? = edata {return v}
      return Server_PushReceived()
    }
    set {edata = .pushReceived(newValue)}
  }

  public var decryptionReport: Server_DecryptionReport {
    get {
      if case .decryptionReport(let v)? = edata {return v}
      return Server_DecryptionReport()
    }
    set {edata = .decryptionReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Edata: Equatable {
    case mediaUpload(Server_MediaUpload)
    case mediaDownload(Server_MediaDownload)
    case mediaComposeLoad(Server_MediaComposeLoad)
    case pushReceived(Server_PushReceived)
    case decryptionReport(Server_DecryptionReport)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_EventData.OneOf_Edata, rhs: Server_EventData.OneOf_Edata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mediaUpload, .mediaUpload): return {
        guard case .mediaUpload(let l) = lhs, case .mediaUpload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaDownload, .mediaDownload): return {
        guard case .mediaDownload(let l) = lhs, case .mediaDownload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaComposeLoad, .mediaComposeLoad): return {
        guard case .mediaComposeLoad(let l) = lhs, case .mediaComposeLoad(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pushReceived, .pushReceived): return {
        guard case .pushReceived(let l) = lhs, case .pushReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.decryptionReport, .decryptionReport): return {
        guard case .decryptionReport(let l) = lhs, case .decryptionReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Server_MediaUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaUpload.TypeEnum = .post

  /// time in ms it took to upload all the media and send iq/message
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects uploaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaUpload.Status = .ok

  /// 0 if upload worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaUpload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaUpload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaDownload.TypeEnum = .post

  /// time in ms it took to download all the media
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects downloaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaDownload.Status = .ok

  /// 0 if download worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaDownload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaDownload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaComposeLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// time in ms it took to load all the media and transcode them.
  public var durationMs: UInt32 = 0

  /// Basically until the share button shows up.
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects
  public var totalSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PushReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var clientTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DecryptionReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_DecryptionReport.Status = .ok

  public var reason: String = String()

  public var msgID: String = String()

  /// at time message id was first encountered
  public var originalVersion: String = String()

  public var senderPlatform: Server_Platform = .unknown

  public var senderVersion: String = String()

  public var rerequestCount: UInt32 = 0

  public var timeTakenS: UInt32 = 0

  public var isSilent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_DecryptionReport.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_DecryptionReport.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "IOS"),
    2: .same(proto: "ANDROID"),
  ]
}

extension Server_EventData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "platform"),
    3: .same(proto: "version"),
    4: .standard(proto: "timestamp_ms"),
    10: .standard(proto: "media_upload"),
    11: .standard(proto: "media_download"),
    12: .standard(proto: "media_compose_load"),
    13: .standard(proto: "push_received"),
    14: .standard(proto: "decryption_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.uid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestampMs) }()
      case 10: try {
        var v: Server_MediaUpload?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .mediaUpload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .mediaUpload(v)}
      }()
      case 11: try {
        var v: Server_MediaDownload?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .mediaDownload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .mediaDownload(v)}
      }()
      case 12: try {
        var v: Server_MediaComposeLoad?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .mediaComposeLoad(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .mediaComposeLoad(v)}
      }()
      case 13: try {
        var v: Server_PushReceived?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .pushReceived(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .pushReceived(v)}
      }()
      case 14: try {
        var v: Server_DecryptionReport?
        if let current = self.edata {
          try decoder.handleConflictingOneOf()
          if case .decryptionReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.edata = .decryptionReport(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularUInt64Field(value: self.uid, fieldNumber: 1)
    }
    if self.platform != .unknown {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if self.timestampMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampMs, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.edata {
    case .mediaUpload?: try {
      guard case .mediaUpload(let v)? = self.edata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .mediaDownload?: try {
      guard case .mediaDownload(let v)? = self.edata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .mediaComposeLoad?: try {
      guard case .mediaComposeLoad(let v)? = self.edata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .pushReceived?: try {
      guard case .pushReceived(let v)? = self.edata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .decryptionReport?: try {
      guard case .decryptionReport(let v)? = self.edata else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EventData, rhs: Server_EventData) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.version != rhs.version {return false}
    if lhs.timestampMs != rhs.timestampMs {return false}
    if lhs.edata != rhs.edata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaUpload, rhs: Server_MediaUpload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUpload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaUpload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaDownload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaDownload, rhs: Server_MediaDownload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaDownload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaDownload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaComposeLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaComposeLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_ms"),
    2: .standard(proto: "num_photos"),
    3: .standard(proto: "num_videos"),
    4: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 1)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 2)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 3)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaComposeLoad, rhs: Server_MediaComposeLoad) -> Bool {
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushReceived"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "client_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.clientTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.clientTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushReceived, rhs: Server_PushReceived) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.clientTimestamp != rhs.clientTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DecryptionReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptionReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "msg_id"),
    4: .standard(proto: "original_version"),
    5: .standard(proto: "sender_platform"),
    6: .standard(proto: "sender_version"),
    7: .standard(proto: "rerequest_count"),
    8: .standard(proto: "time_taken_s"),
    9: .standard(proto: "is_silent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.originalVersion) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.senderPlatform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.senderVersion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.rerequestCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.timeTakenS) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isSilent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 3)
    }
    if !self.originalVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.originalVersion, fieldNumber: 4)
    }
    if self.senderPlatform != .unknown {
      try visitor.visitSingularEnumField(value: self.senderPlatform, fieldNumber: 5)
    }
    if !self.senderVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderVersion, fieldNumber: 6)
    }
    if self.rerequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rerequestCount, fieldNumber: 7)
    }
    if self.timeTakenS != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTakenS, fieldNumber: 8)
    }
    if self.isSilent != false {
      try visitor.visitSingularBoolField(value: self.isSilent, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DecryptionReport, rhs: Server_DecryptionReport) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.originalVersion != rhs.originalVersion {return false}
    if lhs.senderPlatform != rhs.senderPlatform {return false}
    if lhs.senderVersion != rhs.senderVersion {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs.timeTakenS != rhs.timeTakenS {return false}
    if lhs.isSilent != rhs.isSilent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DecryptionReport.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}
