// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: log_events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Server_Platform: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case ios // = 1
  case android // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ios
    case 2: self = .android
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ios: return 1
    case .android: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Server_Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Platform] = [
    .unknown,
    .ios,
    .android,
  ]
}

#endif  // swift(>=4.2)

public struct Server_EventData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: UInt64 {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  /// client platform `android` or `ios`
  public var platform: Server_Platform {
    get {return _storage._platform}
    set {_uniqueStorage()._platform = newValue}
  }

  /// client version (eg.`0.94`)
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// set by server to indicate when event was received
  public var timestampMs: UInt64 {
    get {return _storage._timestampMs}
    set {_uniqueStorage()._timestampMs = newValue}
  }

  /// 2 letter country code
  public var cc: String {
    get {return _storage._cc}
    set {_uniqueStorage()._cc = newValue}
  }

  public var edata: OneOf_Edata? {
    get {return _storage._edata}
    set {_uniqueStorage()._edata = newValue}
  }

  public var mediaUpload: Server_MediaUpload {
    get {
      if case .mediaUpload(let v)? = _storage._edata {return v}
      return Server_MediaUpload()
    }
    set {_uniqueStorage()._edata = .mediaUpload(newValue)}
  }

  public var mediaDownload: Server_MediaDownload {
    get {
      if case .mediaDownload(let v)? = _storage._edata {return v}
      return Server_MediaDownload()
    }
    set {_uniqueStorage()._edata = .mediaDownload(newValue)}
  }

  public var mediaComposeLoad: Server_MediaComposeLoad {
    get {
      if case .mediaComposeLoad(let v)? = _storage._edata {return v}
      return Server_MediaComposeLoad()
    }
    set {_uniqueStorage()._edata = .mediaComposeLoad(newValue)}
  }

  public var pushReceived: Server_PushReceived {
    get {
      if case .pushReceived(let v)? = _storage._edata {return v}
      return Server_PushReceived()
    }
    set {_uniqueStorage()._edata = .pushReceived(newValue)}
  }

  public var decryptionReport: Server_DecryptionReport {
    get {
      if case .decryptionReport(let v)? = _storage._edata {return v}
      return Server_DecryptionReport()
    }
    set {_uniqueStorage()._edata = .decryptionReport(newValue)}
  }

  public var permissions: Server_Permissions {
    get {
      if case .permissions(let v)? = _storage._edata {return v}
      return Server_Permissions()
    }
    set {_uniqueStorage()._edata = .permissions(newValue)}
  }

  public var mediaObjectDownload: Server_MediaObjectDownload {
    get {
      if case .mediaObjectDownload(let v)? = _storage._edata {return v}
      return Server_MediaObjectDownload()
    }
    set {_uniqueStorage()._edata = .mediaObjectDownload(newValue)}
  }

  public var groupDecryptionReport: Server_GroupDecryptionReport {
    get {
      if case .groupDecryptionReport(let v)? = _storage._edata {return v}
      return Server_GroupDecryptionReport()
    }
    set {_uniqueStorage()._edata = .groupDecryptionReport(newValue)}
  }

  public var call: Server_Call {
    get {
      if case .call(let v)? = _storage._edata {return v}
      return Server_Call()
    }
    set {_uniqueStorage()._edata = .call(newValue)}
  }

  public var fabAction: Server_FabAction {
    get {
      if case .fabAction(let v)? = _storage._edata {return v}
      return Server_FabAction()
    }
    set {_uniqueStorage()._edata = .fabAction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Edata: Equatable {
    case mediaUpload(Server_MediaUpload)
    case mediaDownload(Server_MediaDownload)
    case mediaComposeLoad(Server_MediaComposeLoad)
    case pushReceived(Server_PushReceived)
    case decryptionReport(Server_DecryptionReport)
    case permissions(Server_Permissions)
    case mediaObjectDownload(Server_MediaObjectDownload)
    case groupDecryptionReport(Server_GroupDecryptionReport)
    case call(Server_Call)
    case fabAction(Server_FabAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Server_EventData.OneOf_Edata, rhs: Server_EventData.OneOf_Edata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mediaUpload, .mediaUpload): return {
        guard case .mediaUpload(let l) = lhs, case .mediaUpload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaDownload, .mediaDownload): return {
        guard case .mediaDownload(let l) = lhs, case .mediaDownload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaComposeLoad, .mediaComposeLoad): return {
        guard case .mediaComposeLoad(let l) = lhs, case .mediaComposeLoad(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pushReceived, .pushReceived): return {
        guard case .pushReceived(let l) = lhs, case .pushReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.decryptionReport, .decryptionReport): return {
        guard case .decryptionReport(let l) = lhs, case .decryptionReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permissions, .permissions): return {
        guard case .permissions(let l) = lhs, case .permissions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mediaObjectDownload, .mediaObjectDownload): return {
        guard case .mediaObjectDownload(let l) = lhs, case .mediaObjectDownload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupDecryptionReport, .groupDecryptionReport): return {
        guard case .groupDecryptionReport(let l) = lhs, case .groupDecryptionReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.call, .call): return {
        guard case .call(let l) = lhs, case .call(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fabAction, .fabAction): return {
        guard case .fabAction(let l) = lhs, case .fabAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Server_MediaObjectDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of post or message
  public var id: String = String()

  /// 0-based index of the media item in the post/msg
  public var index: UInt64 = 0

  public var type: Server_MediaObjectDownload.TypeEnum = .post

  public var mediaType: Server_MediaObjectDownload.MediaType = .photo

  /// time in ms it took to download the media object
  public var durationMs: UInt64 = 0

  /// byte size of the object
  public var size: UInt64 = 0

  /// number of bytes downloaded during this attempt
  public var progressBytes: UInt64 = 0

  /// should be cloudfront for now
  public var cdn: Server_MediaObjectDownload.Cdn = .unknownCdn

  /// value of the `x-amz-cf-pop` result header
  public var cdnPop: String = String()

  /// value of the `x-amz-cf-id` result header
  public var cdnID: String = String()

  public var cdnCache: Server_MediaObjectDownload.CdnCache = .unknownCache

  public var status: Server_MediaObjectDownload.Status = .ok

  /// number of attempts to download, either so far or until status=ok
  public var retryCount: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case post // = 0
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum MediaType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case photo // = 0
    case video // = 1
    case audio // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .photo
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .photo
      case 1: self = .video
      case 2: self = .audio
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .photo: return 0
      case .video: return 1
      case .audio: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Cdn: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownCdn // = 0
    case cloudfront // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownCdn
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownCdn
      case 1: self = .cloudfront
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownCdn: return 0
      case .cloudfront: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum CdnCache: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownCache // = 0
    case hit // = 1
    case miss // = 2
    case refreshHit // = 3
    case refreshMiss // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownCache
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownCache
      case 1: self = .hit
      case 2: self = .miss
      case 3: self = .refreshHit
      case 4: self = .refreshMiss
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownCache: return 0
      case .hit: return 1
      case .miss: return 2
      case .refreshHit: return 3
      case .refreshMiss: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaObjectDownload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaObjectDownload.MediaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.MediaType] = [
    .photo,
    .video,
    .audio,
  ]
}

extension Server_MediaObjectDownload.Cdn: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.Cdn] = [
    .unknownCdn,
    .cloudfront,
  ]
}

extension Server_MediaObjectDownload.CdnCache: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.CdnCache] = [
    .unknownCache,
    .hit,
    .miss,
    .refreshHit,
    .refreshMiss,
  ]
}

extension Server_MediaObjectDownload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaObjectDownload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaUpload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaUpload.TypeEnum = .post

  /// time in ms it took to upload all the media and send iq/message
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects uploaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaUpload.Status = .ok

  /// 0 if upload worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaUpload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaUpload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaUpload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the id of the post or message
  public var id: String = String()

  public var type: Server_MediaDownload.TypeEnum = .post

  /// time in ms it took to download all the media
  public var durationMs: UInt32 = 0

  /// number of photos
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects downloaded
  public var totalSize: UInt32 = 0

  /// if the request was ok or failed over all
  public var status: Server_MediaDownload.Status = .ok

  /// 0 if download worked from the first attempt
  public var retryCount: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// post or group_post
    case post // = 0

    /// 1v1 message or group_message
    case message // = 1
    case comment // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .post
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .post
      case 1: self = .message
      case 2: self = .comment
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .post: return 0
      case .message: return 1
      case .comment: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_MediaDownload.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.TypeEnum] = [
    .post,
    .message,
    .comment,
  ]
}

extension Server_MediaDownload.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_MediaDownload.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_MediaComposeLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// time in ms it took to load all the media and transcode them.
  public var durationMs: UInt32 = 0

  /// Basically until the share button shows up.
  public var numPhotos: UInt32 = 0

  /// number of videos
  public var numVideos: UInt32 = 0

  /// the total size in bytes of all the media objects
  public var totalSize: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_PushReceived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var clientTimestamp: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Server_DecryptionReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_DecryptionReport.Status = .ok

  public var reason: String = String()

  public var msgID: String = String()

  /// at time message id was first encountered
  public var originalVersion: String = String()

  public var senderPlatform: Server_Platform = .unknown

  public var senderVersion: String = String()

  public var rerequestCount: UInt32 = 0

  public var timeTakenS: UInt32 = 0

  public var isSilent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case fail // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .fail: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_DecryptionReport.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_DecryptionReport.Status] = [
    .ok,
    .fail,
  ]
}

#endif  // swift(>=4.2)

public struct Server_GroupDecryptionReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: Server_GroupDecryptionReport.Status = .unknownStatus

  public var reason: String = String()

  public var contentID: String = String()

  public var gid: String = String()

  public var itemType: Server_GroupDecryptionReport.ItemType = .unknownType

  /// at time msg id was first encountered
  public var originalVersion: String = String()

  public var rerequestCount: UInt32 = 0

  public var timeTakenS: UInt32 = 0

  public var senderPlatform: Server_Platform = .unknown

  public var senderVersion: String = String()

  public var schedule: Server_GroupDecryptionReport.Schedule = .daily

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownStatus // = 0
    case ok // = 1
    case fail // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownStatus
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownStatus
      case 1: self = .ok
      case 2: self = .fail
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownStatus: return 0
      case .ok: return 1
      case .fail: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ItemType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case post // = 1
    case comment // = 2
    case historyResend // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .post
      case 2: self = .comment
      case 3: self = .historyResend
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .post: return 1
      case .comment: return 2
      case .historyResend: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Schedule: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case daily // = 0
    case resultBased // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .daily
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .daily
      case 1: self = .resultBased
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .daily: return 0
      case .resultBased: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_GroupDecryptionReport.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupDecryptionReport.Status] = [
    .unknownStatus,
    .ok,
    .fail,
  ]
}

extension Server_GroupDecryptionReport.ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupDecryptionReport.ItemType] = [
    .unknownType,
    .post,
    .comment,
    .historyResend,
  ]
}

extension Server_GroupDecryptionReport.Schedule: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_GroupDecryptionReport.Schedule] = [
    .daily,
    .resultBased,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Permissions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_Permissions.TypeEnum = .contacts

  public var status: Server_Permissions.Status = .allowed

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case contacts // = 0
    case notifications // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .contacts
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .contacts
      case 1: self = .notifications
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .contacts: return 0
      case .notifications: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case allowed // = 0
    case denied // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allowed
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowed
      case 1: self = .denied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allowed: return 0
      case .denied: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Permissions.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Permissions.TypeEnum] = [
    .contacts,
    .notifications,
  ]
}

extension Server_Permissions.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Permissions.Status] = [
    .allowed,
    .denied,
  ]
}

#endif  // swift(>=4.2)

public struct Server_Call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var callID: String = String()

  public var peerUid: UInt64 = 0

  public var type: Server_Call.CallType = .unknownType

  public var direction: Server_Call.CallDirection = .unknownDirection

  /// true if the call was answered
  public var answered: Bool = false

  /// true if the webrtc connects successful
  public var connected: Bool = false

  /// number of ms this call was in the in-call state
  public var durationMs: UInt64 = 0

  /// string representation of the end call reason as defined in the EndCall.Reason
  public var endCallReason: String = String()

  /// true if the end call happened locally, or false if the end call was received remotely
  public var localEndCall: Bool = false

  /// wifi or cellular
  public var networkType: Server_Call.NetworkType = .unknownNetwork

  /// json serialized version of the result of peer_connection.get_stats at the end of
  public var webrtcStats: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum CallType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case audio // = 1
    case video // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .audio
      case 2: self = .video
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .audio: return 1
      case .video: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum CallDirection: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownDirection // = 0
    case outgoing // = 1
    case incoming // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownDirection
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownDirection
      case 1: self = .outgoing
      case 2: self = .incoming
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownDirection: return 0
      case .outgoing: return 1
      case .incoming: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum NetworkType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownNetwork // = 0
    case wifi // = 1
    case cellular // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownNetwork
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownNetwork
      case 1: self = .wifi
      case 2: self = .cellular
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownNetwork: return 0
      case .wifi: return 1
      case .cellular: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_Call.CallType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Call.CallType] = [
    .unknownType,
    .audio,
    .video,
  ]
}

extension Server_Call.CallDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Call.CallDirection] = [
    .unknownDirection,
    .outgoing,
    .incoming,
  ]
}

extension Server_Call.NetworkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_Call.NetworkType] = [
    .unknownNetwork,
    .wifi,
    .cellular,
  ]
}

#endif  // swift(>=4.2)

public struct Server_FabAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Server_FabAction.FabActionType = .unknownType

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum FabActionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownType // = 0
    case gallery // = 1
    case audio // = 2
    case text // = 3
    case camera // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownType
      case 1: self = .gallery
      case 2: self = .audio
      case 3: self = .text
      case 4: self = .camera
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownType: return 0
      case .gallery: return 1
      case .audio: return 2
      case .text: return 3
      case .camera: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Server_FabAction.FabActionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Server_FabAction.FabActionType] = [
    .unknownType,
    .gallery,
    .audio,
    .text,
    .camera,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "server"

extension Server_Platform: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "IOS"),
    2: .same(proto: "ANDROID"),
  ]
}

extension Server_EventData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "platform"),
    3: .same(proto: "version"),
    4: .standard(proto: "timestamp_ms"),
    5: .same(proto: "cc"),
    10: .standard(proto: "media_upload"),
    11: .standard(proto: "media_download"),
    12: .standard(proto: "media_compose_load"),
    13: .standard(proto: "push_received"),
    14: .standard(proto: "decryption_report"),
    15: .same(proto: "permissions"),
    16: .standard(proto: "media_object_download"),
    17: .standard(proto: "group_decryption_report"),
    18: .same(proto: "call"),
    19: .standard(proto: "fab_action"),
  ]

  fileprivate class _StorageClass {
    var _uid: UInt64 = 0
    var _platform: Server_Platform = .unknown
    var _version: String = String()
    var _timestampMs: UInt64 = 0
    var _cc: String = String()
    var _edata: Server_EventData.OneOf_Edata?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _uid = source._uid
      _platform = source._platform
      _version = source._version
      _timestampMs = source._timestampMs
      _cc = source._cc
      _edata = source._edata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._uid) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._platform) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestampMs) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._cc) }()
        case 10: try {
          var v: Server_MediaUpload?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaUpload(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaUpload(v)
          }
        }()
        case 11: try {
          var v: Server_MediaDownload?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaDownload(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaDownload(v)
          }
        }()
        case 12: try {
          var v: Server_MediaComposeLoad?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaComposeLoad(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaComposeLoad(v)
          }
        }()
        case 13: try {
          var v: Server_PushReceived?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .pushReceived(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .pushReceived(v)
          }
        }()
        case 14: try {
          var v: Server_DecryptionReport?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .decryptionReport(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .decryptionReport(v)
          }
        }()
        case 15: try {
          var v: Server_Permissions?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .permissions(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .permissions(v)
          }
        }()
        case 16: try {
          var v: Server_MediaObjectDownload?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .mediaObjectDownload(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .mediaObjectDownload(v)
          }
        }()
        case 17: try {
          var v: Server_GroupDecryptionReport?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .groupDecryptionReport(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .groupDecryptionReport(v)
          }
        }()
        case 18: try {
          var v: Server_Call?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .call(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .call(v)
          }
        }()
        case 19: try {
          var v: Server_FabAction?
          var hadOneofValue = false
          if let current = _storage._edata {
            hadOneofValue = true
            if case .fabAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._edata = .fabAction(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._uid != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._uid, fieldNumber: 1)
      }
      if _storage._platform != .unknown {
        try visitor.visitSingularEnumField(value: _storage._platform, fieldNumber: 2)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 3)
      }
      if _storage._timestampMs != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._timestampMs, fieldNumber: 4)
      }
      if !_storage._cc.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cc, fieldNumber: 5)
      }
      switch _storage._edata {
      case .mediaUpload?: try {
        guard case .mediaUpload(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .mediaDownload?: try {
        guard case .mediaDownload(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .mediaComposeLoad?: try {
        guard case .mediaComposeLoad(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .pushReceived?: try {
        guard case .pushReceived(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .decryptionReport?: try {
        guard case .decryptionReport(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .permissions?: try {
        guard case .permissions(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .mediaObjectDownload?: try {
        guard case .mediaObjectDownload(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .groupDecryptionReport?: try {
        guard case .groupDecryptionReport(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .call?: try {
        guard case .call(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .fabAction?: try {
        guard case .fabAction(let v)? = _storage._edata else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_EventData, rhs: Server_EventData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._uid != rhs_storage._uid {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._timestampMs != rhs_storage._timestampMs {return false}
        if _storage._cc != rhs_storage._cc {return false}
        if _storage._edata != rhs_storage._edata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaObjectDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaObjectDownload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "index"),
    3: .same(proto: "type"),
    4: .standard(proto: "media_type"),
    5: .standard(proto: "duration_ms"),
    6: .same(proto: "size"),
    7: .standard(proto: "progress_bytes"),
    8: .same(proto: "cdn"),
    9: .standard(proto: "cdn_pop"),
    10: .standard(proto: "cdn_id"),
    11: .standard(proto: "cdn_cache"),
    12: .same(proto: "status"),
    13: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.mediaType) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.durationMs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.size) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.progressBytes) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.cdn) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.cdnPop) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.cdnID) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.cdnCache) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 13: try { try decoder.decodeSingularUInt64Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt64Field(value: self.index, fieldNumber: 2)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.mediaType != .photo {
      try visitor.visitSingularEnumField(value: self.mediaType, fieldNumber: 4)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.durationMs, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt64Field(value: self.size, fieldNumber: 6)
    }
    if self.progressBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.progressBytes, fieldNumber: 7)
    }
    if self.cdn != .unknownCdn {
      try visitor.visitSingularEnumField(value: self.cdn, fieldNumber: 8)
    }
    if !self.cdnPop.isEmpty {
      try visitor.visitSingularStringField(value: self.cdnPop, fieldNumber: 9)
    }
    if !self.cdnID.isEmpty {
      try visitor.visitSingularStringField(value: self.cdnID, fieldNumber: 10)
    }
    if self.cdnCache != .unknownCache {
      try visitor.visitSingularEnumField(value: self.cdnCache, fieldNumber: 11)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 12)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.retryCount, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaObjectDownload, rhs: Server_MediaObjectDownload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.index != rhs.index {return false}
    if lhs.type != rhs.type {return false}
    if lhs.mediaType != rhs.mediaType {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.size != rhs.size {return false}
    if lhs.progressBytes != rhs.progressBytes {return false}
    if lhs.cdn != rhs.cdn {return false}
    if lhs.cdnPop != rhs.cdnPop {return false}
    if lhs.cdnID != rhs.cdnID {return false}
    if lhs.cdnCache != rhs.cdnCache {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaObjectDownload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaObjectDownload.MediaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHOTO"),
    1: .same(proto: "VIDEO"),
    2: .same(proto: "AUDIO"),
  ]
}

extension Server_MediaObjectDownload.Cdn: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CDN"),
    1: .same(proto: "CLOUDFRONT"),
  ]
}

extension Server_MediaObjectDownload.CdnCache: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CACHE"),
    1: .same(proto: "HIT"),
    2: .same(proto: "MISS"),
    3: .same(proto: "REFRESH_HIT"),
    4: .same(proto: "REFRESH_MISS"),
  ]
}

extension Server_MediaObjectDownload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaUpload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaUpload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaUpload, rhs: Server_MediaUpload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaUpload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaUpload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaDownload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "duration_ms"),
    4: .standard(proto: "num_photos"),
    5: .standard(proto: "num_videos"),
    6: .standard(proto: "total_size"),
    7: .same(proto: "status"),
    8: .standard(proto: "retry_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.retryCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .post {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 3)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 4)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 5)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 6)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 7)
    }
    if self.retryCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.retryCount, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaDownload, rhs: Server_MediaDownload) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.status != rhs.status {return false}
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_MediaDownload.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "POST"),
    1: .same(proto: "MESSAGE"),
    2: .same(proto: "COMMENT"),
  ]
}

extension Server_MediaDownload.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_MediaComposeLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaComposeLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_ms"),
    2: .standard(proto: "num_photos"),
    3: .standard(proto: "num_videos"),
    4: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.durationMs) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numPhotos) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numVideos) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationMs != 0 {
      try visitor.visitSingularUInt32Field(value: self.durationMs, fieldNumber: 1)
    }
    if self.numPhotos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPhotos, fieldNumber: 2)
    }
    if self.numVideos != 0 {
      try visitor.visitSingularUInt32Field(value: self.numVideos, fieldNumber: 3)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_MediaComposeLoad, rhs: Server_MediaComposeLoad) -> Bool {
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.numPhotos != rhs.numPhotos {return false}
    if lhs.numVideos != rhs.numVideos {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_PushReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushReceived"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "client_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.clientTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.clientTimestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.clientTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_PushReceived, rhs: Server_PushReceived) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.clientTimestamp != rhs.clientTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DecryptionReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptionReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "msg_id"),
    4: .standard(proto: "original_version"),
    5: .standard(proto: "sender_platform"),
    6: .standard(proto: "sender_version"),
    7: .standard(proto: "rerequest_count"),
    8: .standard(proto: "time_taken_s"),
    9: .standard(proto: "is_silent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.msgID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.originalVersion) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.senderPlatform) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.senderVersion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.rerequestCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.timeTakenS) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isSilent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .ok {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularStringField(value: self.msgID, fieldNumber: 3)
    }
    if !self.originalVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.originalVersion, fieldNumber: 4)
    }
    if self.senderPlatform != .unknown {
      try visitor.visitSingularEnumField(value: self.senderPlatform, fieldNumber: 5)
    }
    if !self.senderVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderVersion, fieldNumber: 6)
    }
    if self.rerequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rerequestCount, fieldNumber: 7)
    }
    if self.timeTakenS != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTakenS, fieldNumber: 8)
    }
    if self.isSilent != false {
      try visitor.visitSingularBoolField(value: self.isSilent, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_DecryptionReport, rhs: Server_DecryptionReport) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.originalVersion != rhs.originalVersion {return false}
    if lhs.senderPlatform != rhs.senderPlatform {return false}
    if lhs.senderVersion != rhs.senderVersion {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs.timeTakenS != rhs.timeTakenS {return false}
    if lhs.isSilent != rhs.isSilent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_DecryptionReport.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "FAIL"),
  ]
}

extension Server_GroupDecryptionReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupDecryptionReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "reason"),
    3: .standard(proto: "content_id"),
    4: .same(proto: "gid"),
    5: .standard(proto: "item_type"),
    6: .standard(proto: "original_version"),
    7: .standard(proto: "rerequest_count"),
    8: .standard(proto: "time_taken_s"),
    9: .standard(proto: "sender_platform"),
    10: .standard(proto: "sender_version"),
    11: .same(proto: "schedule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.contentID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gid) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.itemType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.originalVersion) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.rerequestCount) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.timeTakenS) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.senderPlatform) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.senderVersion) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.schedule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknownStatus {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.contentID.isEmpty {
      try visitor.visitSingularStringField(value: self.contentID, fieldNumber: 3)
    }
    if !self.gid.isEmpty {
      try visitor.visitSingularStringField(value: self.gid, fieldNumber: 4)
    }
    if self.itemType != .unknownType {
      try visitor.visitSingularEnumField(value: self.itemType, fieldNumber: 5)
    }
    if !self.originalVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.originalVersion, fieldNumber: 6)
    }
    if self.rerequestCount != 0 {
      try visitor.visitSingularUInt32Field(value: self.rerequestCount, fieldNumber: 7)
    }
    if self.timeTakenS != 0 {
      try visitor.visitSingularUInt32Field(value: self.timeTakenS, fieldNumber: 8)
    }
    if self.senderPlatform != .unknown {
      try visitor.visitSingularEnumField(value: self.senderPlatform, fieldNumber: 9)
    }
    if !self.senderVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.senderVersion, fieldNumber: 10)
    }
    if self.schedule != .daily {
      try visitor.visitSingularEnumField(value: self.schedule, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_GroupDecryptionReport, rhs: Server_GroupDecryptionReport) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.contentID != rhs.contentID {return false}
    if lhs.gid != rhs.gid {return false}
    if lhs.itemType != rhs.itemType {return false}
    if lhs.originalVersion != rhs.originalVersion {return false}
    if lhs.rerequestCount != rhs.rerequestCount {return false}
    if lhs.timeTakenS != rhs.timeTakenS {return false}
    if lhs.senderPlatform != rhs.senderPlatform {return false}
    if lhs.senderVersion != rhs.senderVersion {return false}
    if lhs.schedule != rhs.schedule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_GroupDecryptionReport.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_STATUS"),
    1: .same(proto: "OK"),
    2: .same(proto: "FAIL"),
  ]
}

extension Server_GroupDecryptionReport.ItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "POST"),
    2: .same(proto: "COMMENT"),
    3: .same(proto: "HISTORY_RESEND"),
  ]
}

extension Server_GroupDecryptionReport.Schedule: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DAILY"),
    1: .same(proto: "RESULT_BASED"),
  ]
}

extension Server_Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .contacts {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.status != .allowed {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Permissions, rhs: Server_Permissions) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Permissions.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTACTS"),
    1: .same(proto: "NOTIFICATIONS"),
  ]
}

extension Server_Permissions.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOWED"),
    1: .same(proto: "DENIED"),
  ]
}

extension Server_Call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Call"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_id"),
    2: .standard(proto: "peer_uid"),
    3: .same(proto: "type"),
    4: .same(proto: "direction"),
    5: .same(proto: "answered"),
    6: .same(proto: "connected"),
    7: .standard(proto: "duration_ms"),
    9: .standard(proto: "end_call_reason"),
    10: .standard(proto: "local_end_call"),
    11: .standard(proto: "network_type"),
    20: .standard(proto: "webrtc_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.callID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.peerUid) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.answered) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.connected) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.durationMs) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.endCallReason) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.localEndCall) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.networkType) }()
      case 20: try { try decoder.decodeSingularStringField(value: &self.webrtcStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.callID.isEmpty {
      try visitor.visitSingularStringField(value: self.callID, fieldNumber: 1)
    }
    if self.peerUid != 0 {
      try visitor.visitSingularUInt64Field(value: self.peerUid, fieldNumber: 2)
    }
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if self.direction != .unknownDirection {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 4)
    }
    if self.answered != false {
      try visitor.visitSingularBoolField(value: self.answered, fieldNumber: 5)
    }
    if self.connected != false {
      try visitor.visitSingularBoolField(value: self.connected, fieldNumber: 6)
    }
    if self.durationMs != 0 {
      try visitor.visitSingularUInt64Field(value: self.durationMs, fieldNumber: 7)
    }
    if !self.endCallReason.isEmpty {
      try visitor.visitSingularStringField(value: self.endCallReason, fieldNumber: 9)
    }
    if self.localEndCall != false {
      try visitor.visitSingularBoolField(value: self.localEndCall, fieldNumber: 10)
    }
    if self.networkType != .unknownNetwork {
      try visitor.visitSingularEnumField(value: self.networkType, fieldNumber: 11)
    }
    if !self.webrtcStats.isEmpty {
      try visitor.visitSingularStringField(value: self.webrtcStats, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_Call, rhs: Server_Call) -> Bool {
    if lhs.callID != rhs.callID {return false}
    if lhs.peerUid != rhs.peerUid {return false}
    if lhs.type != rhs.type {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.answered != rhs.answered {return false}
    if lhs.connected != rhs.connected {return false}
    if lhs.durationMs != rhs.durationMs {return false}
    if lhs.endCallReason != rhs.endCallReason {return false}
    if lhs.localEndCall != rhs.localEndCall {return false}
    if lhs.networkType != rhs.networkType {return false}
    if lhs.webrtcStats != rhs.webrtcStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_Call.CallType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "AUDIO"),
    2: .same(proto: "VIDEO"),
  ]
}

extension Server_Call.CallDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_DIRECTION"),
    1: .same(proto: "OUTGOING"),
    2: .same(proto: "INCOMING"),
  ]
}

extension Server_Call.NetworkType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_NETWORK"),
    1: .same(proto: "WIFI"),
    2: .same(proto: "CELLULAR"),
  ]
}

extension Server_FabAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FabAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Server_FabAction, rhs: Server_FabAction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Server_FabAction.FabActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TYPE"),
    1: .same(proto: "GALLERY"),
    2: .same(proto: "AUDIO"),
    3: .same(proto: "TEXT"),
    4: .same(proto: "CAMERA"),
  ]
}
