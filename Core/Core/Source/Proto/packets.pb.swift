// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: packets.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PBchat_stanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var encPayload: Data = SwiftProtobuf.Internal.emptyData

  /// Temporarily added two payloads: one is for unecrypted and the other is encrypted.
  /// Clients currently send both of them at times.
  public var publicKey: Data = SwiftProtobuf.Internal.emptyData

  public var oneTimePreKeyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBerror_stanza {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBname {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBiq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: PBiq.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var uploadMedia: PBupload_media {
    get {
      if case .uploadMedia(let v)? = _storage._payload {return v}
      return PBupload_media()
    }
    set {_uniqueStorage()._payload = .uploadMedia(newValue)}
  }

  public var contactList: PBcontact_list {
    get {
      if case .contactList(let v)? = _storage._payload {return v}
      return PBcontact_list()
    }
    set {_uniqueStorage()._payload = .contactList(newValue)}
  }

  public var uploadAvatar: PBupload_avatar {
    get {
      if case .uploadAvatar(let v)? = _storage._payload {return v}
      return PBupload_avatar()
    }
    set {_uniqueStorage()._payload = .uploadAvatar(newValue)}
  }

  public var avatar: PBavatar {
    get {
      if case .avatar(let v)? = _storage._payload {return v}
      return PBavatar()
    }
    set {_uniqueStorage()._payload = .avatar(newValue)}
  }

  public var avatars: PBavatars {
    get {
      if case .avatars(let v)? = _storage._payload {return v}
      return PBavatars()
    }
    set {_uniqueStorage()._payload = .avatars(newValue)}
  }

  public var clientMode: PBclient_mode {
    get {
      if case .clientMode(let v)? = _storage._payload {return v}
      return PBclient_mode()
    }
    set {_uniqueStorage()._payload = .clientMode(newValue)}
  }

  public var clientVersion: PBclient_version {
    get {
      if case .clientVersion(let v)? = _storage._payload {return v}
      return PBclient_version()
    }
    set {_uniqueStorage()._payload = .clientVersion(newValue)}
  }

  public var pushRegister: PBpush_register {
    get {
      if case .pushRegister(let v)? = _storage._payload {return v}
      return PBpush_register()
    }
    set {_uniqueStorage()._payload = .pushRegister(newValue)}
  }

  public var whisperKeys: PBwhisper_keys {
    get {
      if case .whisperKeys(let v)? = _storage._payload {return v}
      return PBwhisper_keys()
    }
    set {_uniqueStorage()._payload = .whisperKeys(newValue)}
  }

  public var ping: PBping {
    get {
      if case .ping(let v)? = _storage._payload {return v}
      return PBping()
    }
    set {_uniqueStorage()._payload = .ping(newValue)}
  }

  public var feedItem: PBfeed_item {
    get {
      if case .feedItem(let v)? = _storage._payload {return v}
      return PBfeed_item()
    }
    set {_uniqueStorage()._payload = .feedItem(newValue)}
  }

  public var privacyList: PBprivacy_list {
    get {
      if case .privacyList(let v)? = _storage._payload {return v}
      return PBprivacy_list()
    }
    set {_uniqueStorage()._payload = .privacyList(newValue)}
  }

  public var privacyListResult: PBprivacy_list_result {
    get {
      if case .privacyListResult(let v)? = _storage._payload {return v}
      return PBprivacy_list_result()
    }
    set {_uniqueStorage()._payload = .privacyListResult(newValue)}
  }

  public var privacyLists: PBprivacy_lists {
    get {
      if case .privacyLists(let v)? = _storage._payload {return v}
      return PBprivacy_lists()
    }
    set {_uniqueStorage()._payload = .privacyLists(newValue)}
  }

  public var groupStanza: PBgroup_stanza {
    get {
      if case .groupStanza(let v)? = _storage._payload {return v}
      return PBgroup_stanza()
    }
    set {_uniqueStorage()._payload = .groupStanza(newValue)}
  }

  public var groupsStanza: PBgroups_stanza {
    get {
      if case .groupsStanza(let v)? = _storage._payload {return v}
      return PBgroups_stanza()
    }
    set {_uniqueStorage()._payload = .groupsStanza(newValue)}
  }

  public var clientLog: PBclient_log {
    get {
      if case .clientLog(let v)? = _storage._payload {return v}
      return PBclient_log()
    }
    set {_uniqueStorage()._payload = .clientLog(newValue)}
  }

  public var name: PBname {
    get {
      if case .name(let v)? = _storage._payload {return v}
      return PBname()
    }
    set {_uniqueStorage()._payload = .name(newValue)}
  }

  public var errorStanza: PBerror_stanza {
    get {
      if case .errorStanza(let v)? = _storage._payload {return v}
      return PBerror_stanza()
    }
    set {_uniqueStorage()._payload = .errorStanza(newValue)}
  }

  public var props: PBprops {
    get {
      if case .props(let v)? = _storage._payload {return v}
      return PBprops()
    }
    set {_uniqueStorage()._payload = .props(newValue)}
  }

  public var invitesRequest: PBinvites_request {
    get {
      if case .invitesRequest(let v)? = _storage._payload {return v}
      return PBinvites_request()
    }
    set {_uniqueStorage()._payload = .invitesRequest(newValue)}
  }

  public var invitesResponse: PBinvites_response {
    get {
      if case .invitesResponse(let v)? = _storage._payload {return v}
      return PBinvites_response()
    }
    set {_uniqueStorage()._payload = .invitesResponse(newValue)}
  }

  public var notificationPrefs: PBnotification_prefs {
    get {
      if case .notificationPrefs(let v)? = _storage._payload {return v}
      return PBnotification_prefs()
    }
    set {_uniqueStorage()._payload = .notificationPrefs(newValue)}
  }

  public var groupFeedItem: PBgroup_feed_item {
    get {
      if case .groupFeedItem(let v)? = _storage._payload {return v}
      return PBgroup_feed_item()
    }
    set {_uniqueStorage()._payload = .groupFeedItem(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case uploadMedia(PBupload_media)
    case contactList(PBcontact_list)
    case uploadAvatar(PBupload_avatar)
    case avatar(PBavatar)
    case avatars(PBavatars)
    case clientMode(PBclient_mode)
    case clientVersion(PBclient_version)
    case pushRegister(PBpush_register)
    case whisperKeys(PBwhisper_keys)
    case ping(PBping)
    case feedItem(PBfeed_item)
    case privacyList(PBprivacy_list)
    case privacyListResult(PBprivacy_list_result)
    case privacyLists(PBprivacy_lists)
    case groupStanza(PBgroup_stanza)
    case groupsStanza(PBgroups_stanza)
    case clientLog(PBclient_log)
    case name(PBname)
    case errorStanza(PBerror_stanza)
    case props(PBprops)
    case invitesRequest(PBinvites_request)
    case invitesResponse(PBinvites_response)
    case notificationPrefs(PBnotification_prefs)
    case groupFeedItem(PBgroup_feed_item)

  #if !swift(>=4.1)
    public static func ==(lhs: PBiq.OneOf_Payload, rhs: PBiq.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.uploadMedia(let l), .uploadMedia(let r)): return l == r
      case (.contactList(let l), .contactList(let r)): return l == r
      case (.uploadAvatar(let l), .uploadAvatar(let r)): return l == r
      case (.avatar(let l), .avatar(let r)): return l == r
      case (.avatars(let l), .avatars(let r)): return l == r
      case (.clientMode(let l), .clientMode(let r)): return l == r
      case (.clientVersion(let l), .clientVersion(let r)): return l == r
      case (.pushRegister(let l), .pushRegister(let r)): return l == r
      case (.whisperKeys(let l), .whisperKeys(let r)): return l == r
      case (.ping(let l), .ping(let r)): return l == r
      case (.feedItem(let l), .feedItem(let r)): return l == r
      case (.privacyList(let l), .privacyList(let r)): return l == r
      case (.privacyListResult(let l), .privacyListResult(let r)): return l == r
      case (.privacyLists(let l), .privacyLists(let r)): return l == r
      case (.groupStanza(let l), .groupStanza(let r)): return l == r
      case (.groupsStanza(let l), .groupsStanza(let r)): return l == r
      case (.clientLog(let l), .clientLog(let r)): return l == r
      case (.name(let l), .name(let r)): return l == r
      case (.errorStanza(let l), .errorStanza(let r)): return l == r
      case (.props(let l), .props(let r)): return l == r
      case (.invitesRequest(let l), .invitesRequest(let r)): return l == r
      case (.invitesResponse(let l), .invitesResponse(let r)): return l == r
      case (.notificationPrefs(let l), .notificationPrefs(let r)): return l == r
      case (.groupFeedItem(let l), .groupFeedItem(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case set // = 1
    case result // = 2
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .set
      case 2: self = .result
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .set: return 1
      case .result: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension PBiq.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBiq.TypeEnum] = [
    .get,
    .set,
    .result,
    .error,
  ]
}

#endif  // swift(>=4.2)

public struct PBmsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var type: PBmsg.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var toUid: Int64 {
    get {return _storage._toUid}
    set {_uniqueStorage()._toUid = newValue}
  }

  public var fromUid: Int64 {
    get {return _storage._fromUid}
    set {_uniqueStorage()._fromUid = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var contactList: PBcontact_list {
    get {
      if case .contactList(let v)? = _storage._payload {return v}
      return PBcontact_list()
    }
    set {_uniqueStorage()._payload = .contactList(newValue)}
  }

  public var avatar: PBavatar {
    get {
      if case .avatar(let v)? = _storage._payload {return v}
      return PBavatar()
    }
    set {_uniqueStorage()._payload = .avatar(newValue)}
  }

  public var whisperKeys: PBwhisper_keys {
    get {
      if case .whisperKeys(let v)? = _storage._payload {return v}
      return PBwhisper_keys()
    }
    set {_uniqueStorage()._payload = .whisperKeys(newValue)}
  }

  public var seenReceipt: PBseen_receipt {
    get {
      if case .seenReceipt(let v)? = _storage._payload {return v}
      return PBseen_receipt()
    }
    set {_uniqueStorage()._payload = .seenReceipt(newValue)}
  }

  public var deliveryReceipt: PBdelivery_receipt {
    get {
      if case .deliveryReceipt(let v)? = _storage._payload {return v}
      return PBdelivery_receipt()
    }
    set {_uniqueStorage()._payload = .deliveryReceipt(newValue)}
  }

  public var chatStanza: PBchat_stanza {
    get {
      if case .chatStanza(let v)? = _storage._payload {return v}
      return PBchat_stanza()
    }
    set {_uniqueStorage()._payload = .chatStanza(newValue)}
  }

  public var feedItem: PBfeed_item {
    get {
      if case .feedItem(let v)? = _storage._payload {return v}
      return PBfeed_item()
    }
    set {_uniqueStorage()._payload = .feedItem(newValue)}
  }

  public var feedItems: PBfeed_items {
    get {
      if case .feedItems(let v)? = _storage._payload {return v}
      return PBfeed_items()
    }
    set {_uniqueStorage()._payload = .feedItems(newValue)}
  }

  public var contactHash: PBcontact_hash {
    get {
      if case .contactHash(let v)? = _storage._payload {return v}
      return PBcontact_hash()
    }
    set {_uniqueStorage()._payload = .contactHash(newValue)}
  }

  public var groupStanza: PBgroup_stanza {
    get {
      if case .groupStanza(let v)? = _storage._payload {return v}
      return PBgroup_stanza()
    }
    set {_uniqueStorage()._payload = .groupStanza(newValue)}
  }

  public var groupChat: PBgroup_chat {
    get {
      if case .groupChat(let v)? = _storage._payload {return v}
      return PBgroup_chat()
    }
    set {_uniqueStorage()._payload = .groupChat(newValue)}
  }

  public var name: PBname {
    get {
      if case .name(let v)? = _storage._payload {return v}
      return PBname()
    }
    set {_uniqueStorage()._payload = .name(newValue)}
  }

  public var errorStanza: PBerror_stanza {
    get {
      if case .errorStanza(let v)? = _storage._payload {return v}
      return PBerror_stanza()
    }
    set {_uniqueStorage()._payload = .errorStanza(newValue)}
  }

  public var groupchatRetract: PBgroupchat_retract {
    get {
      if case .groupchatRetract(let v)? = _storage._payload {return v}
      return PBgroupchat_retract()
    }
    set {_uniqueStorage()._payload = .groupchatRetract(newValue)}
  }

  public var chatRetract: PBchat_retract {
    get {
      if case .chatRetract(let v)? = _storage._payload {return v}
      return PBchat_retract()
    }
    set {_uniqueStorage()._payload = .chatRetract(newValue)}
  }

  public var groupFeedItem: PBgroup_feed_item {
    get {
      if case .groupFeedItem(let v)? = _storage._payload {return v}
      return PBgroup_feed_item()
    }
    set {_uniqueStorage()._payload = .groupFeedItem(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case contactList(PBcontact_list)
    case avatar(PBavatar)
    case whisperKeys(PBwhisper_keys)
    case seenReceipt(PBseen_receipt)
    case deliveryReceipt(PBdelivery_receipt)
    case chatStanza(PBchat_stanza)
    case feedItem(PBfeed_item)
    case feedItems(PBfeed_items)
    case contactHash(PBcontact_hash)
    case groupStanza(PBgroup_stanza)
    case groupChat(PBgroup_chat)
    case name(PBname)
    case errorStanza(PBerror_stanza)
    case groupchatRetract(PBgroupchat_retract)
    case chatRetract(PBchat_retract)
    case groupFeedItem(PBgroup_feed_item)

  #if !swift(>=4.1)
    public static func ==(lhs: PBmsg.OneOf_Payload, rhs: PBmsg.OneOf_Payload) -> Bool {
      switch (lhs, rhs) {
      case (.contactList(let l), .contactList(let r)): return l == r
      case (.avatar(let l), .avatar(let r)): return l == r
      case (.whisperKeys(let l), .whisperKeys(let r)): return l == r
      case (.seenReceipt(let l), .seenReceipt(let r)): return l == r
      case (.deliveryReceipt(let l), .deliveryReceipt(let r)): return l == r
      case (.chatStanza(let l), .chatStanza(let r)): return l == r
      case (.feedItem(let l), .feedItem(let r)): return l == r
      case (.feedItems(let l), .feedItems(let r)): return l == r
      case (.contactHash(let l), .contactHash(let r)): return l == r
      case (.groupStanza(let l), .groupStanza(let r)): return l == r
      case (.groupChat(let l), .groupChat(let r)): return l == r
      case (.name(let l), .name(let r)): return l == r
      case (.errorStanza(let l), .errorStanza(let r)): return l == r
      case (.groupchatRetract(let l), .groupchatRetract(let r)): return l == r
      case (.chatRetract(let l), .chatRetract(let r)): return l == r
      case (.groupFeedItem(let l), .groupFeedItem(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case error // = 1
    case groupchat // = 2
    case headline // = 3

    /// Not used yet.
    case chat // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .error
      case 2: self = .groupchat
      case 3: self = .headline
      case 4: self = .chat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .error: return 1
      case .groupchat: return 2
      case .headline: return 3
      case .chat: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension PBmsg.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBmsg.TypeEnum] = [
    .normal,
    .error,
    .groupchat,
    .headline,
    .chat,
  ]
}

#endif  // swift(>=4.2)

public struct PBpresence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: PBpresence.TypeEnum = .available

  public var uid: Int64 = 0

  public var lastSeen: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case away // = 1
    case subscribe // = 2
    case unsubscribe // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .away
      case 2: self = .subscribe
      case 3: self = .unsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .away: return 1
      case .subscribe: return 2
      case .unsubscribe: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension PBpresence.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBpresence.TypeEnum] = [
    .available,
    .away,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct PBchat_state {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: PBchat_state.TypeEnum = .available

  public var threadID: String = String()

  public var threadType: PBchat_state.ThreadType = .chat

  public var fromUid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case typing // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .typing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .typing: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ThreadType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case groupChat // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .groupChat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .groupChat: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension PBchat_state.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBchat_state.TypeEnum] = [
    .available,
    .typing,
  ]
}

extension PBchat_state.ThreadType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBchat_state.ThreadType] = [
    .chat,
    .groupChat,
  ]
}

#endif  // swift(>=4.2)

public struct PBack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBha_error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBpacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stanza: PBpacket.OneOf_Stanza? = nil

  public var msg: PBmsg {
    get {
      if case .msg(let v)? = stanza {return v}
      return PBmsg()
    }
    set {stanza = .msg(newValue)}
  }

  public var iq: PBiq {
    get {
      if case .iq(let v)? = stanza {return v}
      return PBiq()
    }
    set {stanza = .iq(newValue)}
  }

  public var ack: PBack {
    get {
      if case .ack(let v)? = stanza {return v}
      return PBack()
    }
    set {stanza = .ack(newValue)}
  }

  public var presence: PBpresence {
    get {
      if case .presence(let v)? = stanza {return v}
      return PBpresence()
    }
    set {stanza = .presence(newValue)}
  }

  public var haError: PBha_error {
    get {
      if case .haError(let v)? = stanza {return v}
      return PBha_error()
    }
    set {stanza = .haError(newValue)}
  }

  public var chatState: PBchat_state {
    get {
      if case .chatState(let v)? = stanza {return v}
      return PBchat_state()
    }
    set {stanza = .chatState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Stanza: Equatable {
    case msg(PBmsg)
    case iq(PBiq)
    case ack(PBack)
    case presence(PBpresence)
    case haError(PBha_error)
    case chatState(PBchat_state)

  #if !swift(>=4.1)
    public static func ==(lhs: PBpacket.OneOf_Stanza, rhs: PBpacket.OneOf_Stanza) -> Bool {
      switch (lhs, rhs) {
      case (.msg(let l), .msg(let r)): return l == r
      case (.iq(let l), .iq(let r)): return l == r
      case (.ack(let l), .ack(let r)): return l == r
      case (.presence(let l), .presence(let r)): return l == r
      case (.haError(let l), .haError(let r)): return l == r
      case (.chatState(let l), .chatState(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PBchat_stanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "chat_stanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "payload"),
    3: .standard(proto: "enc_payload"),
    4: .standard(proto: "public_key"),
    5: .standard(proto: "one_time_pre_key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.payload)
      case 3: try decoder.decodeSingularBytesField(value: &self.encPayload)
      case 4: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 5: try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 3)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 4)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBchat_stanza, rhs: PBchat_stanza) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBping, rhs: PBping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBerror_stanza: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "error_stanza"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBerror_stanza, rhs: PBerror_stanza) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBname: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBname, rhs: PBname) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBiq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "iq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "upload_media"),
    4: .standard(proto: "contact_list"),
    5: .standard(proto: "upload_avatar"),
    6: .same(proto: "avatar"),
    7: .same(proto: "avatars"),
    8: .standard(proto: "client_mode"),
    9: .standard(proto: "client_version"),
    10: .standard(proto: "push_register"),
    11: .standard(proto: "whisper_keys"),
    12: .same(proto: "ping"),
    13: .standard(proto: "feed_item"),
    14: .standard(proto: "privacy_list"),
    15: .standard(proto: "privacy_list_result"),
    16: .standard(proto: "privacy_lists"),
    17: .standard(proto: "group_stanza"),
    18: .standard(proto: "groups_stanza"),
    19: .standard(proto: "client_log"),
    20: .same(proto: "name"),
    21: .standard(proto: "error_stanza"),
    22: .same(proto: "props"),
    23: .standard(proto: "invites_request"),
    24: .standard(proto: "invites_response"),
    25: .standard(proto: "notification_prefs"),
    26: .standard(proto: "group_feed_item"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: PBiq.TypeEnum = .get
    var _payload: PBiq.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3:
          var v: PBupload_media?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .uploadMedia(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .uploadMedia(v)}
        case 4:
          var v: PBcontact_list?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .contactList(v)}
        case 5:
          var v: PBupload_avatar?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .uploadAvatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .uploadAvatar(v)}
        case 6:
          var v: PBavatar?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .avatar(v)}
        case 7:
          var v: PBavatars?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .avatars(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .avatars(v)}
        case 8:
          var v: PBclient_mode?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .clientMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .clientMode(v)}
        case 9:
          var v: PBclient_version?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .clientVersion(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .clientVersion(v)}
        case 10:
          var v: PBpush_register?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .pushRegister(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .pushRegister(v)}
        case 11:
          var v: PBwhisper_keys?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .whisperKeys(v)}
        case 12:
          var v: PBping?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .ping(v)}
        case 13:
          var v: PBfeed_item?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .feedItem(v)}
        case 14:
          var v: PBprivacy_list?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .privacyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .privacyList(v)}
        case 15:
          var v: PBprivacy_list_result?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .privacyListResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .privacyListResult(v)}
        case 16:
          var v: PBprivacy_lists?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .privacyLists(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .privacyLists(v)}
        case 17:
          var v: PBgroup_stanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupStanza(v)}
        case 18:
          var v: PBgroups_stanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupsStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupsStanza(v)}
        case 19:
          var v: PBclient_log?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .clientLog(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .clientLog(v)}
        case 20:
          var v: PBname?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .name(v)}
        case 21:
          var v: PBerror_stanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .errorStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .errorStanza(v)}
        case 22:
          var v: PBprops?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .props(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .props(v)}
        case 23:
          var v: PBinvites_request?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .invitesRequest(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .invitesRequest(v)}
        case 24:
          var v: PBinvites_response?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .invitesResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .invitesResponse(v)}
        case 25:
          var v: PBnotification_prefs?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .notificationPrefs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .notificationPrefs(v)}
        case 26:
          var v: PBgroup_feed_item?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupFeedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupFeedItem(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .get {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      switch _storage._payload {
      case .uploadMedia(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .contactList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .uploadAvatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .avatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .avatars(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .clientMode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .clientVersion(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .pushRegister(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .whisperKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .ping(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .feedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .privacyList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .privacyListResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .privacyLists(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .groupStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .groupsStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .clientLog(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .name(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case .errorStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      case .props(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      case .invitesRequest(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      case .invitesResponse(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      case .notificationPrefs(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      case .groupFeedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBiq, rhs: PBiq) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBiq.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "get"),
    1: .same(proto: "set"),
    2: .same(proto: "result"),
    3: .same(proto: "error"),
  ]
}

extension PBmsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "msg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "to_uid"),
    4: .standard(proto: "from_uid"),
    5: .standard(proto: "contact_list"),
    6: .same(proto: "avatar"),
    7: .standard(proto: "whisper_keys"),
    8: .standard(proto: "seen_receipt"),
    9: .standard(proto: "delivery_receipt"),
    10: .standard(proto: "chat_stanza"),
    11: .standard(proto: "feed_item"),
    12: .standard(proto: "feed_items"),
    13: .standard(proto: "contact_hash"),
    14: .standard(proto: "group_stanza"),
    15: .standard(proto: "group_chat"),
    16: .same(proto: "name"),
    17: .standard(proto: "error_stanza"),
    18: .standard(proto: "groupchat_retract"),
    19: .standard(proto: "chat_retract"),
    20: .standard(proto: "group_feed_item"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _type: PBmsg.TypeEnum = .normal
    var _toUid: Int64 = 0
    var _fromUid: Int64 = 0
    var _payload: PBmsg.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _toUid = source._toUid
      _fromUid = source._fromUid
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._id)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._toUid)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._fromUid)
        case 5:
          var v: PBcontact_list?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .contactList(v)}
        case 6:
          var v: PBavatar?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .avatar(v)}
        case 7:
          var v: PBwhisper_keys?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .whisperKeys(v)}
        case 8:
          var v: PBseen_receipt?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .seenReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .seenReceipt(v)}
        case 9:
          var v: PBdelivery_receipt?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .deliveryReceipt(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .deliveryReceipt(v)}
        case 10:
          var v: PBchat_stanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .chatStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .chatStanza(v)}
        case 11:
          var v: PBfeed_item?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .feedItem(v)}
        case 12:
          var v: PBfeed_items?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .feedItems(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .feedItems(v)}
        case 13:
          var v: PBcontact_hash?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .contactHash(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .contactHash(v)}
        case 14:
          var v: PBgroup_stanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupStanza(v)}
        case 15:
          var v: PBgroup_chat?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupChat(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupChat(v)}
        case 16:
          var v: PBname?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .name(v)}
        case 17:
          var v: PBerror_stanza?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .errorStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .errorStanza(v)}
        case 18:
          var v: PBgroupchat_retract?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupchatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupchatRetract(v)}
        case 19:
          var v: PBchat_retract?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .chatRetract(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .chatRetract(v)}
        case 20:
          var v: PBgroup_feed_item?
          if let current = _storage._payload {
            try decoder.handleConflictingOneOf()
            if case .groupFeedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payload = .groupFeedItem(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._toUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._toUid, fieldNumber: 3)
      }
      if _storage._fromUid != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fromUid, fieldNumber: 4)
      }
      switch _storage._payload {
      case .contactList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .avatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .whisperKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .seenReceipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .deliveryReceipt(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .chatStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .feedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .feedItems(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .contactHash(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .groupStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .groupChat(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .name(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .errorStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .groupchatRetract(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case .chatRetract(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      case .groupFeedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBmsg, rhs: PBmsg) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._toUid != rhs_storage._toUid {return false}
        if _storage._fromUid != rhs_storage._fromUid {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBmsg.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "normal"),
    1: .same(proto: "error"),
    2: .same(proto: "groupchat"),
    3: .same(proto: "headline"),
    4: .same(proto: "chat"),
  ]
}

extension PBpresence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "presence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "uid"),
    4: .standard(proto: "last_seen"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 4: try decoder.decodeSingularInt64Field(value: &self.lastSeen)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 3)
    }
    if self.lastSeen != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeen, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBpresence, rhs: PBpresence) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.lastSeen != rhs.lastSeen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBpresence.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "available"),
    1: .same(proto: "away"),
    2: .same(proto: "subscribe"),
    3: .same(proto: "unsubscribe"),
  ]
}

extension PBchat_state: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "chat_state"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "thread_id"),
    3: .standard(proto: "thread_type"),
    4: .standard(proto: "from_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.threadID)
      case 3: try decoder.decodeSingularEnumField(value: &self.threadType)
      case 4: try decoder.decodeSingularInt64Field(value: &self.fromUid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.threadType != .chat {
      try visitor.visitSingularEnumField(value: self.threadType, fieldNumber: 3)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBchat_state, rhs: PBchat_state) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.threadType != rhs.threadType {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBchat_state.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "available"),
    1: .same(proto: "typing"),
  ]
}

extension PBchat_state.ThreadType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "chat"),
    1: .same(proto: "group_chat"),
  ]
}

extension PBack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBack, rhs: PBack) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBha_error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ha_error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBha_error, rhs: PBha_error) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBpacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "packet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "iq"),
    3: .same(proto: "ack"),
    4: .same(proto: "presence"),
    5: .standard(proto: "ha_error"),
    6: .standard(proto: "chat_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: PBmsg?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .msg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .msg(v)}
      case 2:
        var v: PBiq?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .iq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .iq(v)}
      case 3:
        var v: PBack?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .ack(v)}
      case 4:
        var v: PBpresence?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .presence(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .presence(v)}
      case 5:
        var v: PBha_error?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .haError(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .haError(v)}
      case 6:
        var v: PBchat_state?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .chatState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .chatState(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.stanza {
    case .msg(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .iq(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .ack(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .presence(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .haError(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .chatState(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBpacket, rhs: PBpacket) -> Bool {
    if lhs.stanza != rhs.stanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
