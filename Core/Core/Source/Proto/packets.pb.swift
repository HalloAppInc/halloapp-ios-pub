// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: packets.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct PBchat {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timestamp: Int64 = 0

  public var payload: Data = SwiftProtobuf.Internal.emptyData

  public var encPayload: Data = SwiftProtobuf.Internal.emptyData

  /// Temporarily added two payloads: one is for unecrypted and the other is encrypted.
  /// Clients currently send both of them at times.
  public var publicKey: Data = SwiftProtobuf.Internal.emptyData

  public var oneTimePreKeyID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBping {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBname {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uid: Int64 = 0

  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBiq_payload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: OneOf_Content? {
    get {return _storage._content}
    set {_uniqueStorage()._content = newValue}
  }

  public var uploadMedia: PBupload_media {
    get {
      if case .uploadMedia(let v)? = _storage._content {return v}
      return PBupload_media()
    }
    set {_uniqueStorage()._content = .uploadMedia(newValue)}
  }

  public var contactList: PBcontact_list {
    get {
      if case .contactList(let v)? = _storage._content {return v}
      return PBcontact_list()
    }
    set {_uniqueStorage()._content = .contactList(newValue)}
  }

  public var uploadAvatar: PBupload_avatar {
    get {
      if case .uploadAvatar(let v)? = _storage._content {return v}
      return PBupload_avatar()
    }
    set {_uniqueStorage()._content = .uploadAvatar(newValue)}
  }

  public var avatar: PBavatar {
    get {
      if case .avatar(let v)? = _storage._content {return v}
      return PBavatar()
    }
    set {_uniqueStorage()._content = .avatar(newValue)}
  }

  public var avatars: PBavatars {
    get {
      if case .avatars(let v)? = _storage._content {return v}
      return PBavatars()
    }
    set {_uniqueStorage()._content = .avatars(newValue)}
  }

  public var clientMode: PBclient_mode {
    get {
      if case .clientMode(let v)? = _storage._content {return v}
      return PBclient_mode()
    }
    set {_uniqueStorage()._content = .clientMode(newValue)}
  }

  public var clientVersion: PBclient_version {
    get {
      if case .clientVersion(let v)? = _storage._content {return v}
      return PBclient_version()
    }
    set {_uniqueStorage()._content = .clientVersion(newValue)}
  }

  public var pushRegister: PBpush_register {
    get {
      if case .pushRegister(let v)? = _storage._content {return v}
      return PBpush_register()
    }
    set {_uniqueStorage()._content = .pushRegister(newValue)}
  }

  public var whisperKeys: PBwhisper_keys {
    get {
      if case .whisperKeys(let v)? = _storage._content {return v}
      return PBwhisper_keys()
    }
    set {_uniqueStorage()._content = .whisperKeys(newValue)}
  }

  public var ping: PBping {
    get {
      if case .ping(let v)? = _storage._content {return v}
      return PBping()
    }
    set {_uniqueStorage()._content = .ping(newValue)}
  }

  public var feedItem: PBfeed_item {
    get {
      if case .feedItem(let v)? = _storage._content {return v}
      return PBfeed_item()
    }
    set {_uniqueStorage()._content = .feedItem(newValue)}
  }

  public var privacyList: PBprivacy_list {
    get {
      if case .privacyList(let v)? = _storage._content {return v}
      return PBprivacy_list()
    }
    set {_uniqueStorage()._content = .privacyList(newValue)}
  }

  public var privacyListResult: PBprivacy_list_result {
    get {
      if case .privacyListResult(let v)? = _storage._content {return v}
      return PBprivacy_list_result()
    }
    set {_uniqueStorage()._content = .privacyListResult(newValue)}
  }

  public var privacyLists: PBprivacy_lists {
    get {
      if case .privacyLists(let v)? = _storage._content {return v}
      return PBprivacy_lists()
    }
    set {_uniqueStorage()._content = .privacyLists(newValue)}
  }

  public var groupStanza: PBgroup_stanza {
    get {
      if case .groupStanza(let v)? = _storage._content {return v}
      return PBgroup_stanza()
    }
    set {_uniqueStorage()._content = .groupStanza(newValue)}
  }

  public var groupsStanza: PBgroups_stanza {
    get {
      if case .groupsStanza(let v)? = _storage._content {return v}
      return PBgroups_stanza()
    }
    set {_uniqueStorage()._content = .groupsStanza(newValue)}
  }

  public var clientLog: PBclient_log {
    get {
      if case .clientLog(let v)? = _storage._content {return v}
      return PBclient_log()
    }
    set {_uniqueStorage()._content = .clientLog(newValue)}
  }

  public var name: PBname {
    get {
      if case .name(let v)? = _storage._content {return v}
      return PBname()
    }
    set {_uniqueStorage()._content = .name(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case uploadMedia(PBupload_media)
    case contactList(PBcontact_list)
    case uploadAvatar(PBupload_avatar)
    case avatar(PBavatar)
    case avatars(PBavatars)
    case clientMode(PBclient_mode)
    case clientVersion(PBclient_version)
    case pushRegister(PBpush_register)
    case whisperKeys(PBwhisper_keys)
    case ping(PBping)
    case feedItem(PBfeed_item)
    case privacyList(PBprivacy_list)
    case privacyListResult(PBprivacy_list_result)
    case privacyLists(PBprivacy_lists)
    case groupStanza(PBgroup_stanza)
    case groupsStanza(PBgroups_stanza)
    case clientLog(PBclient_log)
    case name(PBname)

  #if !swift(>=4.1)
    public static func ==(lhs: PBiq_payload.OneOf_Content, rhs: PBiq_payload.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.uploadMedia(let l), .uploadMedia(let r)): return l == r
      case (.contactList(let l), .contactList(let r)): return l == r
      case (.uploadAvatar(let l), .uploadAvatar(let r)): return l == r
      case (.avatar(let l), .avatar(let r)): return l == r
      case (.avatars(let l), .avatars(let r)): return l == r
      case (.clientMode(let l), .clientMode(let r)): return l == r
      case (.clientVersion(let l), .clientVersion(let r)): return l == r
      case (.pushRegister(let l), .pushRegister(let r)): return l == r
      case (.whisperKeys(let l), .whisperKeys(let r)): return l == r
      case (.ping(let l), .ping(let r)): return l == r
      case (.feedItem(let l), .feedItem(let r)): return l == r
      case (.privacyList(let l), .privacyList(let r)): return l == r
      case (.privacyListResult(let l), .privacyListResult(let r)): return l == r
      case (.privacyLists(let l), .privacyLists(let r)): return l == r
      case (.groupStanza(let l), .groupStanza(let r)): return l == r
      case (.groupsStanza(let l), .groupsStanza(let r)): return l == r
      case (.clientLog(let l), .clientLog(let r)): return l == r
      case (.name(let l), .name(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct PBmsg_payload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: PBmsg_payload.OneOf_Content? = nil

  public var contactList: PBcontact_list {
    get {
      if case .contactList(let v)? = content {return v}
      return PBcontact_list()
    }
    set {content = .contactList(newValue)}
  }

  public var avatar: PBavatar {
    get {
      if case .avatar(let v)? = content {return v}
      return PBavatar()
    }
    set {content = .avatar(newValue)}
  }

  public var whisperKeys: PBwhisper_keys {
    get {
      if case .whisperKeys(let v)? = content {return v}
      return PBwhisper_keys()
    }
    set {content = .whisperKeys(newValue)}
  }

  public var seen: PBseen_receipt {
    get {
      if case .seen(let v)? = content {return v}
      return PBseen_receipt()
    }
    set {content = .seen(newValue)}
  }

  public var delivery: PBdelivery_receipt {
    get {
      if case .delivery(let v)? = content {return v}
      return PBdelivery_receipt()
    }
    set {content = .delivery(newValue)}
  }

  public var chat: PBchat {
    get {
      if case .chat(let v)? = content {return v}
      return PBchat()
    }
    set {content = .chat(newValue)}
  }

  public var feedItem: PBfeed_item {
    get {
      if case .feedItem(let v)? = content {return v}
      return PBfeed_item()
    }
    set {content = .feedItem(newValue)}
  }

  public var feedItems: PBfeed_items {
    get {
      if case .feedItems(let v)? = content {return v}
      return PBfeed_items()
    }
    set {content = .feedItems(newValue)}
  }

  public var contactHash: PBcontact_hash {
    get {
      if case .contactHash(let v)? = content {return v}
      return PBcontact_hash()
    }
    set {content = .contactHash(newValue)}
  }

  public var groupStanza: PBgroup_stanza {
    get {
      if case .groupStanza(let v)? = content {return v}
      return PBgroup_stanza()
    }
    set {content = .groupStanza(newValue)}
  }

  public var groupChat: PBgroup_chat {
    get {
      if case .groupChat(let v)? = content {return v}
      return PBgroup_chat()
    }
    set {content = .groupChat(newValue)}
  }

  public var name: PBname {
    get {
      if case .name(let v)? = content {return v}
      return PBname()
    }
    set {content = .name(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case contactList(PBcontact_list)
    case avatar(PBavatar)
    case whisperKeys(PBwhisper_keys)
    case seen(PBseen_receipt)
    case delivery(PBdelivery_receipt)
    case chat(PBchat)
    case feedItem(PBfeed_item)
    case feedItems(PBfeed_items)
    case contactHash(PBcontact_hash)
    case groupStanza(PBgroup_stanza)
    case groupChat(PBgroup_chat)
    case name(PBname)

  #if !swift(>=4.1)
    public static func ==(lhs: PBmsg_payload.OneOf_Content, rhs: PBmsg_payload.OneOf_Content) -> Bool {
      switch (lhs, rhs) {
      case (.contactList(let l), .contactList(let r)): return l == r
      case (.avatar(let l), .avatar(let r)): return l == r
      case (.whisperKeys(let l), .whisperKeys(let r)): return l == r
      case (.seen(let l), .seen(let r)): return l == r
      case (.delivery(let l), .delivery(let r)): return l == r
      case (.chat(let l), .chat(let r)): return l == r
      case (.feedItem(let l), .feedItem(let r)): return l == r
      case (.feedItems(let l), .feedItems(let r)): return l == r
      case (.contactHash(let l), .contactHash(let r)): return l == r
      case (.groupStanza(let l), .groupStanza(let r)): return l == r
      case (.groupChat(let l), .groupChat(let r)): return l == r
      case (.name(let l), .name(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct PBha_iq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: PBha_iq.TypeEnum = .get

  public var payload: PBiq_payload {
    get {return _payload ?? PBiq_payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case get // = 0
    case set // = 1
    case result // = 2
    case error // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .get
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .get
      case 1: self = .set
      case 2: self = .result
      case 3: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .get: return 0
      case .set: return 1
      case .result: return 2
      case .error: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _payload: PBiq_payload? = nil
}

#if swift(>=4.2)

extension PBha_iq.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBha_iq.TypeEnum] = [
    .get,
    .set,
    .result,
    .error,
  ]
}

#endif  // swift(>=4.2)

public struct PBha_message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: PBha_message.TypeEnum = .normal

  public var toUid: Int64 = 0

  public var fromUid: Int64 = 0

  public var payload: PBmsg_payload {
    get {return _payload ?? PBmsg_payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case normal // = 0
    case error // = 1
    case groupchat // = 2
    case headline // = 3

    /// Not used yet.
    case chat // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .error
      case 2: self = .groupchat
      case 3: self = .headline
      case 4: self = .chat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .error: return 1
      case .groupchat: return 2
      case .headline: return 3
      case .chat: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _payload: PBmsg_payload? = nil
}

#if swift(>=4.2)

extension PBha_message.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBha_message.TypeEnum] = [
    .normal,
    .error,
    .groupchat,
    .headline,
    .chat,
  ]
}

#endif  // swift(>=4.2)

public struct PBha_presence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: PBha_presence.TypeEnum = .available

  public var uid: Int64 = 0

  public var lastSeen: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case away // = 1
    case subscribe // = 2
    case unsubscribe // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .away
      case 2: self = .subscribe
      case 3: self = .unsubscribe
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .away: return 1
      case .subscribe: return 2
      case .unsubscribe: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension PBha_presence.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBha_presence.TypeEnum] = [
    .available,
    .away,
    .subscribe,
    .unsubscribe,
  ]
}

#endif  // swift(>=4.2)

public struct PBha_chat_state {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: PBha_chat_state.TypeEnum = .available

  public var threadID: String = String()

  public var threadType: PBha_chat_state.ThreadType = .chat

  public var fromUid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case available // = 0
    case typing // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .available
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .available
      case 1: self = .typing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .available: return 0
      case .typing: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ThreadType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case chat // = 0
    case groupChat // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .chat
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .chat
      case 1: self = .groupChat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .chat: return 0
      case .groupChat: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension PBha_chat_state.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBha_chat_state.TypeEnum] = [
    .available,
    .typing,
  ]
}

extension PBha_chat_state.ThreadType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [PBha_chat_state.ThreadType] = [
    .chat,
    .groupChat,
  ]
}

#endif  // swift(>=4.2)

public struct PBha_ack {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var timestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBha_error {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct PBpacket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stanza: PBpacket.OneOf_Stanza? = nil

  public var msg: PBha_message {
    get {
      if case .msg(let v)? = stanza {return v}
      return PBha_message()
    }
    set {stanza = .msg(newValue)}
  }

  public var iq: PBha_iq {
    get {
      if case .iq(let v)? = stanza {return v}
      return PBha_iq()
    }
    set {stanza = .iq(newValue)}
  }

  public var ack: PBha_ack {
    get {
      if case .ack(let v)? = stanza {return v}
      return PBha_ack()
    }
    set {stanza = .ack(newValue)}
  }

  public var presence: PBha_presence {
    get {
      if case .presence(let v)? = stanza {return v}
      return PBha_presence()
    }
    set {stanza = .presence(newValue)}
  }

  public var error: PBha_error {
    get {
      if case .error(let v)? = stanza {return v}
      return PBha_error()
    }
    set {stanza = .error(newValue)}
  }

  public var chatState: PBha_chat_state {
    get {
      if case .chatState(let v)? = stanza {return v}
      return PBha_chat_state()
    }
    set {stanza = .chatState(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Stanza: Equatable {
    case msg(PBha_message)
    case iq(PBha_iq)
    case ack(PBha_ack)
    case presence(PBha_presence)
    case error(PBha_error)
    case chatState(PBha_chat_state)

  #if !swift(>=4.1)
    public static func ==(lhs: PBpacket.OneOf_Stanza, rhs: PBpacket.OneOf_Stanza) -> Bool {
      switch (lhs, rhs) {
      case (.msg(let l), .msg(let r)): return l == r
      case (.iq(let l), .iq(let r)): return l == r
      case (.ack(let l), .ack(let r)): return l == r
      case (.presence(let l), .presence(let r)): return l == r
      case (.error(let l), .error(let r)): return l == r
      case (.chatState(let l), .chatState(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PBchat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "chat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "payload"),
    3: .standard(proto: "enc_payload"),
    4: .standard(proto: "public_key"),
    5: .standard(proto: "one_time_pre_key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.payload)
      case 3: try decoder.decodeSingularBytesField(value: &self.encPayload)
      case 4: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 5: try decoder.decodeSingularInt64Field(value: &self.oneTimePreKeyID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 2)
    }
    if !self.encPayload.isEmpty {
      try visitor.visitSingularBytesField(value: self.encPayload, fieldNumber: 3)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 4)
    }
    if self.oneTimePreKeyID != 0 {
      try visitor.visitSingularInt64Field(value: self.oneTimePreKeyID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBchat, rhs: PBchat) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.encPayload != rhs.encPayload {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.oneTimePreKeyID != rhs.oneTimePreKeyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ping"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBping, rhs: PBping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBname: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "name"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBname, rhs: PBname) -> Bool {
    if lhs.uid != rhs.uid {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBiq_payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "iq_payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upload_media"),
    2: .standard(proto: "contact_list"),
    3: .standard(proto: "upload_avatar"),
    4: .same(proto: "avatar"),
    5: .same(proto: "avatars"),
    6: .standard(proto: "client_mode"),
    7: .standard(proto: "client_version"),
    8: .standard(proto: "push_register"),
    9: .standard(proto: "whisper_keys"),
    10: .same(proto: "ping"),
    11: .standard(proto: "feed_item"),
    12: .standard(proto: "privacy_list"),
    13: .standard(proto: "privacy_list_result"),
    14: .standard(proto: "privacy_lists"),
    15: .standard(proto: "group_stanza"),
    16: .standard(proto: "groups_stanza"),
    17: .standard(proto: "client_log"),
    18: .same(proto: "name"),
  ]

  fileprivate class _StorageClass {
    var _content: PBiq_payload.OneOf_Content?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _content = source._content
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          var v: PBupload_media?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .uploadMedia(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .uploadMedia(v)}
        case 2:
          var v: PBcontact_list?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .contactList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .contactList(v)}
        case 3:
          var v: PBupload_avatar?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .uploadAvatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .uploadAvatar(v)}
        case 4:
          var v: PBavatar?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .avatar(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .avatar(v)}
        case 5:
          var v: PBavatars?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .avatars(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .avatars(v)}
        case 6:
          var v: PBclient_mode?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .clientMode(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .clientMode(v)}
        case 7:
          var v: PBclient_version?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .clientVersion(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .clientVersion(v)}
        case 8:
          var v: PBpush_register?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .pushRegister(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .pushRegister(v)}
        case 9:
          var v: PBwhisper_keys?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .whisperKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .whisperKeys(v)}
        case 10:
          var v: PBping?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .ping(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .ping(v)}
        case 11:
          var v: PBfeed_item?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .feedItem(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .feedItem(v)}
        case 12:
          var v: PBprivacy_list?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .privacyList(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .privacyList(v)}
        case 13:
          var v: PBprivacy_list_result?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .privacyListResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .privacyListResult(v)}
        case 14:
          var v: PBprivacy_lists?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .privacyLists(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .privacyLists(v)}
        case 15:
          var v: PBgroup_stanza?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .groupStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .groupStanza(v)}
        case 16:
          var v: PBgroups_stanza?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .groupsStanza(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .groupsStanza(v)}
        case 17:
          var v: PBclient_log?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .clientLog(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .clientLog(v)}
        case 18:
          var v: PBname?
          if let current = _storage._content {
            try decoder.handleConflictingOneOf()
            if case .name(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._content = .name(v)}
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._content {
      case .uploadMedia(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      case .contactList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .uploadAvatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .avatar(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case .avatars(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      case .clientMode(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .clientVersion(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case .pushRegister(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      case .whisperKeys(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      case .ping(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      case .feedItem(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      case .privacyList(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      case .privacyListResult(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      case .privacyLists(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      case .groupStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      case .groupsStanza(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      case .clientLog(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      case .name(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBiq_payload, rhs: PBiq_payload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._content != rhs_storage._content {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBmsg_payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "msg_payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_list"),
    2: .same(proto: "avatar"),
    3: .standard(proto: "whisper_keys"),
    4: .same(proto: "seen"),
    5: .same(proto: "delivery"),
    6: .same(proto: "chat"),
    7: .standard(proto: "feed_item"),
    8: .standard(proto: "feed_items"),
    9: .standard(proto: "contact_hash"),
    10: .standard(proto: "group_stanza"),
    11: .standard(proto: "group_chat"),
    12: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: PBcontact_list?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .contactList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .contactList(v)}
      case 2:
        var v: PBavatar?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .avatar(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .avatar(v)}
      case 3:
        var v: PBwhisper_keys?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .whisperKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .whisperKeys(v)}
      case 4:
        var v: PBseen_receipt?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .seen(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .seen(v)}
      case 5:
        var v: PBdelivery_receipt?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .delivery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .delivery(v)}
      case 6:
        var v: PBchat?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .chat(v)}
      case 7:
        var v: PBfeed_item?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .feedItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .feedItem(v)}
      case 8:
        var v: PBfeed_items?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .feedItems(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .feedItems(v)}
      case 9:
        var v: PBcontact_hash?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .contactHash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .contactHash(v)}
      case 10:
        var v: PBgroup_stanza?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .groupStanza(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .groupStanza(v)}
      case 11:
        var v: PBgroup_chat?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .groupChat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .groupChat(v)}
      case 12:
        var v: PBname?
        if let current = self.content {
          try decoder.handleConflictingOneOf()
          if case .name(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.content = .name(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.content {
    case .contactList(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .avatar(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .whisperKeys(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .seen(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .delivery(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .chat(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .feedItem(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    case .feedItems(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    case .contactHash(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    case .groupStanza(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    case .groupChat(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    case .name(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBmsg_payload, rhs: PBmsg_payload) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBha_iq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ha_iq"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularMessageField(value: &self._payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .get {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBha_iq, rhs: PBha_iq) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBha_iq.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "get"),
    1: .same(proto: "set"),
    2: .same(proto: "result"),
    3: .same(proto: "error"),
  ]
}

extension PBha_message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ha_message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "to_uid"),
    4: .standard(proto: "from_uid"),
    5: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularInt64Field(value: &self.toUid)
      case 4: try decoder.decodeSingularInt64Field(value: &self.fromUid)
      case 5: try decoder.decodeSingularMessageField(value: &self._payload)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .normal {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.toUid != 0 {
      try visitor.visitSingularInt64Field(value: self.toUid, fieldNumber: 3)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 4)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBha_message, rhs: PBha_message) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.toUid != rhs.toUid {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBha_message.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "normal"),
    1: .same(proto: "error"),
    2: .same(proto: "groupchat"),
    3: .same(proto: "headline"),
    4: .same(proto: "chat"),
  ]
}

extension PBha_presence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ha_presence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "uid"),
    4: .standard(proto: "last_seen"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      case 3: try decoder.decodeSingularInt64Field(value: &self.uid)
      case 4: try decoder.decodeSingularInt64Field(value: &self.lastSeen)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.uid != 0 {
      try visitor.visitSingularInt64Field(value: self.uid, fieldNumber: 3)
    }
    if self.lastSeen != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSeen, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBha_presence, rhs: PBha_presence) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.uid != rhs.uid {return false}
    if lhs.lastSeen != rhs.lastSeen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBha_presence.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "available"),
    1: .same(proto: "away"),
    2: .same(proto: "subscribe"),
    3: .same(proto: "unsubscribe"),
  ]
}

extension PBha_chat_state: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ha_chat_state"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "thread_id"),
    3: .standard(proto: "thread_type"),
    4: .standard(proto: "from_uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.threadID)
      case 3: try decoder.decodeSingularEnumField(value: &self.threadType)
      case 4: try decoder.decodeSingularInt64Field(value: &self.fromUid)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .available {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.threadID.isEmpty {
      try visitor.visitSingularStringField(value: self.threadID, fieldNumber: 2)
    }
    if self.threadType != .chat {
      try visitor.visitSingularEnumField(value: self.threadType, fieldNumber: 3)
    }
    if self.fromUid != 0 {
      try visitor.visitSingularInt64Field(value: self.fromUid, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBha_chat_state, rhs: PBha_chat_state) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.threadID != rhs.threadID {return false}
    if lhs.threadType != rhs.threadType {return false}
    if lhs.fromUid != rhs.fromUid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBha_chat_state.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "available"),
    1: .same(proto: "typing"),
  ]
}

extension PBha_chat_state.ThreadType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "chat"),
    1: .same(proto: "group_chat"),
  ]
}

extension PBha_ack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ha_ack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBha_ack, rhs: PBha_ack) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBha_error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ha_error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBha_error, rhs: PBha_error) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PBpacket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "packet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msg"),
    2: .same(proto: "iq"),
    3: .same(proto: "ack"),
    4: .same(proto: "presence"),
    5: .same(proto: "error"),
    6: .standard(proto: "chat_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: PBha_message?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .msg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .msg(v)}
      case 2:
        var v: PBha_iq?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .iq(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .iq(v)}
      case 3:
        var v: PBha_ack?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .ack(v)}
      case 4:
        var v: PBha_presence?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .presence(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .presence(v)}
      case 5:
        var v: PBha_error?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .error(v)}
      case 6:
        var v: PBha_chat_state?
        if let current = self.stanza {
          try decoder.handleConflictingOneOf()
          if case .chatState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.stanza = .chatState(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.stanza {
    case .msg(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .iq(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .ack(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .presence(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .error(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .chatState(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: PBpacket, rhs: PBpacket) -> Bool {
    if lhs.stanza != rhs.stanza {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
